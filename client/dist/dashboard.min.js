function parseScoreFromResult(resultString) {
    if (!resultString) return { away: null, home: null };
    const scorePattern = /(\d+)\s*-\s*(\d+)/;
    const match = resultString.match(scorePattern);
    if (match) {
        return {
            away: parseInt(match[1]),
            home: parseInt(match[2])
        };
    }
    return { away: null, home: null };
}
function normalizeStatus(status) {
    const value = (status || '').toString().toLowerCase();
    return value === 'lost' ? 'loss' : value;
}
function calculateKPIs(picks) {
    if (!picks || !Array.isArray(picks)) {
        picks = [];
    }
    const kpis = {
        activePicks: 0,
        activeRisk: 0,
        toWin: 0,
        onTrackAmount: 0,
        atRiskAmount: 0,
        projected: 0,
        netProfit: 0,
        totalWon: 0,
        totalLost: 0,
        wins: 0,
        losses: 0,
        pushes: 0,
        roePercentage: 0,
        winPercentage: 0,
        currentStreak: '',
        totalRisk: 0,
        topLeague: { name: 'N/A', winRate: 0 },
        topBetType: { name: 'N/A', winRate: 0 },
        topSegment: { name: 'N/A', winRate: 0 },
        topSportsbook: { name: 'N/A', winRate: 0 }
    };
    const leagueStats = {};
    const betTypeStats = {};
    const segmentStats = {};
    const sportsbookStats = {};
    picks.forEach(pick => {
        const riskStr = pick.risk != null ? String(pick.risk).replace(/,/g, '') : '0', risk = parseFloat(riskStr) || 0;
        const winStr = pick.win != null ? String(pick.win).replace(/,/g, '') : '0', win = parseFloat(winStr) || 0;
        const status = normalizeStatus(pick.status);
        const isLoss = status === 'loss';
        if (status === 'pending' || status === 'live' || status === 'on-track' || status === 'at-risk') {
            kpis.activePicks++;
            kpis.toWin += win;
            kpis.activeRisk += risk;
            if (status === 'on-track') {
                kpis.onTrackAmount += win; 
            } else if (status === 'at-risk') {
                kpis.atRiskAmount += risk; 
            } else if (status === 'pending') {
                kpis.onTrackAmount += win * 0.5; 
                kpis.atRiskAmount += risk * 0.5;
            }
        }
        if (status === 'win') {
            kpis.wins++;
            kpis.totalWon += win;
            trackWin(leagueStats, pick.league || 'Unknown');
            trackWin(betTypeStats, pick.pickType || 'Unknown');
            trackWin(segmentStats, pick.segment || 'Full Game');
            trackWin(sportsbookStats, pick.book || 'Unknown');
        }
        if (isLoss) {
            kpis.losses++;
            kpis.totalLost += risk;
            trackLoss(leagueStats, pick.league || 'Unknown');
            trackLoss(betTypeStats, pick.pickType || 'Unknown');
            trackLoss(segmentStats, pick.segment || 'Full Game');
            trackLoss(sportsbookStats, pick.book || 'Unknown');
        }
        if (status === 'push') {
            kpis.pushes++;
        }
        kpis.totalRisk += risk;
    });
    kpis.projected = kpis.toWin - kpis.activeRisk;
    kpis.netProfit = kpis.totalWon - kpis.totalLost;
    const totalGames = kpis.wins + kpis.losses + kpis.pushes;
    if (totalGames > 0) {
        kpis.winPercentage = ((kpis.wins / (kpis.wins + kpis.losses)) * 100).toFixed(1);
    }
    if (kpis.totalRisk > 0) {
        kpis.roePercentage = ((kpis.netProfit / kpis.totalRisk) * 100).toFixed(1);
    }
    kpis.currentStreak = calculateStreak(picks);
    kpis.topLeague = findTopPerformer(leagueStats);
    kpis.topBetType = findTopPerformer(betTypeStats);
    kpis.topSegment = findTopPerformer(segmentStats);
    kpis.topSportsbook = findTopPerformer(sportsbookStats);
    return kpis;
}
function trackWin(stats, key) {
    if (!stats[key]) stats[key] = { wins: 0, losses: 0 };
    stats[key].wins++;
}
function trackLoss(stats, key) {
    if (!stats[key]) stats[key] = { wins: 0, losses: 0 };
    stats[key].losses++;
}
function findTopPerformer(stats) {
    let topName = 'N/A';
    let topWinRate = 0;
    for (const [name, record] of Object.entries(stats)) {
        const total = record.wins + record.losses;
        if (total >= 3) { 
            const winRate = (record.wins / total) * 100;
            if (winRate > topWinRate) {
                topWinRate = winRate;
                topName = name;
            }
        }
    }
    return { name: topName, winRate: topWinRate.toFixed(1) };
}
function calculateStreak(picks) {
    const finishedPicks = picks.filter(p => {
        const status = normalizeStatus(p.status);
        return status === 'win' || status === 'loss';
    }).reverse(); 
    if (finishedPicks.length === 0) return 'W0';
    let streak = 1;
    const lastStatus = normalizeStatus(finishedPicks[0].status);
    for (let i = 1; i < finishedPicks.length; i++) {
        if (normalizeStatus(finishedPicks[i].status) === lastStatus) {
            streak++;
        } else {
            break;
        }
    }
    return lastStatus === 'win' ? `W${streak}` : `L${streak}`;
}
function updateKPITiles(kpis) {
    const tile1 = document.querySelector('[data-tile-id="1"]');
    if (tile1) {
        const frontValueEl = tile1.querySelector('.kpi-tile-layer.active .kpi-value');
        const frontSubtextEl = tile1.querySelector('.kpi-tile-layer.active .kpi-subtext');
        if (frontValueEl) {
            const projectedSign = kpis.projected >= 0 ? '+' : '';
            frontValueEl.textContent = `${projectedSign}$${Math.abs(kpis.projected).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`;
            frontValueEl.classList.remove('positive', 'negative');
            if (kpis.projected > 0) {
                frontValueEl.classList.add('positive');
            } else if (kpis.projected < 0) {
                frontValueEl.classList.add('negative');
            }
        }
        if (frontSubtextEl) {
            frontSubtextEl.textContent = `${kpis.activePicks} Active Pick${kpis.activePicks !== 1 ? 's' : ''}`;
        }
        const backValueEl = tile1.querySelector('.kpi-tile-layer:not(.active) .kpi-value');
        const backSubtextEl = tile1.querySelector('.kpi-tile-layer:not(.active) .kpi-subtext');
        if (backValueEl) {
            const netSign = kpis.netProfit >= 0 ? '+' : '';
            backValueEl.textContent = `${netSign}$${Math.abs(kpis.netProfit).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`;
            backValueEl.classList.remove('positive', 'negative');
            if (kpis.netProfit > 0) backValueEl.classList.add('positive');
            else if (kpis.netProfit < 0) backValueEl.classList.add('negative');
        }
    }
    const tile2 = document.querySelector('[data-tile-id="2"]');
    if (tile2) {
        const frontValueEl = tile2.querySelector('.kpi-tile-layer.active .kpi-value');
        const frontSubtextEl = tile2.querySelector('.kpi-tile-layer.active .kpi-subtext');
        if (frontValueEl) {
            frontValueEl.textContent = `${kpis.winPercentage || 0}%`;
        }
        if (frontSubtextEl) {
            frontSubtextEl.textContent = `${kpis.wins}-${kpis.losses}-${kpis.pushes} Record`;
        }
        const backValueEl = tile2.querySelector('.kpi-tile-layer:not(.active) .kpi-value');
        if (backValueEl) {
            const roiSign = parseFloat(kpis.roePercentage) >= 0 ? '+' : '';
            backValueEl.textContent = `${roiSign}${kpis.roePercentage || 0}%`;
            backValueEl.classList.remove('positive', 'negative');
            if (parseFloat(kpis.roePercentage) > 0) backValueEl.classList.add('positive');
            else if (parseFloat(kpis.roePercentage) < 0) backValueEl.classList.add('negative');
        }
    }
    const tile3 = document.querySelector('[data-tile-id="3"]');
    if (tile3) {
        const frontValueEl = tile3.querySelector('.kpi-tile-layer.active .kpi-value');
        const frontSubtextEl = tile3.querySelector('.kpi-tile-layer.active .kpi-subtext');
        if (frontValueEl) {
            frontValueEl.textContent = `$${kpis.activeRisk.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`;
        }
        if (frontSubtextEl) {
            frontSubtextEl.textContent = `Total Risk`;
        }
        const backValueEl = tile3.querySelector('.kpi-tile-layer:not(.active) .kpi-value');
        if (backValueEl) {
            backValueEl.textContent = `$${kpis.toWin.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`;
        }
    }
}
window.calculateKPIs = calculateKPIs;
window.updateKPITiles = updateKPITiles;
window.parseScoreFromResult = parseScoreFromResult;
const teamMap = {
    'raiders': { full: 'Las Vegas Raiders', abbr: 'LV', logo: 'lv' },
    'broncos': { full: 'Denver Broncos', abbr: 'DEN', logo: 'den' },
    'suns': { full: 'Phoenix Suns', abbr: 'PHX', logo: 'phx', league: 'nba' },
    'clippers': { full: 'Los Angeles Clippers', abbr: 'LAC', logo: 'lac', league: 'nba' },
    'georgia southern': { full: 'Georgia Southern', abbr: 'GASO', logo: 'gaso', league: 'college' },
    'appalachian st': { full: 'Appalachian State', abbr: 'APP', logo: 'app', league: 'college' },
    'utsa': { full: 'UTSA', abbr: 'UTSA', logo: 'utsa', league: 'college' },
    'south florida': { full: 'South Florida', abbr: 'USF', logo: 'usf', league: 'college' }
};
let teamRecordsCache = null;
let teamRecordsPromise = null;
const globalScope = typeof window !== 'undefined' ? window : globalThis;
if (globalScope && typeof globalScope.__TEAM_RECORDS_PROMISE__ === 'undefined') {
    globalScope.__TEAM_RECORDS_PROMISE__ = null;
}
function normalizeTeamRecordValue(value) {
    if (value === undefined || value === null) return '';
    const cleaned = String(value).trim().replace(/[()]/g, '');
    return cleaned ? `(${cleaned})` : '';
}
function getTeamRecordFromCache(teamKey) {
    if (!teamRecordsCache || !teamKey) return '';
    const upperKey = teamKey.toUpperCase();
    return teamRecordsCache[upperKey] ||
        teamRecordsCache[teamKey] ||
        teamRecordsCache[upperKey.toLowerCase()] ||
        '';
}
function populateTeamRecords(root = document, options = {}) {
    if (!teamRecordsCache) return;
    const { force = false } = options;
    const scope = (root && typeof root.querySelectorAll === 'function') ? root : document;
    scope.querySelectorAll('.team-record[data-team], .boxscore-team-record[data-team]').forEach(el => {
        if (!force && el.textContent && el.textContent.trim()) {
            return;
        }
        const teamKey = el.getAttribute('data-team');
        const recordValue = getTeamRecordFromCache(teamKey);
        if (recordValue) {
            el.textContent = normalizeTeamRecordValue(recordValue);
        }
    });
}
function populateTeamRecordsWhenReady(root = document, options = {}) {
    if (!root || typeof populateTeamRecords !== 'function') {
        return;
    }
    const runPopulate = () => populateTeamRecords(root, options);
    if (teamRecordsCache) {
        runPopulate();
        return;
    }
    const pending = teamRecordsPromise || (typeof loadTeamRecords === 'function' ? loadTeamRecords() : null);
    if (pending && typeof pending.then === 'function') {
        pending
            .then(() => runPopulate())
            .catch(err => console.warn('[RECORDS] Deferred populate failed:', err));
    }
}
if (globalScope) {
    globalScope.populateTeamRecords = populateTeamRecords;
    globalScope.populateTeamRecordsWhenReady = populateTeamRecordsWhenReady;
}
function parsePickDescription(description) {
    const result = {
        matchup: '',
        pickType: '',
        pickTeam: '',
        line: '',
        odds: '',
        segment: 'Full Game',
        isTeamTotal: false
    };
    const oddsMatch = description.match(/\(([+-]\d+)\)/);
    if (oddsMatch) {
        result.odds = oddsMatch[1];
    }
    if (description.includes('1st Half')) {
        result.segment = '1st Half';
    } else if (description.includes('2nd Half')) {
        result.segment = '2nd Half';
    } else if (description.includes('1st Quarter')) {
        result.segment = '1st Quarter';
    }
    const teamTotalMatch = description.match(/^(.+?)\s+([OU])\s+(\d+\.?\d*)/i);
    if (teamTotalMatch && !description.includes('@')) {
        result.pickTeam = teamTotalMatch[1].trim();
        result.pickType = teamTotalMatch[2].toUpperCase() === 'O' ? 'Over' : 'Under';
        result.line = teamTotalMatch[3];
        result.isTeamTotal = true;
        return result;
    }
    if (description.match(/under|over/i)) {
        const totalMatch = description.match(/(under|over)\s+(\d+\.?\d*)/i);
        if (totalMatch) {
            result.pickType = totalMatch[1].charAt(0).toUpperCase() + totalMatch[1].slice(1);
            result.line = totalMatch[2];
            result.isTeamTotal = false; 
        }
    } else if (description.match(/moneyline|ml/i)) {
        result.pickType = 'Moneyline';
        const mlMatch = description.match(/^(.+?)\s+(?:Moneyline|ML)/i);
        if (mlMatch) {
            result.pickTeam = mlMatch[1].replace(/@.*$/, '').trim();
        }
    } else {
        const spreadMatch = description.match(/^(.+?)\s+([+-]\d+\.?\d*)/);
        if (spreadMatch) {
            result.pickTeam = spreadMatch[1].replace(/@.*$/, '').trim();
            result.pickType = 'Spread';
            result.line = spreadMatch[2];
        }
    }
    return result;
}
function parseTeamsFromGame(gameString) {
    if (!gameString) return { away: '', home: '' };
    const separators = ['@', ' / ', ' vs ', ' vs. '];
    for (let sep of separators) {
        if (gameString.includes(sep)) {
            const parts = gameString.split(sep);
            return {
                away: parts[0].trim(),
                home: parts[1].trim()
            };
        }
    }
    return { away: gameString, home: '' };
}
function getTeamAbbr(teamName) {
    const teamLookup = {
        'las vegas raiders': 'LV',
        'raiders': 'LV',
        'denver broncos': 'DEN',
        'broncos': 'DEN',
        'phoenix suns': 'PHX',
        'suns': 'PHX',
        'los angeles clippers': 'LAC',
        'clippers': 'LAC',
        'georgia southern': 'GASO',
        'appalachian st': 'APP',
        'appalachian state': 'APP',
        'utsa': 'UTSA',
        'south florida': 'USF',
        'butler': 'BUT',
        'connecticut': 'CONN',
        'u conn': 'CONN',
        'uconn': 'CONN',
        'abilene christian': 'ACU',
        'arizona': 'ARIZ',
        'montana st': 'MTST',
        'montana state': 'MTST',
        'cal poly slo': 'CPSU',
        'cal poly': 'CPSU',
        'oral roberts': 'ORU',
        'missouri st': 'MOST',
        'missouri state': 'MOST',
        'marist': 'MAR',
        'georgia tech': 'GT',
        'east tenn st': 'ETSU',
        'east tennessee st': 'ETSU',
        'east tennessee state': 'ETSU',
        'north carolina': 'UNC',
        'unc': 'UNC',
        'san antonio spurs': 'SAS',
        'spurs': 'SAS',
        'new york knicks': 'NYK',
        'knicks': 'NYK'
    };
    const key = (teamName || '').toLowerCase();
    if (teamLookup[key]) {
        return teamLookup[key];
    }
    const parts = (teamName || '')
        .match(/[A-Za-z0-9]+/g);
    if (parts && parts.length > 1) {
        const acronym = parts.map(part => part[0]).join('').toUpperCase();
        if (acronym.length >= 2 && acronym.length <= 4) {
            return acronym;
        }
    }
    return (teamName || '').substring(0, 3).toUpperCase();
}
function getTeamLogoId(teamName) {
    const ncaaIds = {
        'georgia southern': '290',
        'appalachian st': '2026',
        'appalachian state': '2026',
        'utsa': '2636',
        'south florida': '58',
        'butler': '2086',
        'connecticut': '41',
        'u conn': '41',
        'uconn': '41',
        'abilene christian': '2000',
        'arizona': '12',
        'montana st': '149',
        'montana state': '149',
        'cal poly slo': '13',
        'cal poly': '13',
        'oral roberts': '198',
        'missouri st': '2623',
        'missouri state': '2623',
        'marist': '2368',
        'georgia tech': '59',
        'east tenn st': '2193',
        'east tennessee st': '2193',
        'east tennessee state': '2193',
        'north carolina': '153',
        'unc': '153'
    };
    const key = teamName.toLowerCase();
    if (ncaaIds[key]) {
        return ncaaIds[key];
    }
    return getTeamAbbr(teamName).toLowerCase();
}
function getTeamLogo(teamName, league = 'nfl') {
    if (window.LogoCache && window.LogoCache.getTeamLogo) {
        window.LogoCache.getTeamLogo(teamName, league).catch(err => {
            console.warn('Logo cache error:', err);
        });
    }
    const logoId = getTeamLogoId(teamName);
    if (league === 'nba') {
        return `https://a.espncdn.com/i/teamlogos/nba/500/${logoId}.png`;
    } else if (league === 'college' || league.includes('ncaa') || league === 'ncaab' || league === 'ncaaf') {
        return `https://a.espncdn.com/i/teamlogos/ncaa/500/${logoId}.png`;
    } else {
        return `https://a.espncdn.com/i/teamlogos/nfl/500/${logoId}.png`;
    }
}
function generatePickDisplay(parsedPick, teamLogo, teamAbbr, teamName) {
    if ((parsedPick.pickType === 'Over' || parsedPick.pickType === 'Under') && !parsedPick.isTeamTotal) {
        return `
            <div class="pick-details">
                <span class="pick-line">${parsedPick.pickType} ${parsedPick.line}</span>
                ${parsedPick.odds ? `<span class="pick-odds">(${parsedPick.odds})</span>` : ''}
            </div>
        `;
    }
    if (parsedPick.isTeamTotal) {
        return `
            <div class="pick-team-info">
                <img src="${teamLogo}" class="pick-team-logo" alt="${teamAbbr}">
                <span class="pick-team-abbr">${teamAbbr}</span>
            </div>
            <div class="pick-details">
                <span class="pick-line">${parsedPick.pickType} ${parsedPick.line}</span>
                ${parsedPick.odds ? `<span class="pick-odds">(${parsedPick.odds})</span>` : ''}
            </div>
        `;
    }
    if (parsedPick.pickType === 'Moneyline') {
        return `
            <div class="pick-team-info">
                <img src="${teamLogo}" class="pick-team-logo" alt="${teamAbbr}">
                <span class="pick-team-abbr">${teamAbbr}</span>
            </div>
            <div class="pick-details">
                ${parsedPick.odds ? `<span class="pick-odds">(${parsedPick.odds})</span>` : ''}
            </div>
        `;
    }
    if (parsedPick.pickType === 'Spread') {
        return `
            <div class="pick-team-info">
                <img src="${teamLogo}" class="pick-team-logo" alt="${teamAbbr}">
                <span class="pick-team-abbr">${teamAbbr}</span>
            </div>
            <div class="pick-details">
                <span class="pick-line">${parsedPick.line}</span>
                ${parsedPick.odds ? `<span class="pick-odds">(${parsedPick.odds})</span>` : ''}
            </div>
        `;
    }
    return `
        <div class="pick-team-info">
            <img src="${teamLogo}" class="pick-team-logo" alt="${teamAbbr}">
            <span class="pick-team-abbr">${teamAbbr}</span>
        </div>
        <div class="pick-details">
            ${parsedPick.pickType ? `<span class="pick-type">${parsedPick.pickType}</span>` : ''}
            ${parsedPick.line ? `<span class="pick-line">${parsedPick.line}</span>` : ''}
            ${parsedPick.odds ? `<span class="pick-odds">(${parsedPick.odds})</span>` : ''}
        </div>
    `;
}
function createBoxScoreRows(pick, awayLogo, awayAbbr, homeLogo, homeAbbr, statusClass) {
    let awayScore = '—';
    let homeScore = '—';
    let awayRowClass = '';
    let homeRowClass = '';
    let q1_away = '—', q2_away = '—', q3_away = '—', q4_away = '—';
    let q1_home = '—', q2_home = '—', q3_home = '—', q4_home = '—';
    if (pick.quarters) {
        q1_away = pick.quarters.q1_away !== undefined ? pick.quarters.q1_away : '—';
        q2_away = pick.quarters.q2_away !== undefined ? pick.quarters.q2_away : '—';
        q3_away = pick.quarters.q3_away !== undefined ? pick.quarters.q3_away : '—';
        q4_away = pick.quarters.q4_away !== undefined ? pick.quarters.q4_away : '—';
        q1_home = pick.quarters.q1_home !== undefined ? pick.quarters.q1_home : '—';
        q2_home = pick.quarters.q2_home !== undefined ? pick.quarters.q2_home : '—';
        q3_home = pick.quarters.q3_home !== undefined ? pick.quarters.q3_home : '—';
        q4_home = pick.quarters.q4_home !== undefined ? pick.quarters.q4_home : '—';
    }
    if (pick.result) {
        const numbers = pick.result.match(/\d+/g);
        if (numbers && numbers.length >= 2) {
            awayScore = numbers[0];
            homeScore = numbers[1];
            const awayNum = parseInt(awayScore);
            const homeNum = parseInt(homeScore);
            if (awayNum > homeNum) {
                awayRowClass = 'winning';
                homeRowClass = 'losing';
            } else if (homeNum > awayNum) {
                homeRowClass = 'winning';
                awayRowClass = 'losing';
            }
        }
    }
    return `
        <div class="boxscore-row ${awayRowClass}">
            <div class="boxscore-cell team-cell">
                <div class="boxscore-team">
                    <img src="${awayLogo}" class="boxscore-team-logo" alt="${awayAbbr}">
                    <span class="boxscore-team-abbr">${awayAbbr}</span>
                    <span class="boxscore-team-record" data-team="${awayAbbr}"></span>
                </div>
            </div>
            <div class="boxscore-cell">${q1_away}</div>
            <div class="boxscore-cell">${q2_away}</div>
            <div class="boxscore-cell">${q3_away}</div>
            <div class="boxscore-cell">${q4_away}</div>
            <div class="boxscore-cell total">${awayScore}</div>
        </div>
        <div class="boxscore-row ${homeRowClass}">
            <div class="boxscore-cell team-cell">
                <div class="boxscore-team">
                    <img src="${homeLogo}" class="boxscore-team-logo" alt="${homeAbbr}">
                    <span class="boxscore-team-abbr">${homeAbbr}</span>
                    <span class="boxscore-team-record" data-team="${homeAbbr}"></span>
                </div>
            </div>
            <div class="boxscore-cell">${q1_home}</div>
            <div class="boxscore-cell">${q2_home}</div>
            <div class="boxscore-cell">${q3_home}</div>
            <div class="boxscore-cell">${q4_home}</div>
            <div class="boxscore-cell total">${homeScore}</div>
        </div>
    `;
}
function normalizeTeamKey(value) {
    return (value || '').toString().toLowerCase().replace(/[^a-z0-9]/g, '');
}
function sanitizeSelectionName(selection) {
    return (selection || '')
        .replace(/\([^)]+\)/g, '')
        .replace(/[+-]\d+(\.\d+)?/g, '')
        .replace(/\b(ml|moneyline|spread|total|over|under|team total|tt)\b/gi, '')
        .replace(/\s+/g, ' ')
        .trim();
}
function matchPickSide(pickTeamName, teams) {
    const pickKey = normalizeTeamKey(pickTeamName);
    if (!pickKey) return null;
    const awayKey = normalizeTeamKey(teams.away);
    const homeKey = normalizeTeamKey(teams.home);
    const awayAbbrKey = normalizeTeamKey(getTeamAbbr(teams.away || ''));
    const homeAbbrKey = normalizeTeamKey(getTeamAbbr(teams.home || ''));
    if (awayKey && (awayKey.includes(pickKey) || pickKey.includes(awayKey))) return 'away';
    if (homeKey && (homeKey.includes(pickKey) || pickKey.includes(homeKey))) return 'home';
    if (awayAbbrKey && awayAbbrKey === pickKey) return 'away';
    if (homeAbbrKey && homeAbbrKey === pickKey) return 'home';
    return null;
}
function parsePhaseDetails(phaseRaw = '') {
    const phase = (phaseRaw || '').trim();
    if (!phase) {
        return { isFinal: false, isHalftime: false, isPreGame: false, clock: '', period: '', label: '' };
    }
    const upper = phase.toUpperCase();
    const isFinal = upper.includes('FINAL');
    const isHalftime = !isFinal && upper.includes('HALF');
    const isPreGame = /ET|AM|PM|START|TIP|PREGAME|SCHEDULED|KICK/i.test(upper) && !isFinal;
    const clockMatch = phase.match(/(\d{1,2}:\d{2})/);
    const clock = clockMatch ? clockMatch[1] : '';
    const periodMatch = phase.match(/(Q\d+|OT|1ST|2ND|3RD|4TH|OT|1H|2H)/i);
    let period = periodMatch ? periodMatch[1].toUpperCase() : '';
    if (period === '1ST') period = 'Q1';
    else if (period === '2ND') period = 'Q2';
    else if (period === '3RD') period = 'Q3';
    else if (period === '4TH') period = 'Q4';
    let label = '';
    if (isFinal) {
        label = 'Final';
    } else if (isHalftime) {
        label = 'Halftime';
    } else if (clock && period) {
        label = `${clock} left in ${period}`;
    } else if (clock) {
        label = `${clock} left`;
    } else if (period) {
        label = period;
    } else {
        label = phase;
    }
    return { isFinal, isHalftime, isPreGame, clock, period, label };
}
function extractScoreboardDetails(resultText, matchup) {
    const text = (resultText || '').trim();
    if (!text) return null;
    const phaseMatch = text.match(/\(([^)]+)\)/);
    const phase = phaseMatch ? phaseMatch[1].trim() : '';
    const scorePortion = phaseMatch ? text.replace(phaseMatch[0], '').trim() : text;
    const scorePattern = scorePortion.match(/^([A-Za-z0-9 .&'’-]+)\s+(\d+)\s*[-–]\s*(\d+)/);
    const teams = parseTeamsFromGame(matchup || '');
    const phaseDetails = parsePhaseDetails(phase);
    if (!scorePattern) {
        return {
            raw: text,
            phaseRaw: phase,
            phaseLabel: phaseDetails.label,
            isFinal: phaseDetails.isFinal,
            isHalftime: phaseDetails.isHalftime,
            isPreGame: phaseDetails.isPreGame,
            clock: phaseDetails.clock,
            period: phaseDetails.period,
            teams
        };
    }
    const firstLabel = scorePattern[1].trim();
    const firstScore = parseInt(scorePattern[2], 10);
    const secondScore = parseInt(scorePattern[3], 10);
    const awayAbbrRaw = getTeamAbbr(teams.away || firstLabel);
    const homeAbbrRaw = getTeamAbbr(teams.home || '');
    const firstLabelKey = normalizeTeamKey(firstLabel);
    const awayKey = normalizeTeamKey(awayAbbrRaw || teams.away);
    const homeKey = normalizeTeamKey(homeAbbrRaw || teams.home);
    let awayScore = firstScore;
    let homeScore = secondScore;
    if (homeKey && firstLabelKey && firstLabelKey === homeKey) {
        homeScore = firstScore;
        awayScore = secondScore;
    }
    const fallbackAbbr = name => {
        const parts = (name || '').trim().split(/\s+/).filter(Boolean);
        if (!parts.length) return '';
        const acronym = parts.map(part => part[0]).join('').toUpperCase();
        if (acronym.length >= 2 && acronym.length <= 4) return acronym;
        return (name || '').substring(0, 3).toUpperCase();
    };
    const awayAbbr = awayAbbrRaw || fallbackAbbr(teams.away || 'Away') || 'AWY';
    const homeAbbr = homeAbbrRaw || fallbackAbbr(teams.home || 'Home') || 'HME';
    const scoreboardText = `${awayAbbr} ${awayScore}-${homeAbbr} ${homeScore}`;
    return {
        raw: text,
        phaseRaw: phase,
        phaseLabel: phaseDetails.label,
        isFinal: phaseDetails.isFinal,
        isHalftime: phaseDetails.isHalftime,
        isPreGame: phaseDetails.isPreGame,
        clock: phaseDetails.clock,
        period: phaseDetails.period,
        awayScore,
        homeScore,
        awayAbbr,
        homeAbbr,
        teams,
        scoreboardText
    };
}
function determinePickMeta(payload) {
    const matchup = payload.matchup || payload.game || '';
    const selection = payload.selection || payload.description || '';
    const parsed = payload.parsedPick || (selection ? parsePickDescription(selection) : null);
    const teams = parseTeamsFromGame(matchup);
    const meta = {
        type: 'unknown',
        side: null,
        lineValue: null,
        isOver: false,
        isUnder: false,
        parsedPick: parsed,
        teams
    };
    if (parsed) {
        const pickType = (parsed.pickType || '').toLowerCase();
        if (parsed.isTeamTotal) {
            meta.type = 'team-total';
            meta.isOver = pickType === 'over';
            meta.isUnder = pickType === 'under';
        } else if (pickType === 'moneyline') {
            meta.type = 'moneyline';
        } else if (pickType === 'spread') {
            meta.type = 'spread';
        } else if (pickType === 'over' || pickType === 'under') {
            meta.type = 'total';
            meta.isOver = pickType === 'over';
            meta.isUnder = pickType === 'under';
        }
        if (parsed.line !== undefined && parsed.line !== null && parsed.line !== '') {
            const numericLine = parseFloat(String(parsed.line).replace(/[^\d.-]/g, ''));
            if (!Number.isNaN(numericLine)) {
                meta.lineValue = numericLine;
            }
        }
    }
    if (meta.type === 'unknown') {
        const marketString = (payload.market || '').toLowerCase();
        const selectionLower = selection.toLowerCase();
        if (marketString.includes('moneyline') || /moneyline|ml/.test(selectionLower)) {
            meta.type = 'moneyline';
        } else if (marketString.includes('spread') || /[+-]\d/.test(selectionLower)) {
            meta.type = 'spread';
        } else if (marketString.includes('total') || /over|under/.test(selectionLower)) {
            meta.type = 'total';
        }
    }
    if ((meta.type === 'moneyline' || meta.type === 'spread' || meta.type === 'team-total') && !meta.side) {
        const pickTeamName = parsed?.pickTeam || sanitizeSelectionName(selection);
        meta.side = matchPickSide(pickTeamName, teams);
    }
    if (meta.type === 'total' && meta.lineValue == null) {
        const lineMatch = selection.match(/(\d+\.?\d*)/);
        if (lineMatch) {
            const numericLine = parseFloat(lineMatch[1]);
            if (!Number.isNaN(numericLine)) {
                meta.lineValue = numericLine;
            }
        }
    }
    if (meta.type === 'team-total' && meta.lineValue == null) {
        const ttMatch = selection.match(/(\d+\.?\d*)/);
        if (ttMatch) {
            const numericLine = parseFloat(ttMatch[1]);
            if (!Number.isNaN(numericLine)) {
                meta.lineValue = numericLine;
            }
        }
        if (!meta.isOver && !meta.isUnder) {
            if (/over/i.test(selection)) meta.isOver = true;
            if (/under/i.test(selection)) meta.isUnder = true;
        }
    }
    return meta;
}
function evaluateCoverage(liveInfo, pickMeta) {
    if (!liveInfo) return { coverageState: 'unknown' };
    if (!pickMeta || typeof pickMeta !== 'object') return { coverageState: 'unknown' };
    const { type, side, lineValue, isOver, isUnder } = pickMeta;
    if (liveInfo.awayScore == null || liveInfo.homeScore == null) {
        return { coverageState: 'unknown' };
    }
    if (type === 'total') {
        if (!Number.isFinite(lineValue)) return { coverageState: 'unknown', type };
        const totalScore = (liveInfo.awayScore || 0) + (liveInfo.homeScore || 0);
        const margin = (isOver ? totalScore - lineValue : lineValue - totalScore);
        let coverageState = 'unknown';
        if (margin > 0) coverageState = 'covering';
        else if (margin < 0) coverageState = 'trailing';
        else coverageState = 'push';
        return { coverageState, totalScore, margin, lineValue, type };
    }
    if (type === 'team-total') {
        if (!side || !Number.isFinite(lineValue)) return { coverageState: 'unknown', type };
        const ourScore = side === 'home' ? liveInfo.homeScore : liveInfo.awayScore;
        const oppScore = side === 'home' ? liveInfo.awayScore : liveInfo.homeScore;
        const margin = (isOver ? ourScore - lineValue : lineValue - ourScore);
        let coverageState = 'unknown';
        if (margin > 0) coverageState = 'covering';
        else if (margin < 0) coverageState = 'trailing';
        else coverageState = 'push';
        return { coverageState, ourScore, oppScore, diff: ourScore - oppScore, margin, lineValue, type };
    }
    if (type === 'moneyline' || type === 'spread') {
        if (!side) return { coverageState: 'unknown', type };
        const ourScore = side === 'home' ? liveInfo.homeScore : liveInfo.awayScore;
        const oppScore = side === 'home' ? liveInfo.awayScore : liveInfo.homeScore;
        const diff = ourScore - oppScore;
        if (type === 'spread' && Number.isFinite(lineValue)) {
            const coverMargin = diff + lineValue;
            let coverageState = 'unknown';
            if (coverMargin > 0) coverageState = 'covering';
            else if (coverMargin < 0) coverageState = 'trailing';
            else coverageState = 'push';
            return { coverageState, ourScore, oppScore, diff, coverMargin, lineValue, type };
        }
        let coverageState = 'unknown';
        if (diff > 0) coverageState = 'covering';
        else if (diff < 0) coverageState = 'trailing';
        else coverageState = 'push';
        return { coverageState, ourScore, oppScore, diff, type };
    }
    return { coverageState: 'unknown', type };
}
function buildStatusDecision(baseStatus, liveInfo, coverage) {
    const normalizedBase = (baseStatus || '').toLowerCase();
    const canonicalBase = normalizedBase === 'loss' ? 'lost' : normalizedBase;
    const titleCase = key => key.split('-').map(part => part.charAt(0).toUpperCase() + part.slice(1)).join(' ');
    if (['win', 'lost', 'push'].includes(canonicalBase)) {
        return { key: canonicalBase, label: titleCase(canonicalBase) };
    }
    if (liveInfo && liveInfo.isFinal) {
        if (coverage.coverageState === 'covering') return { key: 'win', label: 'Win' };
        if (coverage.coverageState === 'trailing') return { key: 'lost', label: 'Lost' };
        if (coverage.coverageState === 'push') return { key: 'push', label: 'Push' };
    }
    if (coverage.coverageState === 'covering') {
        return { key: 'on-track', label: 'On Track' };
    }
    if (coverage.coverageState === 'trailing') {
        return { key: 'at-risk', label: 'At Risk' };
    }
    if (coverage.coverageState === 'push') {
        return { key: canonicalBase || 'pending', label: titleCase(canonicalBase || 'Pending') };
    }
    if (canonicalBase) {
        return { key: canonicalBase, label: titleCase(canonicalBase) };
    }
    return { key: 'pending', label: 'Pending' };
}
function composeStatusTooltip(payload, liveInfo, coverage, decision, pickMeta) {
    const parts = [];
    if (Array.isArray(payload.legs) && payload.legs.length && (!liveInfo || (!liveInfo.scoreboardText && !liveInfo.phaseLabel))) {
        const totals = payload.legs.reduce((acc, leg) => {
            const key = (leg.status || '').toLowerCase();
            acc[key] = (acc[key] || 0) + 1;
            return acc;
        }, {});
        const totalLegs = payload.legs.length;
        const finished = (totals.win || 0) + (totals.lost || totals.loss || 0) + (totals.push || 0);
        const liveLegs = (totals['on-track'] || 0) + (totals['at-risk'] || 0) + (totals.live || 0);
        if (finished) {
            parts.push(`${finished}/${totalLegs} complete`);
        } else if (liveLegs) {
            parts.push(`${liveLegs} live`);
        } else if (totals.pending) {
            parts.push(`${totals.pending} pending`);
        }
    }
    if (liveInfo) {
        if (coverage) {
            if (typeof coverage.diff === 'number' && (pickMeta.type === 'moneyline' || pickMeta.type === 'spread' || pickMeta.type === 'team-total')) {
                if (coverage.diff > 0) parts.push(`Up ${Math.abs(coverage.diff)}`);
                else if (coverage.diff < 0) parts.push(`Down ${Math.abs(coverage.diff)}`);
                else parts.push('Tied');
            } else if (pickMeta.type === 'total' && typeof coverage.margin === 'number' && Number.isFinite(pickMeta.lineValue)) {
                const margin = Math.abs(coverage.margin).toFixed(1).replace(/\.0$/, '');
                if (coverage.coverageState === 'covering') {
                    parts.push(`+${margin}`);
                } else if (coverage.coverageState === 'trailing') {
                    parts.push(`Need ${margin}`);
                }
            }
        }
        if (!coverage && liveInfo.scoreboardText) {
            parts.push(liveInfo.scoreboardText);
        } else if (!coverage && payload.result) {
            parts.push(payload.result);
        }
        if (liveInfo.phaseLabel) {
            const phaseMatch = liveInfo.phaseLabel.match(/(Q\d+|OT|1ST|2ND|3RD|4TH|1H|2H)/i);
            const clockMatch = liveInfo.phaseLabel.match(/(\d{1,2}:\d{2})/);
            if (phaseMatch && clockMatch) {
                parts.push(`${normalizePeriodLabel(phaseMatch[1])} ${clockMatch[1]}`);
            } else if (phaseMatch) {
                parts.push(normalizePeriodLabel(phaseMatch[1]));
            } else if (clockMatch) {
                parts.push(clockMatch[1]);
            }
        }
    }
    if (!parts.length && payload.start) {
        parts.push(`Starts ${payload.start}`);
    }
    if (!parts.length && payload.countdown) {
        parts.push(payload.countdown);
    }
    if (!parts.length && payload.result) {
        parts.push(payload.result);
    }
    if (!parts.length && decision) {
        parts.push(decision.label);
    }
    if (!parts.length && payload.status) {
        parts.push(payload.status);
    }
    return parts.filter(Boolean).join(' • ');
}
function formatPointValue(value) {
    if (value === undefined || value === null) return '';
    const absValue = Math.abs(value);
    if (!Number.isFinite(absValue)) return '';
    const rounded = Math.round(absValue * 10) / 10;
    if (Number.isInteger(rounded)) return String(rounded);
    return rounded.toFixed(1).replace(/\.0$/, '');
}
function formatLineValue(value) {
    if (!Number.isFinite(value)) return '';
    const rounded = Math.round(value * 10) / 10;
    if (Number.isInteger(rounded)) return String(rounded);
    return rounded.toFixed(1).replace(/\.0$/, '');
}
function normalizePeriodLabel(value) {
    if (!value) return '';
    const upper = value.toString().toUpperCase();
    if (upper === '1ST') return 'Q1';
    if (upper === '2ND') return 'Q2';
    if (upper === '3RD') return 'Q3';
    if (upper === '4TH') return 'Q4';
    return upper;
}
function parsePhaseSnippet(source) {
    if (!source) return '';
    const cleaned = source.replace(/\s*(left in|remaining|left)\s*/i, ' ');
    const clockMatch = cleaned.match(/(\d{1,2}:\d{2})/);
    const periodMatch = cleaned.match(/(Q\d+|OT|1ST|2ND|3RD|4TH|1H|2H)/i);
    const periodText = periodMatch ? normalizePeriodLabel(periodMatch[1]) : '';
    if (clockMatch && periodText) return `${periodText} ${clockMatch[1]}`;
    if (periodText) return periodText;
    if (clockMatch) return clockMatch[1];
    return cleaned.trim();
}
function formatPhaseSnippet(liveInfo) {
    if (!liveInfo) return '';
    if (liveInfo.isFinal) return 'Final';
    if (liveInfo.isHalftime) return 'Halftime';
    const fromLabel = parsePhaseSnippet(liveInfo.phaseLabel);
    if (fromLabel) return fromLabel;
    const combined = [liveInfo.period, liveInfo.clock].filter(Boolean).join(' ').trim();
    if (combined) {
        return parsePhaseSnippet(combined);
    }
    return '';
}
function formatLiveMarginSnippet(coverage, pickMeta) {
    if (!coverage || !pickMeta) return '';
    const { type } = pickMeta;
    if (type === 'spread' && typeof coverage.coverMargin === 'number') {
        if (coverage.coverMargin === 0) return 'At number';
        const valueText = formatPointValue(coverage.coverMargin);
        if (!valueText) return '';
        return coverage.coverMargin > 0
            ? `Covering by ${valueText}`
            : `Need ${valueText}`;
    }
    if ((type === 'total' || type === 'team-total') && typeof coverage.margin === 'number') {
        if (coverage.margin === 0) {
            if (Number.isFinite(pickMeta.lineValue)) {
                return `On ${formatLineValue(pickMeta.lineValue)}`;
            }
            return 'Even';
        }
        const valueText = formatPointValue(coverage.margin);
        if (!valueText) return '';
        const label = type === 'team-total'
            ? (pickMeta.isOver ? 'Over TT' : 'Under TT')
            : (pickMeta.isOver ? 'Over' : 'Under');
        return coverage.margin > 0
            ? `${label} by ${valueText}`
            : `Need ${valueText}`;
    }
    if (typeof coverage.diff === 'number') {
        if (coverage.diff === 0) return 'Tied';
        const valueText = formatPointValue(coverage.diff);
        if (!valueText) return '';
        return coverage.diff > 0 ? `Up ${valueText}` : `Down ${valueText}`;
    }
    return '';
}
function formatFinalBadgeContext(decisionKey, coverage, pickMeta) {
    if (!pickMeta) return '';
    if (decisionKey === 'push') {
        if (Number.isFinite(pickMeta.lineValue)) {
            return `Push @ ${formatLineValue(pickMeta.lineValue)}`;
        }
        return 'Push';
    }
    if (!coverage) return '';
    const { type } = pickMeta;
    if (type === 'spread' && typeof coverage.coverMargin === 'number') {
        if (coverage.coverMargin === 0) {
            return Number.isFinite(pickMeta.lineValue) ? `Push @ ${formatLineValue(pickMeta.lineValue)}` : 'Push';
        }
        const coverValue = formatPointValue(coverage.coverMargin);
        const diffValue = Number.isFinite(coverage.diff) ? formatPointValue(coverage.diff) : '';
        if (!coverValue && !diffValue) return '';
        if (coverage.coverMargin > 0) {
            if (diffValue) {
                return `Won by ${diffValue}${coverValue ? ` • Cov ${coverValue}` : ''}`;
            }
            return `Covered by ${coverValue}`;
        }
        if (diffValue) {
            const scoreboardPhrase = coverage.diff < 0
                ? `Lost by ${diffValue}`
                : `Won by ${diffValue}`;
            const needText = coverValue ? ` • Need ${coverValue}` : '';
            return `${scoreboardPhrase}${needText}`;
        }
        return coverValue ? `Missed by ${coverValue}` : '';
    }
    if ((type === 'total' || type === 'team-total') && typeof coverage.margin === 'number') {
        if (coverage.margin === 0) {
            return Number.isFinite(pickMeta.lineValue) ? `Push @ ${formatLineValue(pickMeta.lineValue)}` : 'Push';
        }
        const valueText = formatPointValue(coverage.margin);
        if (!valueText) return '';
        const label = type === 'team-total'
            ? (pickMeta.isOver ? 'Over TT' : 'Under TT')
            : (pickMeta.isOver ? 'Over' : 'Under');
        const lineText = Number.isFinite(pickMeta.lineValue) ? ` vs ${formatLineValue(pickMeta.lineValue)}` : '';
        return coverage.margin > 0
            ? `${label} by ${valueText}${lineText}`
            : `Short ${valueText}${lineText}`;
    }
    if (typeof coverage.diff === 'number') {
        if (coverage.diff === 0) return 'Tied';
        const valueText = formatPointValue(coverage.diff);
        if (!valueText) return '';
        return coverage.diff > 0
            ? `Won by ${valueText}`
            : `Lost by ${valueText}`;
    }
    return '';
}
function formatPendingBadgeContext(payload) {
    if (!payload) return '';
    if (payload.countdown) return payload.countdown;
    if (payload.start) return payload.start;
    if (payload.scheduled) return payload.scheduled;
    return '';
}
function formatStatusBadgeContext(decision, liveInfo, coverage, pickMeta, payload) {
    if (!decision) return '';
    const key = decision.key;
    if (key === 'on-track' || key === 'at-risk' || key === 'live') {
        const marginText = formatLiveMarginSnippet(coverage, pickMeta);
        const phaseText = formatPhaseSnippet(liveInfo);
        if (marginText && phaseText) {
            return `${marginText} • ${phaseText}`;
        }
        return marginText || phaseText;
    }
    if (key === 'win' || key === 'lost' || key === 'push') {
        const finalContext = formatFinalBadgeContext(key, coverage, pickMeta);
        if (finalContext) return finalContext;
        if (liveInfo?.scoreboardText) return liveInfo.scoreboardText;
        if (payload?.result) return payload.result;
        return '';
    }
    if (key === 'pending') {
        return formatPendingBadgeContext(payload);
    }
    return '';
}
function normalizeBlurbPayload(input) {
    if (!input || typeof input !== 'object' || Array.isArray(input)) {
        return { status: input };
    }
    return { ...input };
}
function escapeHtmlForStatus(text) {
    if (!text) return '';
    return String(text)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}
function buildStatusBadgeHTML({ statusClass, label, tooltip, info, extraClass = '' }) {
    const safeStatus = escapeHtmlForStatus(statusClass || 'pending');
    const safeLabel = escapeHtmlForStatus(label || '');
    const safeTooltip = tooltip ? escapeHtmlForStatus(tooltip) : '';
    const safeInfo = info ? escapeHtmlForStatus(info) : '';
    const hasWinOrLoss = safeInfo && /(^|[^\d])([1-9]\d*)W|(^|[^\d])([1-9]\d*)L/.test(safeInfo);
    const shouldShowInfo = safeInfo && hasWinOrLoss;
    const tooltipAttr = safeTooltip ? ` data-blurb="${safeTooltip}"` : '';
    const infoAttr = shouldShowInfo ? ` data-status-info="${safeInfo}"` : '';
    const extraClassValue = extraClass ? ` ${extraClass}` : '';
    return `<span class="status-badge${extraClassValue}" data-status="${safeStatus}"${tooltipAttr}${infoAttr}>${safeLabel}</span>`;
}
function formatGameTimeStatus(statusClass, liveInfo, result, status, countdown, start) {
    if (statusClass === 'win' || statusClass === 'lost' || statusClass === 'final') {
        return '<span class="game-time-status final">FINAL</span>';
    }
    if (statusClass === 'on-track' || statusClass === 'at-risk' || statusClass === 'live') {
        let timeText = '';
        if (liveInfo) {
            if (liveInfo.phaseLabel) {
                const periodMatch = liveInfo.phaseLabel.match(/(Q\d+|OT|1ST|2ND|3RD|4TH|1H|2H)/i);
                const clockMatch = liveInfo.phaseLabel.match(/(\d{1,2}:\d{2})/);
                if (periodMatch && clockMatch) {
                    timeText = `${periodMatch[1].toUpperCase()} ${clockMatch[1]}`;
                } else if (periodMatch) {
                    timeText = periodMatch[1].toUpperCase();
                } else if (clockMatch) {
                    timeText = clockMatch[1];
                } else {
                    timeText = liveInfo.phaseLabel;
                }
            } else if (liveInfo.period && liveInfo.clock) {
                timeText = `${liveInfo.period} ${liveInfo.clock}`;
            } else if (liveInfo.period) {
                timeText = liveInfo.period;
            } else if (liveInfo.clock) {
                timeText = liveInfo.clock;
            }
        }
        if (!timeText && result) {
            const periodMatch = result.match(/(Q\d+|OT|1ST|2ND|3RD|4TH|1H|2H)/i);
            const clockMatch = result.match(/(\d{1,2}:\d{2})/);
            if (periodMatch && clockMatch) {
                timeText = `${periodMatch[1].toUpperCase()} ${clockMatch[1]}`;
            } else if (periodMatch) {
                timeText = periodMatch[1].toUpperCase();
            } else if (clockMatch) {
                timeText = clockMatch[1];
            }
        }
        if (timeText) {
            return `<span class="live-indicator">LIVE</span><span class="game-time-status">${escapeHtmlForStatus(timeText)}</span>`;
        } else {
            return '<span class="live-indicator">LIVE</span><span class="game-time-status">LIVE</span>';
        }
    }
    if (countdown) {
        return `<span class="game-time-status countdown">${escapeHtmlForStatus(countdown)}</span>`;
    }
    if (start) {
        if (start.includes('Starts in') || start.includes('starts in')) {
            return `<span class="game-time-status countdown">${escapeHtmlForStatus(start)}</span>`;
        }
        return `<span class="game-time-status countdown">${escapeHtmlForStatus(start)}</span>`;
    }
    if (result) {
        return `<span class="game-time-status">${escapeHtmlForStatus(result)}</span>`;
    }
    if (status) {
        return `<span class="game-time-status">${escapeHtmlForStatus(status)}</span>`;
    }
    return '<span class="game-time-status">—</span>';
}
function buildStatusMeta(payloadInput, fallbackResult) {
    const payload = normalizeBlurbPayload(payloadInput);
    if (fallbackResult !== undefined && payload.result === undefined) {
        payload.result = fallbackResult;
    }
    if (!payload.status && payload.baseStatus) {
        payload.status = payload.baseStatus;
    }
    if (payload.score === undefined) {
        payload.score = payload.result;
    }
    if (!payload.matchup && payload.game) {
        payload.matchup = payload.game;
    }
    const pickMeta = determinePickMeta(payload);
    const liveInfo = extractScoreboardDetails(payload.score, payload.matchup);
    const coverage = evaluateCoverage(liveInfo, pickMeta);
    const decision = buildStatusDecision(payload.status, liveInfo, coverage);
    const tooltip = composeStatusTooltip(payload, liveInfo, coverage, decision, pickMeta);
    const badgeContext = formatStatusBadgeContext(decision, liveInfo, coverage, pickMeta, payload);
    return {
        statusKey: decision.key,
        statusLabel: decision.label,
        tooltip,
        liveInfo,
        coverage,
        pickMeta,
        badgeContext
    };
}
function getStatusBlurb(statusOrPayload, resultMaybe) {
    if (typeof statusOrPayload === 'object' && statusOrPayload !== null && !Array.isArray(statusOrPayload)) {
        return buildStatusMeta(statusOrPayload).tooltip;
    }
    return buildStatusMeta({ status: statusOrPayload }, resultMaybe).tooltip;
}
function createParlayLegsRow(pick, rowId) {
    const legsRow = document.createElement('tr');
    legsRow.className = 'parlay-legs';
    legsRow.setAttribute('data-parent-id', rowId);
    legsRow.setAttribute('data-preserve', 'true');
    legsRow.setAttribute('aria-labelledby', rowId);
    legsRow.setAttribute('role', 'region');
    legsRow.setAttribute('aria-label', 'Parlay legs details');
    legsRow.style.display = 'none'; 
    const legs = pick.legs || [];
    const totalLegs = legs.length;
    const liveLegsCount = legs.filter(leg => {
        const normalized = (leg.status || '').toLowerCase();
        return normalized === 'live' || normalized === 'on-track' || normalized === 'at-risk';
    }).length;
    const legsRowId = `${rowId || `parlay-${Date.now()}`}-legs`;
    const legsHTML = legs.map((leg, legIndex) => {
        const description = leg.description || '';
        const legParsed = parsePickDescription(description);
        const legTeams = parseTeamsFromGame(leg.game || '');
        const legAwayAbbr = getTeamAbbr(legTeams.away);
        const legHomeAbbr = getTeamAbbr(legTeams.home);
        const legAwayLogo = getTeamLogo(legTeams.away, 'nfl');
        const legHomeLogo = getTeamLogo(legTeams.home, 'nfl');
        const statusMeta = buildStatusMeta({
            status: leg.status || 'pending',
            result: leg.score || leg.result,
            score: leg.score || leg.result,
            matchup: leg.matchup || leg.game,
            selection: leg.selection,
            description: leg.description,
            parsedPick: legParsed,
            market: leg.market,
            start: leg.start || leg.countdown
        });
        const legStatusClass = (leg.status || 'pending').toLowerCase();
        const derivedStatus = (statusMeta.statusKey || legStatusClass || 'pending').toLowerCase();
        const isLiveLeg = derivedStatus === 'on-track' || derivedStatus === 'at-risk';
        const statusTooltipText = statusMeta.tooltip || getStatusBlurb(leg.status || '', leg.result || '') || '';
        const legBadgeMarkup = buildStatusBadgeHTML({
            statusClass: derivedStatus,
            label: statusMeta.statusLabel || leg.status || 'Pending',
            tooltip: statusTooltipText,
            info: statusMeta.badgeContext,
            extraClass: isLiveLeg ? 'live-pulsing' : ''
        });
        let pickedTeamLogo = legAwayLogo;
        let pickedTeamAbbr = legAwayAbbr;
        let pickedTeamName = legTeams.away;
        if (legParsed.pickTeam) {
            const pickTeamLower = legParsed.pickTeam.toLowerCase();
            const homeLower = (legTeams.home || '').toLowerCase();
            if (homeLower.includes(pickTeamLower) || pickTeamLower.includes(homeLower)) {
                pickedTeamLogo = legHomeLogo;
                pickedTeamAbbr = legHomeAbbr;
                pickedTeamName = legTeams.home;
            }
        } else if (legParsed.pickType === 'Over' || legParsed.pickType === 'Under') {
            pickedTeamAbbr = legParsed.pickType.substring(0, 1); 
        }
        return `
            <tr class="parlay-leg-row ${isLiveLeg ? 'live-game' : ''}" data-pick-type="${legParsed.pickType?.toLowerCase() || 'unknown'}" data-pick-text="${description.toLowerCase()}" data-segment="${leg.segment?.toLowerCase().replace(/\s+/g, '-') || 'full'}" data-odds="${legParsed.odds || '-110'}" data-away="${legTeams.away.toLowerCase()}" data-home="${legTeams.home.toLowerCase()}">
                <td class="leg-number-cell">
                    <div class="leg-number-badge">
                        <span class="leg-label">Leg</span>
                        <span class="leg-value">${legIndex + 1}</span>
                    </div>
                </td>
                <td>
                    <div class="matchup-cell-parlay-leg">
                        <img src="${legAwayLogo}" class="team-logo" alt="${legAwayAbbr}">
                        <span class="team-name">${legTeams.away}</span>
                        <span class="vs-divider">vs</span>
                        <img src="${legHomeLogo}" class="team-logo" alt="${legHomeAbbr}">
                        <span class="team-name">${legTeams.home}</span>
                    </div>
                </td>
                <td>
                    <div class="pick-cell-leg">
                        <div class="pick-type">${legParsed.pickType || 'Pick'}</div>
                        <div class="pick-details">${generatePickDisplay(legParsed, pickedTeamLogo, pickedTeamAbbr, pickedTeamName)}</div>
                        <div class="pick-odds">${legParsed.odds || '-110'}</div>
                    </div>
                </td>
                <td class="center">
                    <span class="game-segment">${leg.segment || 'Full'}</span>
                </td>
                <td class="center">
                    ${legBadgeMarkup}
                </td>
            </tr>
        `;
    }).join('');
    legsRow.id = legsRowId;
    legsRow.innerHTML = `
        <td colspan="7">
            <div class="parlay-legs-container">
                <div class="parlay-legs-header">
                    <div class="parlay-legs-title">
                        <span class="parlay-legs-heading">Parlay Legs</span>
                        <span class="parlay-legs-subtitle">${totalLegs} Leg${totalLegs === 1 ? '' : 's'}${liveLegsCount > 0 ? ` • ${liveLegsCount} Live` : ''}</span>
                    </div>
                    <div class="parlay-legs-hint">Collapse when done</div>
                </div>
                <table class="picks-table compact-leg-table parlay-legs-table">
                    <thead class="parlay-legs-table-header">
                        <tr>
                            <th class="leg-number-header">#</th>
                            <th>Matchup</th>
                            <th>Pick</th>
                            <th>Segment</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${legsHTML}
                    </tbody>
                </table>
            </div>
        </td>
    `;
    return legsRow;
}
function createParlayRow(pick, index) {
    const legs = pick.legs || [];
    const statusMeta = buildStatusMeta({
        status: pick.status,
        result: pick.result,
        score: pick.result,
        selection: pick.description,
        description: pick.description,
        matchup: pick.game,
        legs,
        start: pick.scheduled,
        market: pick.market
    });
    const statusClass = (statusMeta.statusKey || pick.status || 'pending').toLowerCase();
    const parlayBadgeMarkup = buildStatusBadgeHTML({
        statusClass,
        label: statusMeta.statusLabel || pick.status || 'Pending',
        tooltip: statusMeta.tooltip || getStatusBlurb(pick.status, pick.result) || '',
        info: statusMeta.badgeContext
    });
    const rowId = `parlay-${index}-${Date.now()}`;
    const legCount = legs.length;
    const liveLegs = legs.filter(leg => {
        const normalized = (leg.status || '').toLowerCase();
        return normalized === 'live' || normalized === 'on-track' || normalized === 'at-risk';
    }).length;
    const oddsMatch = pick.description.match(/\(([+\-]\d+)\)/);
    const odds = oddsMatch ? oddsMatch[1] : '+100';
    const row = document.createElement('tr');
    row.className = 'parlay-row group-start';
    row.id = rowId;
    row.setAttribute('data-row-id', rowId);
    row.setAttribute('data-league', 'multi');
    row.setAttribute('data-book', pick.sportsbook || 'bombay 711');
    row.setAttribute('data-status', statusClass);
    row.setAttribute('data-risk', pick.risk != null ? String(pick.risk).replace(/,/g, '') : '0');
    row.setAttribute('data-win', pick.win != null ? String(pick.win).replace(/,/g, '') : '0');
    row.setAttribute('data-pick-type', 'parlay');
    row.setAttribute('data-pick-text', pick.description.toLowerCase());
    row.setAttribute('data-segment', 'full-game');
    row.setAttribute('data-odds', odds.replace('+', '').replace('-', ''));
    row.setAttribute('data-epoch', new Date(pick.scheduled || pick.accepted).getTime());
    row.setAttribute('data-parlay-legs', JSON.stringify(legs));
    row.setAttribute('onclick', 'toggleParlay(this)');
    row.setAttribute('role', 'button');
    row.setAttribute('tabindex', '0');
    row.setAttribute('aria-expanded', 'false');
    row.setAttribute('aria-label', `${legCount}-game parlay, click to expand details`);
    row.setAttribute('aria-controls', `${rowId}-legs`);
    let liveCountText = '';
    if (liveLegs > 0) {
        if (liveLegs === legCount) {
            liveCountText = `<span class="live-count pulsating">${liveLegs === 2 ? 'Both' : 'All'} Live</span>`;
        } else {
            liveCountText = `<span class="live-count pulsating">${liveLegs} Live</span>`;
        }
    }
    const legSnippets = legs.slice(0, 3).map((leg, i) => {
        const legTeams = parseTeamsFromGame(leg.game);
        const legAwayLogo = getTeamLogo(legTeams.away, 'nfl');
        const legResult = leg.result || '';
        const scores = legResult.match(/(\d+)/g) || ['0', '0'];
        return `
            <div class="leg-snippet">
                <span class="leg-num">LEG ${i + 1}</span>
                <div class="score-display">
                    <img src="${legAwayLogo}" class="team-logo-small" alt="${getTeamAbbr(legTeams.away)}">
                    <span>${scores[0] || '0'}</span>
                    <span class="score-sep">-</span>
                    <span>${scores[1] || '0'}</span>
                </div>
            </div>
        `;
    }).join('');
    const collapsedLegSummary = legs.length
        ? legs.map((_, idx) => `Leg ${idx + 1}`).slice(0, 4).join(' • ') + (legs.length > 4 ? ` • +${legs.length - 4}` : '')
        : '';
    row.innerHTML = `
        <td>
            <div class="datetime-cell parlay-trigger">
                <span class="parlay-toggle-icon">▶</span>
                <span class="date-value">${pick.accepted || 'Nov 7, 2025'}</span>
                <span class="time-value">Multi-Leg</span>
                <span class="sportsbook-value">${pick.sportsbook || 'Bombay 711'}</span>
            </div>
        </td>
        <td>
            <div class="matchup-cell">
                <span class="parlay-info">
                    <span class="game-count">${legCount} Games</span>${liveCountText ? ' • ' + liveCountText : ''}
                    ${collapsedLegSummary ? `<span class="parlay-leg-summary">${collapsedLegSummary}</span>` : ''}
                </span>
            </div>
        </td>
        <td>
            <div class="pick-cell">
                <div class="pick-details">
                    <span class="pick-type">${pick.description.split('(')[0].trim()}</span>
                    <span class="pick-odds">(${odds})</span>
                </div>
            </div>
        </td>
        <td class="center">
            <span class="game-segment">Multi</span>
        </td>
        <td class="center">
            <span class="currency-combined">
                <span class="currency-line">
                    <span class="risk-label">$ At Risk</span>
                    <span class="risk-amount">$${pick.risk}</span>
                </span>
                <span class="currency-line">
                    <span class="win-label">To Win</span>
                    <span class="win-amount">$${pick.win}</span>
                </span>
            </span>
        </td>
        <td class="center">
            <div class="multi-game-summary">
                ${legSnippets}
            </div>
        </td>
        <td class="center">
            ${parlayBadgeMarkup}
        </td>
    `;
    return row;
}
function buildPickRow(pick, index) {
    if (pick.is_parlay) {
        return createParlayRow(pick, index);
    }
    const parsedPick = parsePickDescription(pick.description);
    const statusMeta = buildStatusMeta({
        status: pick.status,
        result: pick.result,
        score: pick.result,
        matchup: pick.game,
        selection: pick.description,
        description: pick.description,
        parsedPick,
        start: pick.scheduled,
        market: pick.market
    });
    const statusClass = (statusMeta.statusKey || pick.status || 'pending').toLowerCase();
    const isLive = statusClass === 'on-track' || statusClass === 'at-risk' || statusClass === 'live';
    const statusBadgeMarkup = buildStatusBadgeHTML({
        statusClass,
        label: statusMeta.statusLabel || pick.status || 'Pending',
        tooltip: statusMeta.tooltip || getStatusBlurb(pick.status, pick.result) || '',
        info: statusMeta.badgeContext
    });
    let league = 'nfl';
    if (pick.sport) {
        league = pick.sport.toLowerCase();
    } else if (pick.game && (pick.game.includes('Suns') || pick.game.includes('Clippers'))) {
        league = 'nba';
    } else if (pick.game && (pick.game.includes('Georgia') || pick.game.includes('UTSA') || pick.game.includes('Appalachian'))) {
        league = 'college';
    }
    const teams = parseTeamsFromGame(pick.game);
    const awayAbbr = getTeamAbbr(teams.away);
    const homeAbbr = getTeamAbbr(teams.home);
    const awayLogo = getTeamLogo(teams.away, league);
    const homeLogo = getTeamLogo(teams.home, league);
    let pickedTeamLogo = awayLogo;
    let pickedTeamAbbr = awayAbbr;
    let pickedTeamName = teams.away;
    if (parsedPick.pickTeam) {
        const pickTeamLower = parsedPick.pickTeam.toLowerCase();
        const awayLower = teams.away.toLowerCase();
        const homeLower = teams.home.toLowerCase();
        if (homeLower.includes(pickTeamLower) || pickTeamLower.includes(homeLower)) {
            pickedTeamLogo = homeLogo;
            pickedTeamAbbr = homeAbbr;
            pickedTeamName = teams.home;
        }
    } else if (parsedPick.pickType === 'Over' || parsedPick.pickType === 'Under') {
        pickedTeamLogo = awayLogo;
        pickedTeamAbbr = parsedPick.pickType.substring(0, 1); 
    }
    const row = document.createElement('tr');
    row.className = `group-start ${isLive ? 'live-game' : ''}`;
    let normalizedPickType = 'spread'; 
    if (parsedPick.pickType) {
        const pt = parsedPick.pickType.toLowerCase();
        if (pt === 'over' || pt === 'under') {
            normalizedPickType = 'total';
        } else if (pt === 'moneyline') {
            normalizedPickType = 'moneyline';
        } else if (pt === 'spread') {
            normalizedPickType = 'spread';
        }
    }
    row.setAttribute('data-league', league);
    row.setAttribute('data-book', 'hulk wager');
    row.setAttribute('data-status', statusClass);
    row.setAttribute('data-risk', pick.risk != null ? String(pick.risk).replace(/,/g, '') : '0');
    row.setAttribute('data-win', pick.win != null ? String(pick.win).replace(/,/g, '') : '0');
    row.setAttribute('data-away', teams.away.toLowerCase());
    row.setAttribute('data-home', teams.home.toLowerCase());
    row.setAttribute('data-pick-type', normalizedPickType);
    row.setAttribute('data-pick-text', pick.description.toLowerCase());
    row.setAttribute('data-segment', parsedPick.segment.toLowerCase().replace(/\s+/g, '-'));
    row.setAttribute('data-odds', parsedPick.odds || '-110');
    row.setAttribute('data-epoch', new Date(pick.scheduled || pick.accepted).getTime());
    let leagueLogoUrl = '';
    if (league === 'nba') leagueLogoUrl = 'https://a.espncdn.com/i/teamlogos/leagues/500/nba.png';
    else if (league === 'nfl') leagueLogoUrl = 'https://a.espncdn.com/i/teamlogos/leagues/500/nfl.png';
    else if (league === 'mlb') leagueLogoUrl = 'https://a.espncdn.com/i/teamlogos/leagues/500/mlb.png';
    else if (league === 'nhl') leagueLogoUrl = 'https://a.espncdn.com/i/teamlogos/leagues/500/nhl.png';
    else if (league.includes('college') || league.includes('ncaa')) leagueLogoUrl = 'https://a.espncdn.com/i/teamlogos/ncaa/500/ncaa.png';
    row.innerHTML = `
        <td>
            <div class="datetime-cell">
                <span class="cell-date">${pick.accepted || 'Nov 6, 2025'}</span>
                <span class="cell-time">${pick.scheduled ? pick.scheduled.split(' ').slice(-2).join(' ') : ''}</span>
                <span class="sportsbook-value">Hulk Wager</span>
            </div>
        </td>
        <td class="center">
            <div class="league-cell">
                ${leagueLogoUrl ? `<img src="${leagueLogoUrl}" class="league-logo" alt="${league}">` : ''}
                <span class="league-text">${league.replace('college', 'NCAA').toUpperCase()}</span>
            </div>
        </td>
        <td>
            <div class="matchup-cell">
                <div class="team-line">
                    <img src="${awayLogo}" class="team-logo" alt="${awayAbbr}">
                    <div class="team-name-wrapper">
                        <span class="team-name-full">${teams.away}</span>
                        <span class="team-record" data-team="${awayAbbr}"></span>
                    </div>
                </div>
                <div class="vs-divider">vs</div>
                <div class="team-line">
                    <img src="${homeLogo}" class="team-logo" alt="${homeAbbr}">
                    <div class="team-name-wrapper">
                        <span class="team-name-full">${teams.home}</span>
                        <span class="team-record" data-team="${homeAbbr}"></span>
                    </div>
                </div>
            </div>
        </td>
        <td>
            <div class="pick-cell">
                ${generatePickDisplay(parsedPick, pickedTeamLogo, pickedTeamAbbr, pickedTeamName)}
            </div>
        </td>
        <td class="center">
            <span class="game-segment">${parsedPick.segment || 'Full Game'}</span>
        </td>
        <td class="center">
            <span class="currency-combined">
                <span class="currency-line">
                    <span class="risk-label">$ At Risk</span>
                    <span class="risk-amount">$${pick.risk}</span>
                </span>
                <span class="currency-line">
                    <span class="win-label">To Win</span>
                    <span class="win-amount">$${pick.win}</span>
                </span>
            </span>
        </td>
        <td class="center">
            <div class="compact-boxscore">
                <div class="boxscore-grid">
                    <div class="boxscore-row header">
                        <div class="boxscore-cell header-cell game-time-cell">
                            ${formatGameTimeStatus(statusClass, statusMeta.liveInfo, pick.result, pick.status, pick.countdown, pick.scheduled || pick.start)}
                            ${parsedPick.segment !== 'Full Game' ? `<div style="font-size: 9px; color: rgba(170, 188, 204, 0.9); margin-top: 2px;">${parsedPick.segment}</div>` : ''}
                        </div>
                        <div class="boxscore-cell header-cell">Q1</div>
                        <div class="boxscore-cell header-cell">Q2</div>
                        <div class="boxscore-cell header-cell">Q3</div>
                        <div class="boxscore-cell header-cell">Q4</div>
                        <div class="boxscore-cell header-cell">T</div>
                    </div>
                    ${createBoxScoreRows(pick, awayLogo, awayAbbr, homeLogo, homeAbbr, statusClass)}
                </div>
            </div>
        </td>
        <td class="center">
            ${statusBadgeMarkup}
        </td>
    `;
    return row;
}
async function loadAndAppendPicks() {
    console.log('[PICKS LOADER] Starting to load picks...');
    try {
        const apiUrl = window.APP_CONFIG?.API_BASE_URL || '/api';
        const response = await fetch(`${apiUrl}/get-picks`);
        console.log('[PICKS LOADER] API response status:', response.status);
        if (!response.ok) {
            console.log('[PICKS LOADER] API not available, using static HTML picks');
            return;
        }
        const data = await response.json();
        const picks = data.picks || [];
        console.log('[PICKS LOADER] Received picks:', picks.length, picks);
        if (picks.length === 0) {
            console.log('[PICKS LOADER] No picks to load');
            return;
        }
        const tbody = document.getElementById('picks-tbody');
        if (!tbody) {
            console.error('[PICKS LOADER] ERROR: Table body #picks-tbody not found!');
            return;
        }
        console.log('[PICKS LOADER] Found table body, clearing and adding rows...');
        tbody.innerHTML = '';
        const tableContainer = tbody.closest('.table-container');
        if (tableContainer) {
            if (picks && picks.length > 0) {
                tableContainer.classList.add('has-picks');
            } else {
                tableContainer.classList.remove('has-picks');
            }
        }
        picks.forEach((pick, index) => {
            try {
                console.log(`[PICKS LOADER] Creating row ${index + 1} for:`, pick.description);
                const row = buildPickRow(pick, index);
                tbody.appendChild(row);
                if (pick.is_parlay) {
                    const rowId = row.getAttribute('data-row-id');
                    const legsRow = createParlayLegsRow(pick, rowId);
                    tbody.appendChild(legsRow);
                    console.log(`[PICKS LOADER] Added parlay legs row for: ${pick.description}`);
                }
            } catch (error) {
                console.error(`[PICKS LOADER] ERROR creating row for pick ${index + 1}:`, error);
                console.error('[PICKS LOADER] Pick data:', pick);
            }
        });
        console.log(`[PICKS LOADER] ✓ Successfully loaded ${picks.length} picks from API`);
        if (window.PicksParlayManager) {
            if (typeof window.PicksParlayManager.reinitParlays === 'function') {
                window.PicksParlayManager.reinitParlays();
            } else if (typeof window.PicksParlayManager.initParlays === 'function') {
                window.PicksParlayManager.initParlays();
            }
        }
        if (typeof calculateKPIs === 'function' && typeof updateKPITiles === 'function') {
            const kpis = calculateKPIs(picks);
            updateKPITiles(kpis);
        }
        if (typeof updateTable === 'function') {
            updateTable();
        }
        if (typeof updateTableWithFilters === 'function') {
            updateTableWithFilters();
        }
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                if (typeof window.__gbsvApplyZebraStripes === 'function') {
                    window.__gbsvApplyZebraStripes();
                }
            });
        });
        populateTeamRecordsWhenReady(document, { force: false });
        if (typeof populateLeagueDropdown === 'function') {
            populateLeagueDropdown();
        }
    } catch (error) {
        console.log('[PICKS LOADER] API not available, using static HTML picks');
    }
}
window.loadLivePicks = loadAndAppendPicks;
async function loadTeamRecords(options = {}) {
    const { force = false } = options;
    if (teamRecordsPromise && !force) {
        return teamRecordsPromise;
    }
    const loaderPromise = (async () => {
        try {
            const records = {
                'ARI': '5-5',
                'ATL': '6-4',
                'BAL': '7-3',
                'BUF': '8-2',
                'CAR': '3-7',
                'CHI': '4-6',
                'CIN': '5-5',
                'CLE': '3-7',
                'DAL': '7-3',
                'DEN': '5-4',
                'DET': '9-1',
                'GB': '6-4',
                'HOU': '7-3',
                'IND': '6-4',
                'JAX': '2-8',
                'KC': '9-1',
                'LAC': '6-4',
                'LAR': '5-5',
                'LV': '2-6',
                'MIA': '6-4',
                'MIN': '6-4',
                'NE': '2-8',
                'NO': '5-5',
                'NYG': '3-7',
                'NYJ': '4-6',
                'PHI': '9-1',
                'PIT': '6-4',
                'SEA': '5-5',
                'SF': '7-3',
                'TB': '5-5',
                'TEN': '3-7',
                'WAS': '6-4',
                'PHX': '8-1',
                'LAC': '6-4',
                'GASO': '6-3',
                'APP': '5-4',
                'UTSA': '3-6',
                'USF': '4-5'
            };
            const normalized = {};
            Object.keys(records).forEach(key => {
                normalized[key.toUpperCase()] = records[key];
            });
            teamRecordsCache = normalized;
            if (globalScope) {
                globalScope.__TEAM_RECORDS_CACHE__ = normalized;
                globalScope.teamRecordsCache = normalized;
            }
            populateTeamRecords(document, { force: true });
            return normalized;
        } catch (error) {
            console.warn('[RECORDS] Could not load team records:', error);
            throw error;
        }
    })();
    teamRecordsPromise = loaderPromise;
    if (globalScope) {
        globalScope.__TEAM_RECORDS_PROMISE__ = loaderPromise;
    }
    loaderPromise.catch(() => {
        if (teamRecordsPromise === loaderPromise) {
            teamRecordsPromise = null;
            if (globalScope) {
                globalScope.__TEAM_RECORDS_PROMISE__ = null;
            }
        }
    });
    return loaderPromise;
}
async function loadPicksFromDatabase() {
    try {
        if (!window.APP_CONFIG || !window.APP_CONFIG.API_BASE_URL) {
            console.warn('API not configured, using local picks');
            return null;
        }
        const apiUrl = window.APP_CONFIG.API_BASE_URL;
        const response = await fetch(`${apiUrl}/get-picks?limit=100`);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        const data = await response.json();
        const picks = data.picks || [];
        console.log(`Loaded ${picks.length} picks from database`);
        return picks.map(pick => ({
            ...pick,
            awayLogo: pick.awayLogo || getTeamLogo(pick.awayTeam, pick.sport),
            homeLogo: pick.homeLogo || getTeamLogo(pick.homeTeam, pick.sport)
        }));
    } catch (error) {
        console.warn('Failed to load picks from database:', error);
        return null;
    }
}
function initializePicksAndRecords() {
    const recordsPromise = loadTeamRecords();
    if (recordsPromise && typeof recordsPromise.catch === 'function') {
        recordsPromise.catch(error => console.warn('[RECORDS] Initial team records load failed:', error));
    }
    const databasePromise = loadPicksFromDatabase();
    databasePromise.then(dbPicks => {
        if (dbPicks && dbPicks.length > 0) {
            console.log('Using picks from database');
        } else {
            const picksPromise = loadAndAppendPicks();
            if (picksPromise && typeof picksPromise.catch === 'function') {
                picksPromise.catch(error => console.warn('[PICKS LOADER] Initial load encountered an error:', error));
            }
        }
    }).catch(error => {
        console.warn('Database load failed, using uploaded picks:', error);
        const picksPromise = loadAndAppendPicks();
        if (picksPromise && typeof picksPromise.catch === 'function') {
            picksPromise.catch(error => console.warn('[PICKS LOADER] Initial load encountered an error:', error));
        }
    });
}
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        const recordsPromise = loadTeamRecords();
        if (recordsPromise && typeof recordsPromise.catch === 'function') {
            recordsPromise.catch(error => console.warn('[RECORDS] Initial team records load failed:', error));
        }
    });
} else {
    const recordsPromise = loadTeamRecords();
    if (recordsPromise && typeof recordsPromise.catch === 'function') {
        recordsPromise.catch(error => console.warn('[RECORDS] Initial team records load failed:', error));
    }
}
if (globalScope) {
    globalScope.loadTeamRecords = loadTeamRecords;
    globalScope.createParlayLegsRow = createParlayLegsRow;
    globalScope.createParlayRow = createParlayRow;
}
(function() {
    'use strict';
    function calculatePickStatus(pick) {
        if (!pick.isLive) {
            return 'pending';
        }
        if (pick.isFinal) {
            if (pick.didWin) return 'win';
            if (pick.didLose) return 'loss';
            if (pick.isPush) return 'push';
        }
        if (pick.pickType === 'spread') {
            return calculateSpreadStatus(pick);
        } else if (pick.pickType === 'total' || pick.pickType.includes('ou')) {
            return calculateTotalStatus(pick);
        } else if (pick.pickType === 'moneyline') {
            return calculateMoneylineStatus(pick);
        }
        return 'pending';
    }
    function calculateSpreadStatus(pick) {
        const { awayScore, homeScore, pickTeam, spread, timeRemaining, quarter } = pick;
        const isAwayPick = pickTeam === pick.awayTeam;
        const actualSpread = isAwayPick ? (awayScore - homeScore) : (homeScore - awayScore);
        const coverMargin = actualSpread - spread;
        const criticalTime = getCriticalTimeThreshold(quarter, timeRemaining);
        if (coverMargin > 3 || (coverMargin > 0 && criticalTime < 0.15)) {
            return 'on-track';  
        } else if (coverMargin < -3 || (coverMargin < 0 && criticalTime < 0.15)) {
            return 'at-risk';   
        } else if (Math.abs(coverMargin) <= 3) {
            return coverMargin >= 0 ? 'on-track' : 'at-risk';
        }
        return coverMargin >= 0 ? 'on-track' : 'at-risk';
    }
    function calculateTotalStatus(pick) {
        const { awayScore, homeScore, pickTeam, total, isOver, timeRemaining, quarter, isTeamTotal = false } = pick;
        let currentTotal;
        if (isTeamTotal && pickTeam) {
            const teamScore = pickTeam === pick.awayTeam ? awayScore : homeScore;
            currentTotal = teamScore;
        } else {
            currentTotal = awayScore + homeScore;
        }
        const difference = isOver ? (currentTotal - total) : (total - currentTotal);
        const criticalTime = getCriticalTimeThreshold(quarter, timeRemaining);
        const remainingPossessions = estimateRemainingPossessions(timeRemaining, quarter);
        const expectedPointsRemaining = remainingPossessions * 7; 
        if (isOver) {
            if (difference > expectedPointsRemaining * 0.5) {
                return 'on-track';
            } else if (difference < -expectedPointsRemaining) {
                return 'at-risk';
            }
        } else {
            if (difference > expectedPointsRemaining * 0.5) {
                return 'on-track';
            } else if (difference < -expectedPointsRemaining) {
                return 'at-risk';
            }
        }
        return difference >= 0 ? 'on-track' : 'at-risk';
    }
    function calculateMoneylineStatus(pick) {
        const { awayScore, homeScore, pickTeam, timeRemaining, quarter } = pick;
        const isAwayPick = pickTeam === pick.awayTeam;
        const leadMargin = isAwayPick ? (awayScore - homeScore) : (homeScore - awayScore);
        const criticalTime = getCriticalTimeThreshold(quarter, timeRemaining);
        if (leadMargin > 7 || (leadMargin > 0 && criticalTime < 0.10)) {
            return 'on-track';
        }
        else if (leadMargin < -7 || (leadMargin < 0 && criticalTime < 0.10)) {
            return 'at-risk';
        }
        else {
            return leadMargin >= 0 ? 'on-track' : 'at-risk';
        }
    }
    function getCriticalTimeThreshold(quarter, timeRemaining) {
        const totalGameSeconds = 3600; 
        let secondsRemaining = 0;
        if (quarter === 'Q1') {
            secondsRemaining = (45 * 60) + parseTimeToSeconds(timeRemaining);
        } else if (quarter === 'Q2') {
            secondsRemaining = (30 * 60) + parseTimeToSeconds(timeRemaining);
        } else if (quarter === 'Q3') {
            secondsRemaining = (15 * 60) + parseTimeToSeconds(timeRemaining);
        } else if (quarter === 'Q4') {
            secondsRemaining = parseTimeToSeconds(timeRemaining);
        }
        return secondsRemaining / totalGameSeconds;
    }
    function estimateRemainingPossessions(timeRemaining, quarter) {
        const totalSeconds = getCriticalTimeThreshold(quarter, timeRemaining) * 3600;
        const avgPossessionTime = 180; 
        return Math.ceil(totalSeconds / avgPossessionTime);
    }
    function parseTimeToSeconds(timeStr) {
        if (!timeStr) return 0;
        const [min, sec] = timeStr.split(':').map(Number);
        return (min * 60) + (sec || 0);
    }
    function generateStatusTooltip(pick, status) {
        if (status === 'pending') {
            return `Game starts ${pick.startTime}`;
        }
        const { awayScore, homeScore, pickTeam, spread, total, isOver, finalScore, isTeamTotal = false } = pick;
        let tooltipText = '';
        if (status === 'win' || status === 'loss') {
            if (pick.isFinal) {
                const isAwayPick = pickTeam === pick.awayTeam;
                let diff, line, betType;
                if (pick.pickType === 'spread') {
                    const actualSpread = isAwayPick ? (awayScore - homeScore) : (homeScore - awayScore);
                    diff = actualSpread - spread;
                    line = spread;
                    betType = 'spread';
                } else if (pick.pickType === 'total' || pick.pickType.includes('ou')) {
                    let currentTotal;
                    if (isTeamTotal && pickTeam) {
                        const teamScore = isAwayPick ? awayScore : homeScore;
                        currentTotal = teamScore;
                    } else {
                        currentTotal = awayScore + homeScore;
                    }
                    diff = isOver ? (currentTotal - total) : (total - currentTotal);
                    line = total;
                    betType = isTeamTotal ? 'team total' : 'total';
                } else if (pick.pickType === 'moneyline') {
                    const lead = isAwayPick ? (awayScore - homeScore) : (homeScore - awayScore);
                    diff = lead;
                    betType = 'moneyline';
                }
                const absDiff = Math.abs(diff).toFixed(1);
                const ttSuffix = isTeamTotal ? ' (TT)' : '';
                if (status === 'win') {
                    if (betType === 'spread') {
                        tooltipText = `✓ Bet won - Covered ${line >= 0 ? ' + ' : ''}${line} by ${absDiff} pts${ttSuffix} - ${finalScore}`;
                    } else if (betType === 'total') {
                        tooltipText = `✓ Bet won - ${isOver ? 'Over' : 'Under'} ${line}${ttSuffix} by ${absDiff} pts - ${finalScore}`;
                    } else if (betType === 'moneyline') {
                        tooltipText = `✓ Bet won - Won by ${absDiff} pts - ${finalScore}`;
                    }
                } else { 
                    if (betType === 'spread') {
                        tooltipText = `✗ Bet lost - Failed to cover ${line >= 0 ? '+' : ''}${line} (missed by ${absDiff} pts)${ttSuffix} - ${finalScore}`;
                    } else if (betType === 'total') {
                        if (isOver) {
                            tooltipText = `✗ Bet lost - Over ${line}${ttSuffix} (scored ${currentTotal}, short ${absDiff} pts) - ${finalScore}`;
                        } else {
                            tooltipText = `✗ Bet lost - Under ${line}${ttSuffix} (scored ${currentTotal}, over by ${absDiff} pts) - ${finalScore}`;
                        }
                    } else if (betType === 'moneyline') {
                        tooltipText = `✗ Bet lost - Lost by ${absDiff} pts - ${finalScore}`;
                    }
                }
                if (tooltipText) return tooltipText;
            }
            if (status === 'win') {
                return `✓ Bet won - ${finalScore || 'Final'}`;
            } else {
                return `✗ Bet lost - ${finalScore || 'Final'}`;
            }
        }
        if (status === 'push') {
            return `Push - ${finalScore || pick.finalScore}`;
        }
        if (pick.isLive) {
            if (pick.pickType === 'spread') {
                const isAwayPick = pickTeam === pick.awayTeam;
                const actualSpread = isAwayPick ? (awayScore - homeScore) : (homeScore - awayScore);
                const coverMargin = actualSpread - spread;
                if (status === 'on-track') {
                    return `Covering by ${Math.abs(coverMargin).toFixed(1)} pts • ${pick.timeRemaining} ${pick.quarter}`;
                } else {
                    return `Need ${Math.abs(coverMargin).toFixed(1)} pts to cover • ${pick.timeRemaining} ${pick.quarter}`;
                }
            }
            if (pick.pickType === 'total' || pick.pickType.includes('ou')) {
                const isAwayPick = pickTeam === pick.awayTeam; 
                let currentTotal;
                if (isTeamTotal && pickTeam) {
                    currentTotal = isAwayPick ? awayScore : homeScore;
                } else {
                    currentTotal = awayScore + homeScore;
                }
                const diff = isOver ? (currentTotal - total) : (total - currentTotal);
                const ttPrefix = isTeamTotal ? 'TT ' : '';
                if (status === 'on-track') {
                    return `${isOver ? 'Over' : 'Under'} ${ttPrefix}by ${Math.abs(diff).toFixed(1)} pts • ${pick.timeRemaining} ${pick.quarter}`;
                } else {
                    return `Need ${Math.abs(diff).toFixed(1)} more pts for ${isOver ? 'over' : 'under'} ${ttPrefix}• ${pick.timeRemaining} ${pick.quarter}`;
                }
            }
            if (pick.pickType === 'moneyline') {
                const isAwayPick = pickTeam === pick.awayTeam;
                const lead = isAwayPick ? (awayScore - homeScore) : (homeScore - awayScore);
                if (status === 'on-track') {
                    return `Leading by ${Math.abs(lead)} • ${pick.timeRemaining} ${pick.quarter}`;
                } else {
                    return `Down ${Math.abs(lead)} • ${pick.timeRemaining} ${pick.quarter}`;
                }
            }
            return `Live • ${pick.timeRemaining} ${pick.quarter}`;
        }
        return `Status: ${status}`;
    }
    function syncKPIsWithTable() {
        const tbody = document.getElementById('picks-tbody');
        if (!tbody) return;
        const visibleRows = Array.from(tbody.children)
            .filter(row => row && row.tagName === 'TR' && !row.classList.contains('parlay-legs'))
            .filter(row => row.style.display !== 'none');
        const stats = {
            totalActivePicks: 0,
            toWin: 0,
            riskAmount: 0,
            winCount: 0,
            lossCount: 0,
            pendingCount: 0,
            onTrackCount: 0,
            atRiskCount: 0
        };
        visibleRows.forEach(row => {
            const status = (row.getAttribute('data-status') || '').toLowerCase();
            const risk = parseFloat(row.getAttribute('data-risk')) || 0;
            const win = parseFloat(row.getAttribute('data-win')) || 0;
            stats.riskAmount += risk;
            if (status === 'win') {
                stats.winCount++;
                stats.toWin += win;
            } else if (status === 'loss') {
                stats.lossCount++;
            } else if (status === 'pending') {
                stats.pendingCount++;
                stats.totalActivePicks++;
                stats.toWin += win;
            } else if (status === 'on-track') {
                stats.onTrackCount++;
                stats.totalActivePicks++;
                stats.toWin += win;
            } else if (status === 'at-risk') {
                stats.atRiskCount++;
                stats.totalActivePicks++;
                stats.toWin += win;
            }
        });
        updateKPITile('active-picks', stats.totalActivePicks);
        updateKPITile('to-win', `$${stats.toWin.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`);
        const roi = stats.riskAmount > 0 ? ((stats.toWin - stats.riskAmount) / stats.riskAmount * 100) : 0;
        updateKPITile('roe', `${roi >= 0 ? '+' : ''}${roi.toFixed(1)}%`);
        const recentResults = getRecentResults(visibleRows, 10);
        const streak = calculateStreak(recentResults);
        updateKPITile('streak', streak);
    }
    function updateKPITile(tileId, value) {
        const tileSelectors = [
            `#${tileId} .kpi-value`,
            `.kpi-tile[data-metric="${tileId}"] .kpi-value`,
            `.metric-card[data-metric="${tileId}"] .metric-value`
        ];
        for (const selector of tileSelectors) {
            const element = document.querySelector(selector);
            if (element) {
                element.textContent = value;
                return;
            }
        }
    }
    function getRecentResults(rows, limit = 10) {
        return rows
            .filter(row => {
                const status = (row.getAttribute('data-status') || '').toLowerCase();
                return status === 'win' || status === 'loss';
            })
            .slice(0, limit)
            .map(row => {
                const status = (row.getAttribute('data-status') || '').toLowerCase();
                return status === 'win' ? 'W' : 'L';
            });
    }
    function calculateStreak(results) {
        if (results.length === 0) return 'N/A';
        const mostRecent = results[0];
        let count = 0;
        for (const result of results) {
            if (result === mostRecent) {
                count++;
            } else {
                break;
            }
        }
        return `${mostRecent}${count}`;
    }
    function initializeStatusTooltips() {
        const statusBadges = document.querySelectorAll('.status-badge, .status-chip, .status-badge--mini');
        statusBadges.forEach(badge => {
            const existingTooltip = badge.getAttribute('data-blurb') || badge.getAttribute('title');
            if (!existingTooltip || existingTooltip === '') {
                const row = badge.closest('tr');
                if (row) {
                    const status = badge.getAttribute('data-status') || row.getAttribute('data-status');
                    const tooltip = generateDefaultTooltip(status);
                    badge.setAttribute('data-blurb', tooltip);
                }
            }
            if (badge.hasAttribute('title')) {
                badge.removeAttribute('title');
            }
        });
    }
    function generateDefaultTooltip(status) {
        const tooltips = {
            'pending': 'Awaiting game start',
            'on-track': 'Currently covering the bet',
            'at-risk': 'Currently not covering',
            'win': 'Bet won successfully',
            'loss': 'Bet did not cover',
            'push': 'Bet pushed (tie)'
        };
        return tooltips[status] || 'Status unknown';
    }
    document.addEventListener('DOMContentLoaded', function() {
        setTimeout(() => {
            syncKPIsWithTable();
            initializeStatusTooltips();
        }, 500);
    });
    const originalUpdateTable = window.updateTable || function() {};
    window.updateTable = function() {
        originalUpdateTable.apply(this, arguments);
        setTimeout(syncKPIsWithTable, 100);
    };
    window.dashboardStatusLogic = {
        calculatePickStatus,
        generateStatusTooltip,
        syncKPIsWithTable,
        initializeStatusTooltips
    };
})();
(function() {
    'use strict';
    const BADGE_SELECTOR = '.status-badge, .status-badge--mini';
    let tooltipElement = null;
    let currentTarget = null;
    let hideTimeout = null;
    let showDelayTimeout = null;
    let hideAnimationTimeout = null;
    function createTooltipElement() {
        if (tooltipElement) return tooltipElement;
        tooltipElement = document.createElement('div');
        tooltipElement.className = 'status-tooltip';
        tooltipElement.setAttribute('role', 'tooltip');
        tooltipElement.setAttribute('aria-hidden', 'true');
        document.body.appendChild(tooltipElement);
        return tooltipElement;
    }
    function getStatusTooltipClass(status) {
        const statusMap = {
            'live': 'tooltip-live',
            'on-track': 'tooltip-on-track',
            'at-risk': 'tooltip-at-risk',
            'win': 'tooltip-win',
            'final': 'tooltip-win',
            'loss': 'tooltip-loss',
            'pending': 'tooltip-pending',
            'push': 'tooltip-push'
        };
        return statusMap[status] || '';
    }
    function calculateTooltipPosition(target, tooltip) {
        const rect = target.getBoundingClientRect();
        const tooltipRect = tooltip.getBoundingClientRect();
        const viewport = {
            width: window.innerWidth,
            height: window.innerHeight,
            scrollX: window.scrollX,
            scrollY: window.scrollY
        };
        const spacing = 12;
        const arrowSize = 6;
        let top, left, placement = 'top';
        top = rect.top - tooltipRect.height - spacing - arrowSize;
        left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
        if (top < viewport.scrollY + 10) {
            top = rect.bottom + spacing + arrowSize;
            placement = 'bottom';
            if (top + tooltipRect.height > viewport.scrollY + viewport.height - 10) {
                if (rect.right + tooltipRect.width + spacing < viewport.scrollX + viewport.width) {
                    left = rect.right + spacing;
                    top = rect.top + (rect.height / 2) - (tooltipRect.height / 2);
                    placement = 'right';
                }
                else if (rect.left - tooltipRect.width - spacing > viewport.scrollX) {
                    left = rect.left - tooltipRect.width - spacing;
                    top = rect.top + (rect.height / 2) - (tooltipRect.height / 2);
                    placement = 'left';
                }
            }
        }
        if (left < viewport.scrollX + 10) {
            left = viewport.scrollX + 10;
        } else if (left + tooltipRect.width > viewport.scrollX + viewport.width - 10) {
            left = viewport.scrollX + viewport.width - tooltipRect.width - 10;
        }
        return { top, left, placement };
    }
    function formatTooltipContent(text, status) {
        const escapeHtml = value => String(value ?? '')
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
        const highlightNumbers = value => {
            const safe = escapeHtml(value);
            return safe.replace(/([+\-]?\d+(?:\.\d+)?%?)/g, '<span class="tooltip-highlight">$1</span>');
        };
        const raw = String(text || '').trim();
        if (!raw) return '';
        const parts = raw.split('•').map(s => s.trim()).filter(s => s);
        if (parts.length > 1) {
            return parts.map(highlightNumbers).join('<br>');
        }
        return highlightNumbers(raw);
    }
    function showTooltip(target, text) {
        if (!text || text.trim() === '') return;
        if (hideAnimationTimeout) {
            clearTimeout(hideAnimationTimeout);
            hideAnimationTimeout = null;
        }
        const tooltip = createTooltipElement();
        const status = target.getAttribute('data-status') || '';
        const formattedContent = formatTooltipContent(text, status);
        tooltip.innerHTML = `<span class="tooltip-content">${formattedContent}</span>`;
        tooltip.className = 'status-tooltip ' + getStatusTooltipClass(status);
        tooltip.style.visibility = 'hidden';
        tooltip.style.display = 'block';
        tooltip.setAttribute('aria-hidden', 'false');
        const position = calculateTooltipPosition(target, tooltip);
        tooltip.style.top = position.top + 'px';
        tooltip.style.left = position.left + 'px';
        tooltip.setAttribute('data-placement', position.placement);
        tooltip.style.visibility = 'visible';
        void tooltip.offsetWidth;
        tooltip.style.opacity = '1';
        tooltip.classList.add('showing');
        currentTarget = target;
    }
    function hideTooltip() {
        if (!tooltipElement) return;
        if (showDelayTimeout) {
            clearTimeout(showDelayTimeout);
            showDelayTimeout = null;
        }
        tooltipElement.classList.remove('showing');
        tooltipElement.style.opacity = '0';
        tooltipElement.setAttribute('aria-hidden', 'true');
        if (hideAnimationTimeout) {
            clearTimeout(hideAnimationTimeout);
        }
        hideAnimationTimeout = setTimeout(() => {
            if (tooltipElement) {
                tooltipElement.style.display = 'none';
                tooltipElement.style.visibility = 'hidden';
            }
            currentTarget = null;
            hideAnimationTimeout = null;
        }, 80);
    }
    function getTooltipText(target) {
        const blurb = target.getAttribute('data-blurb') || target.getAttribute('title') || '';
        const statusInfo = target.getAttribute('data-status-info') || '';
        let text = blurb.trim();
        if (statusInfo && text) {
            text = `${text} • ${statusInfo}`;
        } else if (statusInfo) {
            text = statusInfo;
        }
        if (!text) {
            text = target.textContent || '';
        }
        return text.trim();
    }
    function handleMouseEnter(e) {
        const target = e.currentTarget;
        if (target.hasAttribute('title')) {
            const titleText = target.getAttribute('title');
            if (titleText && !target.hasAttribute('data-blurb')) {
                target.setAttribute('data-blurb', titleText);
            }
            target.removeAttribute('title');
        }
        const text = getTooltipText(target);
        if (!text) return;
        if (hideTimeout) {
            clearTimeout(hideTimeout);
            hideTimeout = null;
        }
        if (showDelayTimeout) {
            clearTimeout(showDelayTimeout);
            showDelayTimeout = null;
        }
        showTooltip(target, text);
    }
    function handleMouseLeave(e) {
        if (showDelayTimeout) {
            clearTimeout(showDelayTimeout);
            showDelayTimeout = null;
        }
        hideTooltip();
    }
    function handleFocus(e) {
        const target = e.currentTarget;
        const text = getTooltipText(target);
        if (!text) return;
        if (showDelayTimeout) {
            clearTimeout(showDelayTimeout);
            showDelayTimeout = null;
        }
        showTooltip(target, text);
    }
    function handleBlur() {
        if (showDelayTimeout) {
            clearTimeout(showDelayTimeout);
            showDelayTimeout = null;
        }
        hideTooltip();
    }
    function initializeStatusTooltips() {
        const badges = document.querySelectorAll(BADGE_SELECTOR);
        badges.forEach(badge => {
            if (badge.hasAttribute('title')) {
                const titleText = badge.getAttribute('title');
                if (titleText && !badge.hasAttribute('data-blurb')) {
                    badge.setAttribute('data-blurb', titleText);
                }
                badge.removeAttribute('title');
            }
            badge.removeEventListener('mouseenter', handleMouseEnter);
            badge.removeEventListener('mouseleave', handleMouseLeave);
            badge.removeEventListener('focus', handleFocus);
            badge.removeEventListener('blur', handleBlur);
            badge.addEventListener('mouseenter', handleMouseEnter);
            badge.addEventListener('mouseleave', handleMouseLeave);
            badge.addEventListener('focus', handleFocus, true);
            badge.addEventListener('blur', handleBlur, true);
            if (!badge.hasAttribute('tabindex')) {
                badge.setAttribute('tabindex', '0');
            }
        });
    }
    function updateTooltipPosition() {
        if (currentTarget && tooltipElement && tooltipElement.style.opacity === '1') {
            const text = getTooltipText(currentTarget);
            if (text) {
                showTooltip(currentTarget, text);
            }
        }
    }
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeStatusTooltips);
    } else {
        initializeStatusTooltips();
    }
    const originalUpdateTable = window.updateTable || function() {};
    window.updateTable = function() {
        originalUpdateTable.apply(this, arguments);
        setTimeout(initializeStatusTooltips, 100);
    };
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(updateTooltipPosition, 100);
    });
    let scrollTimeout;
    window.addEventListener('scroll', () => {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(updateTooltipPosition, 50);
    }, { passive: true });
    window.addEventListener('beforeunload', () => {
        if (tooltipElement) {
            tooltipElement.remove();
        }
    });
    window.statusTooltipSystem = {
        initialize: initializeStatusTooltips,
        show: showTooltip,
        hide: hideTooltip
    };
})();
(function() {
    'use strict';
    const STORAGE_KEY = 'gbsv_picks';
    const UNIT_MULTIPLIER_KEY = 'gbsv_unit_multiplier';
    function getAllPicks() {
        try {
            const data = localStorage.getItem(STORAGE_KEY);
            return data ? JSON.parse(data) : [];
        } catch (e) {
            console.error('Error reading picks from localStorage:', e);
            return [];
        }
    }
    function savePicks(picks) {
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(picks));
            console.log(`✅ Saved ${picks.length} picks to localStorage`);
            return true;
        } catch (e) {
            console.error('Error saving picks to localStorage:', e);
            return false;
        }
    }
    function addPicks(newPicks) {
        const existing = getAllPicks();
        const enrichedPicks = newPicks.map((pick, idx) => ({
            ...pick,
            id: pick.id || `pick_${Date.now()}_${idx}_${Math.random().toString(36).substring(7)}`,
            createdAt: pick.createdAt || new Date().toISOString(),
            status: pick.status || 'pending'
        }));
        const all = [...existing, ...enrichedPicks];
        savePicks(all);
        return enrichedPicks;
    }
    function clearPicks() {
        localStorage.removeItem(STORAGE_KEY);
        console.log('🗑️ Cleared all picks from localStorage');
        refreshPicksTable();
    }
    function deletePick(pickId) {
        const picks = getAllPicks().filter(p => p.id !== pickId);
        savePicks(picks);
        refreshPicksTable();
    }
    function updatePickStatus(pickId, newStatus) {
        const picks = getAllPicks().map(p => {
            if (p.id === pickId) {
                return { ...p, status: newStatus, updatedAt: new Date().toISOString() };
            }
            return p;
        });
        savePicks(picks);
        refreshPicksTable();
    }
    function getUnitMultiplier() {
        return parseInt(localStorage.getItem(UNIT_MULTIPLIER_KEY)) || 1000;
    }
    function setUnitMultiplier(multiplier) {
        localStorage.setItem(UNIT_MULTIPLIER_KEY, multiplier.toString());
        if (window.PickStandardizer) {
            window.PickStandardizer.setUnitMultiplier(multiplier);
        }
    }
    const TEAM_DATA = {
        'san antonio spurs': { abbr: 'SAS', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/sa.png' },
        'spurs': { abbr: 'SAS', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/sa.png' },
        'new york knicks': { abbr: 'NYK', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/ny.png' },
        'knicks': { abbr: 'NYK', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/ny.png' },
        'los angeles lakers': { abbr: 'LAL', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/lal.png' },
        'lakers': { abbr: 'LAL', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/lal.png' },
        'golden state warriors': { abbr: 'GSW', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/gs.png' },
        'warriors': { abbr: 'GSW', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/gs.png' },
        'boston celtics': { abbr: 'BOS', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/bos.png' },
        'celtics': { abbr: 'BOS', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/bos.png' },
        'miami heat': { abbr: 'MIA', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/mia.png' },
        'heat': { abbr: 'MIA', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/mia.png' },
        'dallas mavericks': { abbr: 'DAL', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/dal.png' },
        'mavericks': { abbr: 'DAL', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/dal.png' },
        'mavs': { abbr: 'DAL', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/dal.png' },
        'denver nuggets': { abbr: 'DEN', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/den.png' },
        'nuggets': { abbr: 'DEN', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/den.png' },
        'phoenix suns': { abbr: 'PHX', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/phx.png' },
        'suns': { abbr: 'PHX', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/phx.png' },
        'milwaukee bucks': { abbr: 'MIL', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/mil.png' },
        'bucks': { abbr: 'MIL', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/mil.png' },
        'philadelphia 76ers': { abbr: 'PHI', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/phi.png' },
        '76ers': { abbr: 'PHI', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/phi.png' },
        'sixers': { abbr: 'PHI', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/phi.png' },
        'brooklyn nets': { abbr: 'BKN', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/bkn.png' },
        'nets': { abbr: 'BKN', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/bkn.png' },
        'chicago bulls': { abbr: 'CHI', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/chi.png' },
        'bulls': { abbr: 'CHI', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/chi.png' },
        'cleveland cavaliers': { abbr: 'CLE', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/cle.png' },
        'cavaliers': { abbr: 'CLE', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/cle.png' },
        'cavs': { abbr: 'CLE', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/cle.png' },
        'atlanta hawks': { abbr: 'ATL', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/atl.png' },
        'hawks': { abbr: 'ATL', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/atl.png' },
        'toronto raptors': { abbr: 'TOR', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/tor.png' },
        'raptors': { abbr: 'TOR', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/tor.png' },
        'orlando magic': { abbr: 'ORL', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/orl.png' },
        'magic': { abbr: 'ORL', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/orl.png' },
        'indiana pacers': { abbr: 'IND', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/ind.png' },
        'pacers': { abbr: 'IND', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/ind.png' },
        'detroit pistons': { abbr: 'DET', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/det.png' },
        'pistons': { abbr: 'DET', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/det.png' },
        'charlotte hornets': { abbr: 'CHA', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/cha.png' },
        'hornets': { abbr: 'CHA', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/cha.png' },
        'washington wizards': { abbr: 'WAS', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/wsh.png' },
        'wizards': { abbr: 'WAS', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/wsh.png' },
        'memphis grizzlies': { abbr: 'MEM', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/mem.png' },
        'grizzlies': { abbr: 'MEM', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/mem.png' },
        'new orleans pelicans': { abbr: 'NOP', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/no.png' },
        'pelicans': { abbr: 'NOP', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/no.png' },
        'houston rockets': { abbr: 'HOU', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/hou.png' },
        'rockets': { abbr: 'HOU', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/hou.png' },
        'minnesota timberwolves': { abbr: 'MIN', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/min.png' },
        'timberwolves': { abbr: 'MIN', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/min.png' },
        'wolves': { abbr: 'MIN', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/min.png' },
        'oklahoma city thunder': { abbr: 'OKC', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/okc.png' },
        'thunder': { abbr: 'OKC', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/okc.png' },
        'portland trail blazers': { abbr: 'POR', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/por.png' },
        'trail blazers': { abbr: 'POR', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/por.png' },
        'blazers': { abbr: 'POR', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/por.png' },
        'utah jazz': { abbr: 'UTA', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/utah.png' },
        'jazz': { abbr: 'UTA', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/utah.png' },
        'sacramento kings': { abbr: 'SAC', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/sac.png' },
        'kings': { abbr: 'SAC', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/sac.png' },
        'la clippers': { abbr: 'LAC', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/lac.png' },
        'clippers': { abbr: 'LAC', logo: 'https://a.espncdn.com/i/teamlogos/nba/500/lac.png' },
        'butler': { abbr: 'BUT', fullName: 'Butler Bulldogs', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/2086.png' },
        'butler bulldogs': { abbr: 'BUT', fullName: 'Butler Bulldogs', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/2086.png' },
        'connecticut': { abbr: 'CONN', fullName: 'UConn Huskies', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/41.png' },
        'u conn': { abbr: 'CONN', fullName: 'UConn Huskies', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/41.png' },
        'uconn': { abbr: 'CONN', fullName: 'UConn Huskies', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/41.png' },
        'uconn huskies': { abbr: 'CONN', fullName: 'UConn Huskies', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/41.png' },
        'abilene christian': { abbr: 'ACU', fullName: 'Abilene Christian Wildcats', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/2000.png' },
        'abilene christian wildcats': { abbr: 'ACU', fullName: 'Abilene Christian Wildcats', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/2000.png' },
        'arizona': { abbr: 'ARIZ', fullName: 'Arizona Wildcats', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/12.png' },
        'arizona wildcats': { abbr: 'ARIZ', fullName: 'Arizona Wildcats', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/12.png' },
        'montana st': { abbr: 'MTST', fullName: 'Montana State Bobcats', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/149.png' },
        'montana state': { abbr: 'MTST', fullName: 'Montana State Bobcats', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/149.png' },
        'montana state bobcats': { abbr: 'MTST', fullName: 'Montana State Bobcats', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/149.png' },
        'cal poly slo': { abbr: 'CPSU', fullName: 'Cal Poly Mustangs', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/13.png' },
        'cal poly': { abbr: 'CPSU', fullName: 'Cal Poly Mustangs', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/13.png' },
        'cal poly mustangs': { abbr: 'CPSU', fullName: 'Cal Poly Mustangs', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/13.png' },
        'oral roberts': { abbr: 'ORU', fullName: 'Oral Roberts Golden Eagles', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/198.png' },
        'oral roberts golden eagles': { abbr: 'ORU', fullName: 'Oral Roberts Golden Eagles', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/198.png' },
        'missouri st': { abbr: 'MOST', fullName: 'Missouri State Bears', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/2623.png' },
        'missouri state': { abbr: 'MOST', fullName: 'Missouri State Bears', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/2623.png' },
        'missouri state bears': { abbr: 'MOST', fullName: 'Missouri State Bears', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/2623.png' },
        'marist': { abbr: 'MAR', fullName: 'Marist Red Foxes', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/2368.png' },
        'marist red foxes': { abbr: 'MAR', fullName: 'Marist Red Foxes', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/2368.png' },
        'georgia tech': { abbr: 'GT', fullName: 'Georgia Tech Yellow Jackets', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/59.png' },
        'georgia tech yellow jackets': { abbr: 'GT', fullName: 'Georgia Tech Yellow Jackets', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/59.png' },
        'east tenn st': { abbr: 'ETSU', fullName: 'East Tennessee State Buccaneers', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/2193.png' },
        'east tennessee st': { abbr: 'ETSU', fullName: 'East Tennessee State Buccaneers', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/2193.png' },
        'east tennessee state': { abbr: 'ETSU', fullName: 'East Tennessee State Buccaneers', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/2193.png' },
        'east tennessee state buccaneers': { abbr: 'ETSU', fullName: 'East Tennessee State Buccaneers', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/2193.png' },
        'etsu buccaneers': { abbr: 'ETSU', fullName: 'East Tennessee State Buccaneers', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/2193.png' },
        'north carolina': { abbr: 'UNC', fullName: 'North Carolina Tar Heels', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/153.png' },
        'unc': { abbr: 'UNC', fullName: 'North Carolina Tar Heels', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/153.png' },
        'north carolina tar heels': { abbr: 'UNC', fullName: 'North Carolina Tar Heels', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/153.png' },
        'tar heels': { abbr: 'UNC', fullName: 'North Carolina Tar Heels', logo: 'https://a.espncdn.com/i/teamlogos/ncaa/500/153.png' }
    };
    function getTeamInfo(teamName) {
        if (!teamName) return { abbr: 'N/A', fullName: '', logo: '' };
        const lower = teamName.toLowerCase().trim();
        const data = TEAM_DATA[lower];
        if (data) {
            return { abbr: data.abbr, fullName: data.fullName || teamName, logo: data.logo };
        }
        return { abbr: teamName.substring(0, 3).toUpperCase(), fullName: teamName, logo: '' };
    }
    async function parseAndAddPicks(content) {
        if (!window.PickStandardizer) {
            console.error('PickStandardizer not loaded');
            return [];
        }
        window.PickStandardizer.setUnitMultiplier(getUnitMultiplier());
        const picks = window.PickStandardizer.standardize(content);
        if (picks.length === 0) {
            console.warn('No picks could be parsed from content');
            return [];
        }
        const enrichedPicks = await enrichPicksWithGameData(picks);
        const added = addPicks(enrichedPicks);
        refreshPicksTable();
        return added;
    }
    async function enrichPicksWithGameData(picks) {
        let todaysGames = [];
        if (window.AutoGameFetcher) {
            try {
                await window.AutoGameFetcher.fetchTodaysGames();
                todaysGames = window.AutoGameFetcher.getTodaysGames() || [];
                console.log(`🏀 Found ${todaysGames.length} games today:`, todaysGames.map(g => `${g.awayTeam} @ ${g.homeTeam} (${g.time})`));
            } catch (e) {
                console.warn('Could not fetch games:', e);
            }
        } else {
            console.warn('⚠️ AutoGameFetcher not available');
        }
        return picks.map(pick => {
            const enriched = { ...pick };
            const teamToFind = pick.pickTeam;
            console.log(`🔍 Looking for game with team: "${teamToFind}"`);
            if (window.AutoGameFetcher && todaysGames.length > 0) {
                const game = window.AutoGameFetcher.findGame(teamToFind);
                if (game) {
                    console.log(`✅ Found game: ${game.awayTeam} (${game.awayRecord}) @ ${game.homeTeam} (${game.homeRecord}) at ${game.time}`);
                    enriched.awayTeam = game.awayTeam;
                    enriched.homeTeam = game.homeTeam;
                    enriched.awayRecord = game.awayRecord || '';
                    enriched.homeRecord = game.homeRecord || '';
                    enriched.gameTime = game.time;
                    enriched.gameDate = game.date;
                    enriched.sport = game.sport;
                    enriched.gameStatus = game.status;
                    enriched.game = `${game.awayTeam} @ ${game.homeTeam}`;
                } else {
                    console.warn(`❌ No game found for "${teamToFind}" - available teams:`, 
                        todaysGames.flatMap(g => [g.awayTeam, g.homeTeam]));
                }
            }
            if (!enriched.gameDate) {
                enriched.gameDate = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            }
            if (!enriched.gameTime) {
                enriched.gameTime = 'TBD';
            }
            return enriched;
        });
    }
    function formatCurrencyValue(val) {
        if (val === undefined || val === null || val === '') return '$0.00';
        const num = typeof val === 'number' ? val : parseFloat(String(val).replace(/[$,]/g, ''));
        if (isNaN(num)) return '$0.00';
        return `$${num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
    }
    function formatDateValue(date) {
        if (!date) return 'Today';
        if (date.includes('/') || date.includes('-')) {
            const d = new Date(date);
            if (!isNaN(d)) {
                return d.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
            }
        }
        return date;
    }
    function partitionPicksByParlay(picks) {
        const parlayMap = new Map();
        const sequence = [];
        const parlayAdded = new Set();
        picks.forEach(pick => {
            if (pick.parlayId) {
                if (!parlayMap.has(pick.parlayId)) {
                    parlayMap.set(pick.parlayId, {
                        parlayId: pick.parlayId,
                        parlayType: pick.parlayType,
                        legs: []
                    });
                }
                parlayMap.get(pick.parlayId).legs.push(pick);
                if (!parlayAdded.has(pick.parlayId)) {
                    parlayAdded.add(pick.parlayId);
                    sequence.push({ type: 'parlay', parlayId: pick.parlayId });
                }
            } else {
                sequence.push({ type: 'single', pick });
            }
        });
        const parlayGroups = Array.from(parlayMap.values()).map(group => ({
            ...group,
            summary: buildParlaySummary(group)
        }));
        return { sequence, parlayGroups, parlayMap };
    }
    function buildParlaySummary(group) {
        const primary = group.legs[0];
        if (!primary) return {};
        const summary = {
            date: formatDateValue(primary.gameDate),
            time: primary.gameTime || 'TBD',
            sportsbook: primary.sportsbook || '',
            league: primary.sport,
            type: primary.parlayType || 'Parlay',
            risk: primary.parlaySummary?.risk ?? group.legs.reduce((sum, leg) => sum + (leg.parlaySummary?.risk || leg.risk || 0), 0),
            win: primary.parlaySummary?.win ?? group.legs.reduce((sum, leg) => sum + (leg.parlaySummary?.win || leg.win || 0), 0),
            segment: 'Parlay',
            legs: group.legs.length,
            status: primary.status || 'pending'
        };
        return summary;
    }
    const LEAGUE_LOGOS = {
        'NBA': 'https://a.espncdn.com/i/teamlogos/leagues/500/nba.png',
        'NFL': 'https://a.espncdn.com/i/teamlogos/leagues/500/nfl.png',
        'NCAAB': 'assets/logo_ncaam_bball.png',
        'NCAAM': 'assets/logo_ncaam_bball.png',
        "NCAA MEN'S BASKETBALL": 'assets/logo_ncaam_bball.png',
        'CBB': 'assets/logo_ncaam_bball.png',
        'NCAAF': 'assets/logo_ncaa_football',
        'COLLEGE FOOTBALL': 'assets/logo_ncaa_football',
        'CFB': 'assets/logo_ncaa_football',
        'MLB': 'https://a.espncdn.com/i/teamlogos/leagues/500/mlb.png',
        'NHL': 'https://a.espncdn.com/i/teamlogos/leagues/500/nhl.png',
        'MLS': 'https://a.espncdn.com/i/teamlogos/leagues/500/mls.png'
    };
    function renderLeagueCell(sport) {
        const logo = LEAGUE_LOGOS[sport] || '';
        return `
            <div class="league-cell">
                ${logo ? `<img src="${logo}" class="league-logo" alt="${sport}" onerror="this.style.display='none'">` : ''}
                <span class="league-text">${sport}</span>
            </div>
        `;
    }
    function toggleParlayLegs(parlayId, forceState) {
        const parentRow = document.querySelector(`tr.parlay-row[data-parlay-id="${parlayId}"]`);
        if (!parentRow) return;
        const legsRow = document.querySelector(`tr.parlay-legs[data-parent-id="${parlayId}"]`);
        const shouldExpand = typeof forceState === 'boolean' ? forceState : !parentRow.classList.contains('expanded');
        parentRow.classList.toggle('expanded', shouldExpand);
        parentRow.setAttribute('aria-expanded', shouldExpand);
        if (legsRow) {
            legsRow.style.display = shouldExpand ? 'table-row' : 'none';
        }
        const arrow = parentRow.querySelector('.parlay-expand-arrow');
        if (arrow) {
            arrow.style.transform = shouldExpand ? 'rotate(90deg)' : 'rotate(0deg)';
        }
    }
    function refreshPicksTable() {
        const picks = getAllPicks();
        const tbody = document.getElementById('picks-tbody');
        if (!tbody) {
            return;
        }
        tbody.innerHTML = '';
        const tableContainer = tbody.closest('.table-container');
        if (tableContainer) {
            tableContainer.classList.toggle('has-picks', picks.length > 0);
        }
        if (picks.length === 0) {
            console.log('No picks to display');
            return;
        }
        const { sequence, parlayGroups, parlayMap } = partitionPicksByParlay(picks);
        const parlayLookup = new Map(parlayGroups.map(group => [group.parlayId, group]));
        sequence.forEach((entry, entryIdx) => {
            if (entry.type === 'single') {
                const row = createPickRow(entry.pick, entryIdx);
                tbody.appendChild(row);
            } else {
                const group = parlayLookup.get(entry.parlayId);
                if (!group) return;
                const parentRow = createParlayParentRow(group, entryIdx);
                tbody.appendChild(parentRow);
                const legsRow = document.createElement('tr');
                legsRow.className = 'parlay-legs';
                legsRow.setAttribute('data-parent-id', group.parlayId);
                legsRow.style.display = 'none'; 
                const legsCell = document.createElement('td');
                legsCell.colSpan = 7; 
                legsCell.style.padding = '0'; 
                const containerDiv = document.createElement('div');
                containerDiv.className = 'parlay-legs-container';
                const headerDiv = document.createElement('div');
                headerDiv.className = 'parlay-legs-header';
                headerDiv.innerHTML = `
                    <div class="parlay-legs-title">
                        <span class="parlay-legs-heading">Parlay Details</span>
                    </div>
                `;
                containerDiv.appendChild(headerDiv);
                const legsTable = document.createElement('table');
                legsTable.className = 'picks-table compact-leg-table';
                legsTable.style.width = '100%';
                legsTable.style.margin = '0';
                const legsThead = document.createElement('thead');
                legsThead.innerHTML = `
                    <tr>
                        <th>Date</th>
                        <th>Matchup</th>
                        <th>Pick</th>
                        <th>Segment</th>
                        <th>Status</th>
                    </tr>
                `;
                legsTable.appendChild(legsThead);
                const legsTbody = document.createElement('tbody');
                group.legs.forEach((leg, legIdx) => {
                    const legRow = createParlayLegRow(leg);
                    legsTbody.appendChild(legRow);
                });
                legsTable.appendChild(legsTbody);
                containerDiv.appendChild(legsTable);
                legsCell.appendChild(containerDiv);
                legsRow.appendChild(legsCell);
                tbody.appendChild(legsRow);
            }
        });
        console.log(`📊 Displayed ${picks.length} picks in table`);
        if (typeof window.calculateKPIs === 'function' && typeof window.updateKPITiles === 'function') {
            const kpis = window.calculateKPIs(picks);
            window.updateKPITiles(kpis);
        }
        if (typeof window.updateLastRefreshedTimestamp === 'function') {
            window.updateLastRefreshedTimestamp();
        }
        if (window.ZebraStripes?.applyPicksTableZebraStripes) {
            setTimeout(() => window.ZebraStripes.applyPicksTableZebraStripes(), 50);
        }
        document.dispatchEvent(new CustomEvent('picksRefreshed', { detail: { count: picks.length } }));
    }
    function createParlayLegRow(pick) {
        const row = document.createElement('tr');
        row.classList.add('parlay-leg-item');
        const pickTeamInfo = getTeamInfo(pick.pickTeam);
        const awayTeam = pick.awayTeam || pick.pickTeam || 'TBD';
        const homeTeam = pick.homeTeam || 'TBD';
        const awayInfo = getTeamInfo(awayTeam);
        const homeInfo = getTeamInfo(homeTeam);
        let selection = '';
        let market = '';
        if (pick.pickType === 'spread') {
            const line = pick.line || '';
            selection = line.startsWith('+') || line.startsWith('-') ? line : `+${line}`;
            market = 'Spread';
        } else if (pick.pickType === 'moneyline') {
            selection = 'ML';
            market = 'Moneyline';
        } else if (pick.pickType === 'total' || pick.pickType === 'team-total') {
            selection = `${pick.pickDirection || 'Over'} ${pick.line || ''}`;
            market = 'Total';
        }
        const status = pick.status || 'pending';
        const isSingleTeamBet = !pick.homeTeam || homeTeam === 'TBD';
        const awayLogoHtml = awayInfo.logo 
            ? `<img src="${awayInfo.logo}" class="team-logo" alt="${awayInfo.abbr}" onerror="this.style.display='none'">`
            : '';
        const homeLogoHtml = homeInfo.logo 
            ? `<img src="${homeInfo.logo}" class="team-logo" alt="${homeInfo.abbr}" onerror="this.style.display='none'">`
            : '';
        const pickLogoHtml = pickTeamInfo.logo
            ? `<img src="${pickTeamInfo.logo}" class="pick-team-logo" alt="${pickTeamInfo.abbr}" onerror="this.style.display='none'">`
            : '';
        const matchupHtml = isSingleTeamBet 
            ? `<div class="matchup-cell-parlay-leg">
                    <div class="team-line">
                        ${awayLogoHtml}
                        <span class="team-name-full">${awayTeam}</span>
                    </div>
                </div>`
            : `<div class="matchup-cell-parlay-leg">
                    <div class="team-line">
                        ${awayLogoHtml}
                        <span class="team-name-full">${awayTeam}</span>
                    </div>
                    <div class="vs-divider">vs</div>
                    <div class="team-line">
                        ${homeLogoHtml}
                        <span class="team-name-full">${homeTeam}</span>
                    </div>
                </div>`;
        row.innerHTML = `
            <td data-label="Date & Time">
                <div class="cell-date">${formatDateValue(pick.gameDate)}</div>
                <div class="cell-time">${pick.gameTime || 'TBD'}</div>
            </td>
            <td>
                ${matchupHtml}
            </td>
            <td>
                <div class="pick-cell">
                    <div class="pick-team-info">
                        ${pickLogoHtml}
                        <span class="pick-team-abbr">${pickTeamInfo.abbr}</span>
                    </div>
                    <div class="pick-details">
                        <span class="pick-market">${market}</span>
                        <span class="pick-selection">${selection}</span>
                        <span class="pick-odds">(${pick.odds || '-110'})</span>
                    </div>
                </div>
            </td>
            <td class="center">
                <span class="game-segment">${pick.segment || 'Full Game'}</span>
            </td>
            <td class="center">
                <span class="status-badge" data-status="${status}">${status.charAt(0).toUpperCase() + status.slice(1)}</span>
            </td>
        `;
        return row;
    }
    function createPickRow(pick, idx, options = {}) {
        const row = document.createElement('tr');
        const { isParlayLeg = false } = options;
        if (isParlayLeg) {
            row.classList.add('parlay-leg', 'parlay-leg-hidden');
        }
        const pickTeamInfo = getTeamInfo(pick.pickTeam);
        const awayTeam = pick.awayTeam || pick.pickTeam || 'TBD';
        const homeTeam = pick.homeTeam || 'TBD';
        const awayRecord = pick.awayRecord || '';
        const homeRecord = pick.homeRecord || '';
        const awayInfo = getTeamInfo(awayTeam);
        const homeInfo = getTeamInfo(homeTeam);
        const segment = pick.segment || 'Full Game';
        const segmentKey = segment.toLowerCase().includes('1h') || segment.toLowerCase().includes('1st') ? '1h' :
                          segment.toLowerCase().includes('2h') || segment.toLowerCase().includes('2nd') ? '2h' :
                          'full-game';
        const segmentLabel = {
            '1h': '1st Half',
            '2h': '2nd Half',
            '1q': '1st Quarter',
            '2q': '2nd Quarter',
            '3q': '3rd Quarter',
            '4q': '4th Quarter',
            'full-game': 'Full Game'
        }[segmentKey] || 'Full Game';
        let selection = '';
        if (pick.pickType === 'spread') {
            const line = pick.line || '';
            selection = line.startsWith('+') || line.startsWith('-') ? line : `+${line}`;
        } else if (pick.pickType === 'moneyline') {
            selection = 'ML';
        } else if (pick.pickType === 'total' || pick.pickType === 'team-total') {
            selection = `${pick.pickDirection || 'Over'} ${pick.line || ''}`;
        }
        const status = pick.status || 'pending';
        const sportsbook = pick.sportsbook || '';
        const sport = (pick.sport || 'NBA').toUpperCase();
        const epochTime = pick.gameDate && pick.gameTime ?
            new Date(`${pick.gameDate} ${pick.gameTime}`).getTime() : Date.now();
        row.setAttribute('data-pick-id', pick.id || `pick-${idx}`);
        row.setAttribute('data-league', sport.toLowerCase());
        row.setAttribute('data-epoch', epochTime);
        row.setAttribute('data-book', sportsbook.toLowerCase());
        row.setAttribute('data-away', awayTeam.toLowerCase());
        row.setAttribute('data-home', homeTeam.toLowerCase());
        row.setAttribute('data-pick-type', pick.pickType || 'spread');
        row.setAttribute('data-pick-text', selection);
        row.setAttribute('data-segment', segmentKey);
        row.setAttribute('data-odds', pick.odds || '');
        row.setAttribute('data-risk', pick.risk || '');
        row.setAttribute('data-win', pick.win || '');
        row.setAttribute('data-status', status);
        row.setAttribute('data-is-parlay', pick.isParlay ? 'true' : 'false');
        if (pick.parlayId) row.setAttribute('data-parlay-id', pick.parlayId);
        row.classList.add('group-start');
        const isSingleTeamBet = !pick.homeTeam || homeTeam === 'TBD';
        const awayLogoHtml = awayInfo.logo 
            ? `<img src="${awayInfo.logo}" class="team-logo" alt="${awayInfo.abbr}" onerror="this.style.display='none'">`
            : '';
        const homeLogoHtml = homeInfo.logo 
            ? `<img src="${homeInfo.logo}" class="team-logo" alt="${homeInfo.abbr}" onerror="this.style.display='none'">`
            : '';
        const pickLogoHtml = pickTeamInfo.logo
            ? `<img src="${pickTeamInfo.logo}" class="pick-team-logo" alt="${pickTeamInfo.abbr}" onerror="this.style.display='none'">`
            : '';
        const matchupHtml = isSingleTeamBet 
            ? `<div class="matchup-cell">
                    <div class="team-line">
                        ${awayLogoHtml}
                        <div class="team-name-wrapper">
                            <span class="team-name-full">${awayTeam}</span>
                            <span class="team-record">${awayRecord ? `(${awayRecord})` : ''}</span>
                        </div>
                    </div>
                </div>`
            : `<div class="matchup-cell">
                    <div class="team-line">
                        ${awayLogoHtml}
                        <div class="team-name-wrapper">
                            <span class="team-name-full">${awayTeam}</span>
                            <span class="team-record">${awayRecord ? `(${awayRecord})` : ''}</span>
                        </div>
                    </div>
                    <div class="vs-divider">vs</div>
                    <div class="team-line">
                        ${homeLogoHtml}
                        <div class="team-name-wrapper">
                            <span class="team-name-full">${homeTeam}</span>
                            <span class="team-record">${homeRecord ? `(${homeRecord})` : ''}</span>
                        </div>
                    </div>
                </div>`;
        const useQuarters = sport === 'NBA' || sport === 'NFL';
        const boxscoreClass = useQuarters ? 'boxscore-quarters' : 'boxscore-halves';
        let awayBoxRow, homeBoxRow, headerCells;
        if (useQuarters) {
            headerCells = `
                <div class="boxscore-cell header-cell">Q1</div>
                <div class="boxscore-cell header-cell">Q2</div>
                <div class="boxscore-cell header-cell">Q3</div>
                <div class="boxscore-cell header-cell">Q4</div>
                <div class="boxscore-cell header-cell">T</div>`;
            awayBoxRow = `
                <div class="boxscore-row">
                    <div class="boxscore-cell team-cell">
                        <div class="boxscore-team">
                            ${awayInfo.logo ? `<img src="${awayInfo.logo}" class="boxscore-team-logo" alt="${awayInfo.abbr}" onerror="this.style.display='none'">` : ''}
                            <span class="boxscore-team-abbr">${awayInfo.abbr}</span>
                        </div>
                    </div>
                    <div class="boxscore-cell period-cell q1-away"></div>
                    <div class="boxscore-cell period-cell q2-away"></div>
                    <div class="boxscore-cell period-cell q3-away"></div>
                    <div class="boxscore-cell period-cell q4-away"></div>
                    <div class="boxscore-cell total total-away"></div>
                </div>`;
            homeBoxRow = `
                <div class="boxscore-row">
                    <div class="boxscore-cell team-cell">
                        <div class="boxscore-team">
                            ${homeInfo.logo ? `<img src="${homeInfo.logo}" class="boxscore-team-logo" alt="${homeInfo.abbr}" onerror="this.style.display='none'">` : ''}
                            <span class="boxscore-team-abbr">${homeInfo.abbr}</span>
                        </div>
                    </div>
                    <div class="boxscore-cell period-cell q1-home"></div>
                    <div class="boxscore-cell period-cell q2-home"></div>
                    <div class="boxscore-cell period-cell q3-home"></div>
                    <div class="boxscore-cell period-cell q4-home"></div>
                    <div class="boxscore-cell total total-home"></div>
                </div>`;
        } else {
            headerCells = `
                <div class="boxscore-cell header-cell">1H</div>
                <div class="boxscore-cell header-cell">2H</div>
                <div class="boxscore-cell header-cell">T</div>`;
            awayBoxRow = `
                <div class="boxscore-row">
                    <div class="boxscore-cell team-cell">
                        <div class="boxscore-team">
                            ${awayInfo.logo ? `<img src="${awayInfo.logo}" class="boxscore-team-logo" alt="${awayInfo.abbr}" onerror="this.style.display='none'">` : ''}
                            <span class="boxscore-team-abbr">${awayInfo.abbr}</span>
                        </div>
                    </div>
                    <div class="boxscore-cell period-cell h1-away"></div>
                    <div class="boxscore-cell period-cell h2-away"></div>
                    <div class="boxscore-cell total total-away"></div>
                </div>`;
            homeBoxRow = `
                <div class="boxscore-row">
                    <div class="boxscore-cell team-cell">
                        <div class="boxscore-team">
                            ${homeInfo.logo ? `<img src="${homeInfo.logo}" class="boxscore-team-logo" alt="${homeInfo.abbr}" onerror="this.style.display='none'">` : ''}
                            <span class="boxscore-team-abbr">${homeInfo.abbr}</span>
                        </div>
                    </div>
                    <div class="boxscore-cell period-cell h1-home"></div>
                    <div class="boxscore-cell period-cell h2-home"></div>
                    <div class="boxscore-cell total total-home"></div>
                </div>`;
        }
        const pickStatus = pick.status || 'pending';
        let statusText = pick.gameTime || 'Pending';
        let statusClass = 'countdown';
        if (pickStatus === 'final' || pickStatus === 'win' || pickStatus === 'loss' || pickStatus === 'push') {
            statusText = 'Final';
            statusClass = 'final';
        } else if (pickStatus === 'live' || pickStatus === 'on-track' || pickStatus === 'at-risk') {
            statusText = pick.gameTime || 'Live';
            statusClass = 'live';
        } else if (pickStatus === 'pending') {
            statusText = pick.gameTime || 'Pending';
            statusClass = 'countdown';
        }
        const boxscoreHtml = `
            <div class="boxscore-container" data-live-ready="false">
                <div class="compact-boxscore">
                    <div class="boxscore-grid ${boxscoreClass}">
                        <div class="boxscore-row header">
                            <div class="boxscore-cell header-cell game-time-cell">
                                <span class="game-time-status ${statusClass}">${statusText}</span>
                            </div>
                            ${headerCells}
                        </div>
                        ${awayBoxRow}
                        ${isSingleTeamBet ? '' : homeBoxRow}
                    </div>
                </div>
            </div>`;
        row.innerHTML = `
            <td data-label="Date & Time">
                <div class="cell-date">${formatDateValue(pick.gameDate)}</div>
                <div class="cell-time">${pick.gameTime || 'TBD'}</div>
                <div class="sportsbook-value">${sportsbook}</div>
            </td>
            <td>
                ${matchupHtml}
            </td>
            <td>
                <div class="pick-cell">
                    <div class="pick-team-info">
                        ${pickLogoHtml}
                        <span class="pick-team-abbr">${pickTeamInfo.abbr}</span>
                    </div>
                    <div class="pick-details">
                        <span class="pick-line">${selection}</span>
                        <span class="pick-odds">(${pick.odds || '-110'})</span>
                    </div>
                </div>
            </td>
            <td class="center">
                <span class="game-segment" data-segment="${segmentKey}">${segmentLabel}</span>
            </td>
            <td class="center">
                <span class="currency-combined">
                    <span class="currency-line">
                        <span class="risk-label">$ At Risk</span>
                        <span class="risk-amount">${formatCurrencyValue(pick.risk)}</span>
                    </span>
                    <span class="currency-line">
                        <span class="win-label">To Win</span>
                        <span class="win-amount">${formatCurrencyValue(pick.win)}</span>
                    </span>
                </span>
            </td>
            <td class="center">
                ${boxscoreHtml}
            </td>
            <td class="center">
                <span class="status-badge" data-status="${status}" data-blurb="">${status.charAt(0).toUpperCase() + status.slice(1)}</span>
            </td>
        `;
        return row;
    }
    function createParlayParentRow(group, idx) {
        const row = document.createElement('tr');
        row.classList.add('parlay-row');
        row.setAttribute('data-parlay-id', group.parlayId);
        row.setAttribute('aria-expanded', 'false');
        const summary = group.summary || {};
        const status = (summary.status || 'pending').toLowerCase();
        const legCount = summary.legs || group.legs.length;
        row.innerHTML = `
            <td data-label="Date & Time">
                <div class="cell-date">${summary.date || 'Today'}</div>
                <div class="cell-time">${summary.time || 'TBD'}</div>
                <div class="sportsbook-value">${summary.sportsbook || ''}</div>
            </td>
            <td>
                <div class="matchup-cell parlay-matchup">
                    <span class="parlay-expand-arrow">▶</span>
                    <span class="team-name-full">Multi-Leg</span>
                    <span class="parlay-leg-count">(${legCount} legs)</span>
                </div>
            </td>
            <td>
                <div class="pick-cell">
                    <span class="pick-team-abbr">${summary.type || 'Parlay'}</span>
                </div>
            </td>
            <td class="center">
                <span class="game-segment" data-segment="parlay">Parlay</span>
            </td>
            <td class="center">
                <span class="currency-combined">
                    <span class="currency-line">
                        <span class="risk-label">$ At Risk</span>
                        <span class="risk-amount">${formatCurrencyValue(summary.risk)}</span>
                    </span>
                    <span class="currency-line">
                        <span class="win-label">To Win</span>
                        <span class="win-amount">${formatCurrencyValue(summary.win)}</span>
                    </span>
                </span>
            </td>
            <td class="center">
                <span class="boxscore-placeholder">—</span>
            </td>
            <td class="center">
                <span class="status-badge" data-status="${status}">${status.charAt(0).toUpperCase() + status.slice(1)}</span>
            </td>
        `;
        row.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleParlayLegs(group.parlayId);
        });
        return row;
    }
    async function reEnrichExistingPicks() {
        const picks = getAllPicks();
        if (picks.length === 0) return;
        const needsEnrichment = picks.some(p => !p.awayRecord && !p.homeRecord);
        if (!needsEnrichment) {
            console.log('✅ All picks already have records');
            return;
        }
        console.log('🔄 Re-enriching existing picks with ESPN data...');
        let attempts = 0;
        while (!window.AutoGameFetcher && attempts < 10) {
            await new Promise(r => setTimeout(r, 200));
            attempts++;
        }
        if (!window.AutoGameFetcher) {
            console.warn('⚠️ AutoGameFetcher not available for re-enrichment');
            return;
        }
        try {
            await window.AutoGameFetcher.fetchTodaysGames();
            const todaysGames = window.AutoGameFetcher.getTodaysGames() || [];
            if (todaysGames.length === 0) {
                console.log('📭 No games today to enrich with');
                return;
            }
            console.log(`🏀 Found ${todaysGames.length} games for enrichment`);
            let updated = false;
            const enrichedPicks = picks.map(pick => {
                if (pick.awayRecord || pick.homeRecord) return pick;
                const teamToFind = pick.pickTeam || pick.awayTeam;
                if (!teamToFind) return pick;
                const game = window.AutoGameFetcher.findGame(teamToFind);
                if (game) {
                    console.log(`📝 Enriching: ${pick.pickTeam} -> ${game.awayTeam} (${game.awayRecord}) vs ${game.homeTeam} (${game.homeRecord})`);
                    updated = true;
                    return {
                        ...pick,
                        awayTeam: game.awayTeam,
                        homeTeam: game.homeTeam,
                        awayRecord: game.awayRecord || '',
                        homeRecord: game.homeRecord || '',
                        gameTime: pick.gameTime || game.time,
                        gameDate: pick.gameDate || game.date,
                        sport: pick.sport || game.sport,
                        gameStatus: game.status
                    };
                }
                return pick;
            });
            if (updated) {
                savePicks(enrichedPicks);
                console.log('✅ Picks re-enriched with team records');
                refreshPicksTable();
            }
        } catch (e) {
            console.error('Error re-enriching picks:', e);
        }
    }
    function importTodaysPicks() {
        const existingPicks = getAllPicks();
        if (existingPicks.length > 0) {
            console.log(`✅ Skipping demo import - user has ${existingPicks.length} existing picks`);
            return;
        }
        const IMPORT_KEY = 'gbsv_demo_imported_v1';
        if (localStorage.getItem(IMPORT_KEY)) {
            console.log('✅ Demo picks already imported');
            return;
        }
        const today = new Date();
        const todayStr = today.toISOString().split('T')[0]; 
        const demoPicks = [
            { sport: 'NBA', sportsbook: 'Demo Book', pickTeam: 'San Antonio Spurs', awayTeam: 'San Antonio Spurs', homeTeam: 'New York Knicks', awayRecord: '13-13', homeRecord: '18-9', pickType: 'spread', line: '+2.5', odds: '-110', segment: 'Full Game', gameDate: todayStr, gameTime: '7:30 PM', risk: 1100, win: 1000, isParlay: false, status: 'pending' },
            { sport: 'NCAAB', sportsbook: 'Demo Book', pickTeam: 'Butler Bulldogs', awayTeam: 'Butler Bulldogs', homeTeam: 'UConn Huskies', awayRecord: '6-4', homeRecord: '8-2', pickType: 'total', pickDirection: 'Over', line: '145.5', odds: '-110', segment: 'Full Game', gameDate: todayStr, gameTime: '8:00 PM', risk: 1100, win: 1000, isParlay: false, status: 'pending' }
        ];
        addPicks(demoPicks);
        localStorage.setItem(IMPORT_KEY, 'true');
        console.log('🎯 Imported demo picks for new users');
    }
    function initialize() {
        console.log('🏠 LocalPicksManager v2.2 initialized (auto re-enrich)');
        importTodaysPicks();
        window.processAndSavePicks = parseAndAddPicks;
        window.loadUploadedPicks = refreshPicksTable;
        refreshPicksTable();
        setTimeout(() => reEnrichExistingPicks(), 500);
    }
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
    } else {
        initialize();
    }
    window.LocalPicksManager = {
        getAll: getAllPicks,
        add: addPicks,
        parseAndAdd: parseAndAddPicks,
        clear: clearPicks,
        delete: deletePick,
        updateStatus: updatePickStatus,
        refresh: refreshPicksTable,
        reEnrich: reEnrichExistingPicks,
        getUnitMultiplier,
        setUnitMultiplier
    };
    console.log('✅ LocalPicksManager v2.2 loaded');
})();
