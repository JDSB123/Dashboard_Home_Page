(function() {
    'use strict';
    function getApiUrl() {
        return window.APP_CONFIG?.API_BASE_URL || '/api';
    }
    function formatMoney(val) {
        if (!val) return '$0.00';
        const num = parseFloat(String(val).replace(/[$,]/g, ''));
        return isNaN(num) ? '$0.00' : `$${num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
    }
    function formatMoneyValue(val) {
        if (!val) return '0.00';
        const num = parseFloat(String(val).replace(/[$,]/g, ''));
        return isNaN(num) ? '0.00' : num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }
    function getStatusLabel(status) {
        const labels = {
            'pending': 'Pending',
            'on-track': 'On Track',
            'at-risk': 'At Risk',
            'hit': 'Hit',
            'miss': 'Miss',
            'push': 'Push'
        };
        return labels[status] || status;
    }
    function getSegmentLabel(segment) {
        const labels = {
            'full-game': 'Full Game',
            'fg': 'Full Game',
            '1h': '1st Half',
            '2h': '2nd Half',
            '1q': '1st Quarter',
            '2q': '2nd Quarter',
            '3q': '3rd Quarter',
            '4q': '4th Quarter'
        };
        return labels[(segment || '').toLowerCase()] || segment || 'Full Game';
    }
    function getTeamAbbr(teamName) {
        if (!teamName) return '';
        const abbrs = {
            'raiders': 'LV', 'las vegas raiders': 'LV',
            'broncos': 'DEN', 'denver broncos': 'DEN',
            'chiefs': 'KC', 'kansas city chiefs': 'KC',
            'chargers': 'LAC', 'los angeles chargers': 'LAC',
            'cowboys': 'DAL', 'dallas cowboys': 'DAL',
            'eagles': 'PHI', 'philadelphia eagles': 'PHI',
            'giants': 'NYG', 'new york giants': 'NYG',
            'commanders': 'WSH', 'washington commanders': 'WSH',
            'packers': 'GB', 'green bay packers': 'GB',
            'bears': 'CHI', 'chicago bears': 'CHI',
            'lions': 'DET', 'detroit lions': 'DET',
            'vikings': 'MIN', 'minnesota vikings': 'MIN',
            'falcons': 'ATL', 'atlanta falcons': 'ATL',
            'saints': 'NO', 'new orleans saints': 'NO',
            'panthers': 'CAR', 'carolina panthers': 'CAR',
            'buccaneers': 'TB', 'tampa bay buccaneers': 'TB',
            'bills': 'BUF', 'buffalo bills': 'BUF',
            'dolphins': 'MIA', 'miami dolphins': 'MIA',
            'jets': 'NYJ', 'new york jets': 'NYJ',
            'patriots': 'NE', 'new england patriots': 'NE',
            'bengals': 'CIN', 'cincinnati bengals': 'CIN',
            'browns': 'CLE', 'cleveland browns': 'CLE',
            'steelers': 'PIT', 'pittsburgh steelers': 'PIT',
            'ravens': 'BAL', 'baltimore ravens': 'BAL',
            'colts': 'IND', 'indianapolis colts': 'IND',
            'jaguars': 'JAX', 'jacksonville jaguars': 'JAX',
            'texans': 'HOU', 'houston texans': 'HOU',
            'titans': 'TEN', 'tennessee titans': 'TEN',
            'seahawks': 'SEA', 'seattle seahawks': 'SEA',
            '49ers': 'SF', 'san francisco 49ers': 'SF',
            'rams': 'LAR', 'los angeles rams': 'LAR',
            'cardinals': 'ARI', 'arizona cardinals': 'ARI',
            'lakers': 'LAL', 'los angeles lakers': 'LAL',
            'clippers': 'LAC', 'la clippers': 'LAC',
            'warriors': 'GSW', 'golden state warriors': 'GSW',
            'suns': 'PHX', 'phoenix suns': 'PHX',
            'celtics': 'BOS', 'boston celtics': 'BOS',
            'nets': 'BKN', 'brooklyn nets': 'BKN',
            'knicks': 'NYK', 'new york knicks': 'NYK',
            '76ers': 'PHI', 'philadelphia 76ers': 'PHI',
            'heat': 'MIA', 'miami heat': 'MIA',
            'magic': 'ORL', 'orlando magic': 'ORL',
            'bulls': 'CHI', 'chicago bulls': 'CHI',
            'bucks': 'MIL', 'milwaukee bucks': 'MIL',
            'cavaliers': 'CLE', 'cleveland cavaliers': 'CLE',
            'pistons': 'DET', 'detroit pistons': 'DET',
            'pacers': 'IND', 'indiana pacers': 'IND',
            'hawks': 'ATL', 'atlanta hawks': 'ATL',
            'hornets': 'CHA', 'charlotte hornets': 'CHA',
            'wizards': 'WAS', 'washington wizards': 'WAS',
            'raptors': 'TOR', 'toronto raptors': 'TOR',
            'nuggets': 'DEN', 'denver nuggets': 'DEN',
            'jazz': 'UTA', 'utah jazz': 'UTA',
            'blazers': 'POR', 'portland trail blazers': 'POR',
            'thunder': 'OKC', 'oklahoma city thunder': 'OKC',
            'timberwolves': 'MIN', 'minnesota timberwolves': 'MIN',
            'pelicans': 'NOP', 'new orleans pelicans': 'NOP',
            'grizzlies': 'MEM', 'memphis grizzlies': 'MEM',
            'spurs': 'SAS', 'san antonio spurs': 'SAS',
            'rockets': 'HOU', 'houston rockets': 'HOU',
            'mavericks': 'DAL', 'dallas mavericks': 'DAL',
            'kings': 'SAC', 'sacramento kings': 'SAC'
        };
        const key = teamName.toLowerCase().trim();
        if (abbrs[key]) {
            return abbrs[key];
        }
        const words = teamName.trim().split(/\s+/);
        return words[words.length - 1].substring(0, 3).toUpperCase();
    }
    function parseTeamsFromGame(gameString) {
        if (!gameString) return { away: '', home: '' };
        const separators = ['@', ' vs ', ' vs. ', ' / '];
        for (const sep of separators) {
            if (gameString.includes(sep)) {
                const parts = gameString.split(sep);
                return {
                    away: parts[0].trim(),
                    home: parts[1] ? parts[1].trim() : ''
                };
            }
        }
        return { away: gameString.trim(), home: '' };
    }
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    function formatFileSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }
    function debounce(func, wait = 150, immediate = false) {
        let timeout;
        function debounced(...args) {
            const context = this;
            const later = function() {
                timeout = null;
                if (!immediate) func.apply(context, args);
            };
            const callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) func.apply(context, args);
        }
        debounced.cancel = function() {
            clearTimeout(timeout);
            timeout = null;
        };
        return debounced;
    }
    function throttle(func, wait = 100) {
        let lastCall = 0;
        let timeout = null;
        return function throttled(...args) {
            const context = this;
            const now = Date.now();
            const remaining = wait - (now - lastCall);
            if (remaining <= 0 || remaining > wait) {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                }
                lastCall = now;
                func.apply(context, args);
            } else if (!timeout) {
                timeout = setTimeout(function() {
                    lastCall = Date.now();
                    timeout = null;
                    func.apply(context, args);
                }, remaining);
            }
        };
    }
    function formatDate(date) {
        if (!date) return 'TBD';
        const d = new Date(date);
        if (isNaN(d.getTime())) return 'TBD';
        const month = (d.getMonth() + 1).toString().padStart(2, '0');
        const day = d.getDate().toString().padStart(2, '0');
        const year = d.getFullYear();
        return `${month}/${day}/${year}`;
    }
    function formatTime(date) {
        if (!date) return 'TBD';
        const d = new Date(date);
        if (isNaN(d.getTime())) return 'TBD';
        return d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true });
    }
    window.SharedUtils = {
        getApiUrl,
        formatMoney,
        formatMoneyValue,
        getStatusLabel,
        getSegmentLabel,
        getTeamAbbr,
        parseTeamsFromGame,
        escapeHtml,
        formatFileSize,
        formatDate,
        formatTime,
        debounce,
        throttle
    };
})();
(function() {
    'use strict';
    class LogoCache {
        constructor() {
            this.memoryCache = new Map();
            this.preloadQueue = [];
            this.batchSize = 10;
            this.isPreloading = false;
            this.localStorageKey = 'gbsv_logo_cache_v1';
            this.cacheVersion = '1.0';
            this.maxCacheAge = 24 * 60 * 60 * 1000; 
            this.maxCacheSize = 100; 
            this.loadFromLocalStorage();
            this.getTeamLogo = this.getTeamLogo.bind(this);
            this.preloadLogos = this.preloadLogos.bind(this);
        }
        loadFromLocalStorage() {
            try {
                const stored = localStorage.getItem(this.localStorageKey);
                if (stored) {
                    const parsed = JSON.parse(stored);
                    if (parsed.version === this.cacheVersion) {
                        const now = Date.now();
                        for (const [key, value] of Object.entries(parsed.logos || {})) {
                            if (now - value.timestamp < this.maxCacheAge) {
                                this.memoryCache.set(key, value.url);
                            }
                        }
                    }
                }
            } catch (error) {
                console.warn('Failed to load logo cache from localStorage:', error);
            }
        }
        saveToLocalStorage() {
            try {
                const cacheData = {
                    version: this.cacheVersion,
                    logos: {}
                };
                const entries = Array.from(this.memoryCache.entries());
                if (entries.length > this.maxCacheSize) {
                    entries.splice(this.maxCacheSize);
                }
                for (const [key, url] of entries) {
                    cacheData.logos[key] = {
                        url: url,
                        timestamp: Date.now()
                    };
                }
                localStorage.setItem(this.localStorageKey, JSON.stringify(cacheData));
            } catch (error) {
                console.warn('Failed to save logo cache to localStorage:', error);
            }
        }
        async getTeamLogo(teamName, league = 'nfl') {
            if (!teamName) {
                return '';
            }
            const cacheKey = `${league}:${teamName.toLowerCase()}`;
            if (this.memoryCache.has(cacheKey)) {
                return this.memoryCache.get(cacheKey);
            }
            const apiAvailable = window.APP_CONFIG && window.APP_CONFIG.API_BASE_URL;
            if (apiAvailable) {
                try {
                    const response = await fetch(`${window.APP_CONFIG.API_BASE_URL}/get-logo?team=${encodeURIComponent(teamName)}&league=${encodeURIComponent(league)}`);
                    if (response.ok) {
                        const data = await response.json();
                        const logoUrl = data.logoUrl;
                        this.memoryCache.set(cacheKey, logoUrl);
                        this.saveToLocalStorage();
                        return logoUrl;
                    }
                } catch (error) {
                    console.warn(`Failed to fetch logo from API for ${teamName}:`, error);
                }
            }
            const logoUrl = this.generateLogoUrl(teamName, league);
            this.memoryCache.set(cacheKey, logoUrl);
            this.saveToLocalStorage();
            return logoUrl;
        }
        generateLogoUrl(teamName, league) {
            const teamKey = this.normalizeTeamName(teamName, league);
            if (league === 'nba') {
                return `https://a.espncdn.com/i/teamlogos/nba/500/${teamKey}.png`;
            } else if (league === 'nfl') {
                return `https://a.espncdn.com/i/teamlogos/nfl/500/${teamKey}.png`;
            } else if (league === 'ncaaf' || league === 'college') {
                const ncaaId = this.getNCAATeamId(teamName);
                if (ncaaId) {
                    return `https://a.espncdn.com/i/teamlogos/ncaa/500/${ncaaId}.png`;
                }
                return `https://a.espncdn.com/i/teamlogos/ncaa/500/default.png`;
            } else if (league === 'nhl') {
                return `https://a.espncdn.com/i/teamlogos/nhl/500/${teamKey}.png`;
            } else if (league === 'mlb') {
                return `https://a.espncdn.com/i/teamlogos/mlb/500/${teamKey}.png`;
            } else {
                return `https://a.espncdn.com/i/teamlogos/${league}/500/${teamKey}.png`;
            }
        }
        normalizeTeamName(teamName, league) {
            const name = teamName.toLowerCase().replace(/[^a-z0-9]/g, '');
            const mappings = {
                'raiders': 'lv',
                'lasvegas': 'lv',
                'lasvegasraiders': 'lv',
                '49ers': 'sf',
                'sanfrancisco': 'sf',
                'rams': 'lar',
                'larams': 'lar',
                'chargers': 'lac',
                'lachargers': 'lac',
                'cardinals': 'ari',
                'arizona': 'ari',
                'packers': 'gb',
                'greenbay': 'gb',
                'patriots': 'ne',
                'newengland': 'ne',
                'saints': 'no',
                'neworleans': 'no',
                'buccaneers': 'tb',
                'tampabay': 'tb',
                'commanders': 'wsh',
                'washington': 'wsh'
            };
            return mappings[name] || teamName.toLowerCase().substring(0, 3);
        }
        getNCAATeamId(teamName) {
            const ncaaIds = {
                'alabama': '333',
                'georgia': '61',
                'ohiostate': '194',
                'michigan': '130',
                'texas': '251',
                'oklahoma': '201'
            };
            const normalized = teamName.toLowerCase().replace(/[^a-z]/g, '');
            return ncaaIds[normalized] || null;
        }
        async preloadLogos(picks) {
            if (this.isPreloading || !picks || picks.length === 0) {
                return;
            }
            this.isPreloading = true;
            const teams = new Set();
            for (const pick of picks) {
                const league = pick.league || pick.sport || 'nfl';
                if (pick.awayTeam) {
                    teams.add(`${league}:${pick.awayTeam}`);
                }
                if (pick.homeTeam) {
                    teams.add(`${league}:${pick.homeTeam}`);
                }
            }
            const teamArray = Array.from(teams);
            for (let i = 0; i < teamArray.length; i += this.batchSize) {
                const batch = teamArray.slice(i, i + this.batchSize);
                await Promise.all(
                    batch.map(key => {
                        const [league, team] = key.split(':');
                        return this.getTeamLogo(team, league).catch(err => {
                            console.warn(`Failed to preload logo for ${team}:`, err);
                            return '';
                        });
                    })
                );
                if (i + this.batchSize < teamArray.length) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            this.isPreloading = false;
        }
        clearCache() {
            this.memoryCache.clear();
            try {
                localStorage.removeItem(this.localStorageKey);
            } catch (error) {
                console.warn('Failed to clear localStorage cache:', error);
            }
        }
        getCacheStats() {
            return {
                memorySize: this.memoryCache.size,
                localStorageKey: this.localStorageKey,
                maxAge: this.maxCacheAge,
                maxSize: this.maxCacheSize,
                isPreloading: this.isPreloading
            };
        }
    }
    const logoCache = new LogoCache();
    window.LogoCache = logoCache;
    window.getCachedTeamLogo = logoCache.getTeamLogo;
    window.preloadTeamLogos = logoCache.preloadLogos;
    if (typeof window.getTeamLogo === 'function') {
        const originalGetTeamLogo = window.getTeamLogo;
        window.getTeamLogo = function(teamName, league) {
            return logoCache.getTeamLogo(teamName, league).catch(() => {
                return originalGetTeamLogo(teamName, league);
            });
        };
    } else {
        window.getTeamLogo = logoCache.getTeamLogo;
    }
    console.log('Logo cache initialized');
})();
(function() {
    'use strict';
    let container = null;
    function initContainer() {
        if (container) return container;
        container = document.createElement('div');
        container.id = 'notification-container';
        container.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10001;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 400px;
            pointer-events: none;
        `;
        document.body.appendChild(container);
        return container;
    }
    function showNotification(message, type = 'info', duration = 5000) {
        initContainer();
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        const colors = {
            success: { bg: 'rgba(0, 214, 137, 0.95)', icon: '✓', border: '#00ffaa' },
            error: { bg: 'rgba(229, 57, 53, 0.95)', icon: '✕', border: '#ff5f6d' },
            warning: { bg: 'rgba(251, 140, 0, 0.95)', icon: '⚠', border: '#fb8c00' },
            info: { bg: 'rgba(74, 182, 255, 0.95)', icon: 'ℹ', border: '#4ab6ff' }
        };
        const style = colors[type] || colors.info;
        notification.style.cssText = `
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 14px 18px;
            background: ${style.bg};
            border: 1px solid ${style.border};
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            color: white;
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-size: 0.95rem;
            font-weight: 500;
            line-height: 1.4;
            pointer-events: auto;
            opacity: 0;
            transform: translateX(100%);
            transition: opacity 0.3s ease, transform 0.3s ease;
        `;
        notification.innerHTML = `
            <span style="font-size: 1.2rem; line-height: 1;">${style.icon}</span>
            <span style="flex: 1;">${message}</span>
            <button onclick="this.parentElement.remove()" style="
                background: none;
                border: none;
                color: white;
                opacity: 0.7;
                cursor: pointer;
                font-size: 1.2rem;
                padding: 0;
                line-height: 1;
            " onmouseover="this.style.opacity=1" onmouseout="this.style.opacity=0.7">×</button>
        `;
        container.appendChild(notification);
        requestAnimationFrame(() => {
            notification.style.opacity = '1';
            notification.style.transform = 'translateX(0)';
        });
        if (duration > 0) {
            setTimeout(() => {
                dismissNotification(notification);
            }, duration);
        }
        return notification;
    }
    function dismissNotification(notification) {
        if (!notification) return;
        notification.style.opacity = '0';
        notification.style.transform = 'translateX(100%)';
        setTimeout(() => {
            notification.remove();
        }, 300);
    }
    function showLoading(message = 'Loading...') {
        const notification = showNotification(
            `<span class="loading-spinner"></span> ${message}`,
            'info',
            0
        );
        const style = document.createElement('style');
        style.textContent = `
            @keyframes spin {
                to { transform: rotate(360deg); }
            }
            .loading-spinner {
                display: inline-block;
                width: 14px;
                height: 14px;
                border: 2px solid rgba(255,255,255,0.3);
                border-top-color: white;
                border-radius: 50%;
                animation: spin 1s linear infinite;
                margin-right: 8px;
                vertical-align: middle;
            }
        `;
        if (!document.querySelector('style[data-loading-spinner]')) {
            style.setAttribute('data-loading-spinner', 'true');
            document.head.appendChild(style);
        }
        return {
            dismiss: () => dismissNotification(notification),
            update: (newMessage) => {
                const textSpan = notification.querySelector('span:nth-child(2)');
                if (textSpan) textSpan.innerHTML = `<span class="loading-spinner"></span> ${newMessage}`;
            }
        };
    }
    function success(message, duration) {
        return showNotification(message, 'success', duration);
    }
    function error(message, duration = 8000) {
        return showNotification(message, 'error', duration);
    }
    function warning(message, duration) {
        return showNotification(message, 'warning', duration);
    }
    function info(message, duration) {
        return showNotification(message, 'info', duration);
    }
    window.Notify = {
        show: showNotification,
        success,
        error,
        warning,
        info,
        loading: showLoading
    };
})();
(function() {
    'use strict';
    let currentDateRange = 'all'; 
    let customStartDate = null;
    let customEndDate = null;
    function initializeDateToggles() {
        const dateButtons = document.querySelectorAll('.date-toggle-btn');
        const customRangeSection = document.querySelector('.custom-date-range');
        const applyButton = document.querySelector('.date-apply-btn');
        const clearButton = document.querySelector('.date-clear-btn');
        const startDateInput = document.getElementById('date-range-start');
        const endDateInput = document.getElementById('date-range-end');
        const allTimeButton = document.querySelector('.date-toggle-btn[data-range="all"]');
        if (allTimeButton) {
            allTimeButton.classList.add('active');
        }
        dateButtons.forEach(button => {
            button.addEventListener('click', function(e) {
                e.stopPropagation();
                const range = this.getAttribute('data-range');
                handleDateRangeSelection(range, this);
            });
        });
        const customButton = document.querySelector('.date-toggle-btn[data-range="custom"]');
        if (customButton) {
            customButton.addEventListener('click', function(e) {
                e.stopPropagation();
                if (customRangeSection) {
                    const isActive = customRangeSection.classList.contains('active');
                    customRangeSection.classList.toggle('active');
                    if (!isActive && startDateInput) {
                        setTimeout(() => startDateInput.focus(), 100);
                    }
                }
            });
        }
        initializeCustomCalendar({
            container: customRangeSection,
            startInput: startDateInput,
            endInput: endDateInput
        });
        if (applyButton) {
            applyButton.addEventListener('click', function(e) {
                e.stopPropagation();
                const startDate = startDateInput?.value;
                const endDate = endDateInput?.value;
                if (startDate && endDate) {
                    customStartDate = new Date(startDate);
                    customEndDate = new Date(endDate);
                    customEndDate.setHours(23, 59, 59, 999);
                    if (customButton) {
                        const allButtons = document.querySelectorAll('.date-toggle-btn');
                        allButtons.forEach(btn => btn.classList.remove('active'));
                        customButton.classList.add('active');
                    }
                    applyDateFilter('custom');
                    if (customRangeSection) {
                        customRangeSection.classList.remove('active');
                    }
                } else {
                    if (!startDate && startDateInput) {
                        startDateInput.style.borderColor = '#FF4757';
                        setTimeout(() => startDateInput.style.borderColor = '', 2000);
                    }
                    if (!endDate && endDateInput) {
                        endDateInput.style.borderColor = '#FF4757';
                        setTimeout(() => endDateInput.style.borderColor = '', 2000);
                    }
                }
            });
        }
        if (clearButton) {
            clearButton.addEventListener('click', function(e) {
                e.stopPropagation();
                resetDateFilter();
            });
        }
        document.addEventListener('click', function(e) {
            if (customRangeSection && customRangeSection.classList.contains('active')) {
                const isClickInside = customRangeSection.contains(e.target) || 
                                     customButton?.contains(e.target);
                if (!isClickInside) {
                    customRangeSection.classList.remove('active');
                }
            }
        });
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && customRangeSection?.classList.contains('active')) {
                customRangeSection.classList.remove('active');
                customButton?.focus();
            }
        });
    }
    let calendarActiveTarget = 'start'; 
    let calendarMonthCursor = new Date(); 
    calendarMonthCursor.setDate(1);
    function formatISODate(date) {
        const y = date.getFullYear();
        const m = String(date.getMonth() + 1).padStart(2, '0');
        const d = String(date.getDate()).padStart(2, '0');
        return `${y}-${m}-${d}`;
    }
    function formatDisplayDate(date) {
        return date.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric',
            year: 'numeric'
        });
    }
    function initializeCustomCalendar(config) {
        const container = config.container;
        const startInput = config.startInput;
        const endInput = config.endInput;
        if (!container || !startInput || !endInput) return;
        const monthLabel = container.querySelector('#custom-calendar-month');
        const daysContainer = container.querySelector('#custom-calendar-days');
        const prevBtn = container.querySelector('.calendar-nav.prev');
        const nextBtn = container.querySelector('.calendar-nav.next');
        const targetButtons = container.querySelectorAll('.date-target-btn');
        const startDisplay = container.querySelector('#date-range-start-display');
        const endDisplay = container.querySelector('#date-range-end-display');
        if (!monthLabel || !daysContainer || !prevBtn || !nextBtn || !startDisplay || !endDisplay) {
            return;
        }
        function setActiveTarget(target) {
            calendarActiveTarget = target === 'end' ? 'end' : 'start';
            targetButtons.forEach(btn => {
                const isActive = btn.dataset.target === calendarActiveTarget;
                btn.classList.toggle('active', isActive);
                btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
            });
        }
        function updateDisplayFromInputs() {
            if (startInput.value) {
                const d = new Date(startInput.value);
                const isValid = !isNaN(d.getTime());
                startDisplay.textContent = isValid ? formatDisplayDate(d) : '—';
                startDisplay.classList.toggle('is-placeholder', !isValid);
            } else {
                startDisplay.textContent = '—';
                startDisplay.classList.add('is-placeholder');
            }
            if (endInput.value) {
                const d = new Date(endInput.value);
                const isValid = !isNaN(d.getTime());
                endDisplay.textContent = isValid ? formatDisplayDate(d) : '—';
                endDisplay.classList.toggle('is-placeholder', !isValid);
            } else {
                endDisplay.textContent = '—';
                endDisplay.classList.add('is-placeholder');
            }
        }
        function renderCalendar() {
            const year = calendarMonthCursor.getFullYear();
            const month = calendarMonthCursor.getMonth();
            monthLabel.textContent = calendarMonthCursor.toLocaleDateString('en-US', {
                month: 'long',
                year: 'numeric'
            });
            daysContainer.innerHTML = '';
            const firstDay = new Date(year, month, 1);
            const startWeekDay = firstDay.getDay(); 
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const startVal = startInput.value ? new Date(startInput.value) : null;
            const endVal = endInput.value ? new Date(endInput.value) : null;
            for (let i = 0; i < startWeekDay; i++) {
                const emptyCell = document.createElement('button');
                emptyCell.className = 'calendar-day empty';
                emptyCell.tabIndex = -1;
                emptyCell.setAttribute('aria-hidden', 'true');
                daysContainer.appendChild(emptyCell);
            }
            for (let day = 1; day <= daysInMonth; day++) {
                const dateObj = new Date(year, month, day);
                const iso = formatISODate(dateObj);
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'calendar-day';
                btn.textContent = String(day);
                btn.setAttribute('data-date', iso);
                btn.setAttribute('aria-label', formatDisplayDate(dateObj));
                const time = dateObj.getTime();
                const startTime = startVal ? startVal.getTime() : null;
                const endTime = endVal ? endVal.getTime() : null;
                if (startTime && time === startTime) {
                    btn.classList.add('selected', 'selected-start');
                }
                if (endTime && time === endTime) {
                    btn.classList.add('selected', 'selected-end');
                }
                if (startTime && endTime && time > startTime && time < endTime) {
                    btn.classList.add('in-range');
                }
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleDaySelection(dateObj);
                });
                daysContainer.appendChild(btn);
            }
            updateDisplayFromInputs();
        }
        function handleDaySelection(dateObj) {
            const iso = formatISODate(dateObj);
            const currentStart = startInput.value ? new Date(startInput.value) : null;
            const currentEnd = endInput.value ? new Date(endInput.value) : null;
            if (calendarActiveTarget === 'start') {
                startInput.value = iso;
                if (currentEnd && dateObj.getTime() > currentEnd.getTime()) {
                    endInput.value = iso;
                }
            } else {
                endInput.value = iso;
                if (currentStart && dateObj.getTime() < currentStart.getTime()) {
                    startInput.value = iso;
                }
            }
            renderCalendar();
        }
        targetButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const target = btn.dataset.target === 'end' ? 'end' : 'start';
                setActiveTarget(target);
            });
        });
        prevBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            calendarMonthCursor.setMonth(calendarMonthCursor.getMonth() - 1);
            renderCalendar();
        });
        nextBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            calendarMonthCursor.setMonth(calendarMonthCursor.getMonth() + 1);
            renderCalendar();
        });
        setActiveTarget('start');
        calendarMonthCursor = new Date();
        calendarMonthCursor.setDate(1);
        updateDisplayFromInputs();
        renderCalendar();
    }
    function handleDateRangeSelection(range, button) {
        if (range === 'custom') {
            return;
        }
        const allButtons = document.querySelectorAll('.date-toggle-btn');
        allButtons.forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        currentDateRange = range;
        applyDateFilter(range);
        const customRangeSection = document.querySelector('.custom-date-range');
        if (customRangeSection) {
            customRangeSection.classList.remove('active');
        }
    }
    function applyDateFilter(range) {
        const now = new Date();
        let startDate, endDate;
        switch(range) {
            case 'today':
                startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                endDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59, 999);
                break;
            case 'tomorrow':
                startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);
                endDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 23, 59, 59, 999);
                break;
            case 'week':
                const dayOfWeek = now.getDay();
                startDate = new Date(now);
                startDate.setDate(now.getDate() - dayOfWeek);
                startDate.setHours(0, 0, 0, 0);
                endDate = new Date(startDate);
                endDate.setDate(startDate.getDate() + 6);
                endDate.setHours(23, 59, 59, 999);
                break;
            case '7days':
                startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                endDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 7, 23, 59, 59, 999);
                break;
            case 'month':
                startDate = new Date(now.getFullYear(), now.getMonth(), 1);
                endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59, 999);
                break;
            case '30days':
                startDate = new Date(now);
                startDate.setDate(now.getDate() - 30);
                startDate.setHours(0, 0, 0, 0);
                endDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59, 999);
                break;
            case 'custom':
                startDate = customStartDate;
                endDate = customEndDate;
                break;
            case 'all':
            default:
                if (window.tableState && window.tableState.filters) {
                    window.tableState.filters.date = { start: null, end: null };
                    if (window.updateTableWithFilters) {
                        window.updateTableWithFilters();
                    }
                }
                updateKPIs();
                return;
        }
        if (window.tableState && window.tableState.filters) {
            window.tableState.filters.date.start = startDate;
            window.tableState.filters.date.end = endDate;
            if (window.updateTableWithFilters) {
                window.updateTableWithFilters();
            }
        }
        updateKPIs();
    }
    function updateKPIs() {
        if (typeof window.updateKPIValues === 'function') {
            window.updateKPIValues();
        } else if (typeof window.recalculateKPIs === 'function') {
            window.recalculateKPIs();
        }
    }
    function getCurrentDateRange() {
        return {
            range: currentDateRange,
            customStart: customStartDate,
            customEnd: customEndDate
        };
    }
    function resetDateFilter() {
        currentDateRange = 'all';
        customStartDate = null;
        customEndDate = null;
        const allButtons = document.querySelectorAll('.date-toggle-btn');
        allButtons.forEach(btn => btn.classList.remove('active'));
        const allTimeButton = document.querySelector('.date-toggle-btn[data-range="all"]');
        if (allTimeButton) {
            allTimeButton.classList.add('active');
        }
        const customRangeSection = document.querySelector('.custom-date-range');
        if (customRangeSection) {
            customRangeSection.classList.remove('active');
        }
        applyDateFilter('all');
    }
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeDateToggles);
    } else {
        initializeDateToggles();
    }
    window.DateToggles = {
        getCurrentDateRange,
        resetDateFilter,
        applyDateFilter
    };
})();
(function() {
    'use strict';
    let teamConfig = null;
    let teamLookup = {};
    let isLoaded = false;
    let loadPromise = null;
    const LOGO_TEMPLATES = {
        nba: 'https://a.espncdn.com/i/teamlogos/nba/500/{id}.png',
        nfl: 'https://a.espncdn.com/i/teamlogos/nfl/500/{id}.png',
        nhl: 'https://a.espncdn.com/i/teamlogos/nhl/500/{id}.png',
        ncaab: 'https://a.espncdn.com/i/teamlogos/ncaa/500/{id}.png',
        ncaaf: 'https://a.espncdn.com/i/teamlogos/ncaa/500/{id}.png',
        mlb: 'https://a.espncdn.com/i/teamlogos/mlb/500/{id}.png'
    };
    const LEAGUE_LOGOS = {
        'NBA': 'https://a.espncdn.com/i/teamlogos/leagues/500/nba.png',
        'NFL': 'https://a.espncdn.com/i/teamlogos/leagues/500/nfl.png',
        'NHL': 'https://a.espncdn.com/i/teamlogos/leagues/500/nhl.png',
        'MLB': 'https://a.espncdn.com/i/teamlogos/leagues/500/mlb.png',
        'NCAAB': 'assets/logo_ncaam_bball.png',
        'NCAAM': 'assets/logo_ncaam_bball.png',
        'NCAAF': 'assets/logo_ncaa_football.png',
        'CBB': 'assets/logo_ncaam_bball.png',
        'CFB': 'assets/logo_ncaa_football.png'
    };
    const ESPN_TEAM_IDS = {
        'atl': 'atl', 'bos': 'bos', 'bkn': 'bkn', 'cha': 'cha', 'chi': 'chi',
        'cle': 'cle', 'dal': 'dal', 'den': 'den', 'det': 'det', 'gsw': 'gs',
        'hou': 'hou', 'ind': 'ind', 'lac': 'lac', 'lal': 'lal', 'mem': 'mem',
        'mia': 'mia', 'mil': 'mil', 'min': 'min', 'nop': 'no', 'nyk': 'ny',
        'okc': 'okc', 'orl': 'orl', 'phi': 'phi', 'phx': 'phx', 'por': 'por',
        'sac': 'sac', 'sas': 'sa', 'tor': 'tor', 'uta': 'utah', 'was': 'wsh',
        'ari': 'ari', 'bal': 'bal', 'buf': 'buf', 'car': 'car', 'cin': 'cin',
        'gb': 'gb', 'hou': 'hou', 'jax': 'jax', 'kc': 'kc', 'lv': 'lv',
        'lar': 'lar', 'mia': 'mia', 'min': 'min', 'ne': 'ne', 'no': 'no',
        'nyg': 'nyg', 'nyj': 'nyj', 'pit': 'pit', 'sea': 'sea', 'sf': 'sf',
        'tb': 'tb', 'ten': 'ten', 'was': 'wsh',
        'duke': '150', 'unc': '153', 'uk': '96', 'ku': '2305', 'msu': '127',
        'iu': '84', 'cuse': '183', 'conn': '41', 'ucla': '26', 'lou': '97',
        'gonz': '2250', 'baylor': '239',
        'georgia southern': '290', 'appalachian st': '2026', 'utsa': '2636',
        'south florida': '58', 'butler': '2086', 'uconn': '41',
        'abilene christian': '2000', 'arizona': '12', 'montana st': '149',
        'cal poly': '13', 'oral roberts': '198', 'missouri st': '2623',
        'marist': '2368', 'georgia tech': '59', 'east tenn st': '2193'
    };
    async function loadConfig() {
        if (loadPromise) return loadPromise;
        if (isLoaded) return teamConfig;
        loadPromise = (async () => {
            try {
                const response = await fetch('assets/data/team-config.json');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                teamConfig = await response.json();
                buildLookupTable();
                isLoaded = true;
                console.log('[TeamData] Loaded team configuration');
                return teamConfig;
            } catch (error) {
                console.warn('[TeamData] Could not load config, using defaults:', error);
                teamConfig = getDefaultConfig();
                buildLookupTable();
                isLoaded = true;
                return teamConfig;
            }
        })();
        return loadPromise;
    }
    function buildLookupTable() {
        if (!teamConfig) return;
        teamLookup = {};
        ['nfl', 'nba', 'nhl', 'ncaab', 'ncaaf'].forEach(league => {
            const leagueData = teamConfig[league];
            if (!leagueData || !leagueData.teams) return;
            Object.entries(leagueData.teams).forEach(([abbr, team]) => {
                const entry = {
                    abbr: abbr.toUpperCase(),
                    name: team.name,
                    fullName: team.fullName,
                    city: team.city,
                    league: league.toUpperCase(),
                    logo: getTeamLogoUrl(abbr.toLowerCase(), league)
                };
                teamLookup[abbr.toLowerCase()] = entry;
                if (team.fullName) {
                    teamLookup[team.fullName.toLowerCase()] = entry;
                }
                if (team.name) {
                    teamLookup[team.name.toLowerCase()] = entry;
                }
                if (team.city && team.name) {
                    teamLookup[`${team.city} ${team.name}`.toLowerCase()] = entry;
                }
            });
        });
    }
    function getTeamLogoUrl(teamId, league) {
        const template = LOGO_TEMPLATES[league.toLowerCase()];
        if (!template) return '';
        const espnId = ESPN_TEAM_IDS[teamId.toLowerCase()] || teamId.toLowerCase();
        return template.replace('{id}', espnId);
    }
    function getDefaultConfig() {
        return {
            nfl: { teams: {} },
            nba: { teams: {} },
            nhl: { teams: {} },
            ncaab: { teams: {} },
            ncaaf: { teams: {} }
        };
    }
    function getTeamInfo(teamName, league) {
        if (!teamName) return { abbr: 'N/A', name: '', fullName: '', logo: '', league: '' };
        const key = teamName.toLowerCase().trim();
        if (teamLookup[key]) {
            return teamLookup[key];
        }
        for (const [lookupKey, team] of Object.entries(teamLookup)) {
            if (lookupKey.includes(key) || key.includes(lookupKey)) {
                return team;
            }
        }
        return {
            abbr: generateAbbreviation(teamName),
            name: teamName,
            fullName: teamName,
            logo: league ? getTeamLogoUrl(teamName.toLowerCase().replace(/\s+/g, ''), league) : '',
            league: league || ''
        };
    }
    function generateAbbreviation(name) {
        if (!name) return 'N/A';
        const words = name.trim().split(/\s+/).filter(Boolean);
        if (words.length === 1) {
            return words[0].substring(0, 3).toUpperCase();
        }
        const abbr = words.map(w => w[0]).join('').toUpperCase();
        return abbr.length >= 2 && abbr.length <= 4 ? abbr : words[0].substring(0, 3).toUpperCase();
    }
    function getTeamAbbr(teamName, league) {
        return getTeamInfo(teamName, league).abbr;
    }
    function getTeamLogo(teamName, league) {
        const info = getTeamInfo(teamName, league);
        if (info.logo) return info.logo;
        if (league) {
            const id = ESPN_TEAM_IDS[teamName.toLowerCase()] || 
                       teamName.toLowerCase().replace(/\s+/g, '').substring(0, 3);
            return getTeamLogoUrl(id, league);
        }
        return '';
    }
    function getLeagueLogo(league) {
        return LEAGUE_LOGOS[league.toUpperCase()] || '';
    }
    function parseTeamsFromGame(gameString) {
        if (!gameString) return { away: '', home: '' };
        const separators = [' @ ', ' vs ', ' vs. ', ' / ', ' v '];
        for (const sep of separators) {
            if (gameString.includes(sep)) {
                const parts = gameString.split(sep);
                return {
                    away: parts[0].trim(),
                    home: parts[1] ? parts[1].trim() : ''
                };
            }
        }
        return { away: gameString.trim(), home: '' };
    }
    function getStatusSortOrder(status) {
        const order = teamConfig?.statusSortOrder || {
            'pending': 1, 'on-track': 2, 'at-risk': 3,
            'win': 4, 'lost': 5, 'push': 6
        };
        return order[status.toLowerCase()] || 99;
    }
    function getBetTypeLabel(betType) {
        const labels = teamConfig?.betTypeLabels || {
            'spread': 'Spread', 'moneyline': 'Moneyline', 'total': 'Total',
            'parlay': 'Parlay', 'prop': 'Prop'
        };
        return labels[betType.toLowerCase()] || betType;
    }
    function getSegmentLabel(segment) {
        const labels = teamConfig?.segmentLabels || {
            'full-game': 'Full Game', '1h': '1st Half', '2h': '2nd Half',
            'fg': 'Full Game', '1q': '1st Quarter', '2q': '2nd Quarter',
            '3q': '3rd Quarter', '4q': '4th Quarter'
        };
        return labels[segment.toLowerCase()] || segment;
    }
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', loadConfig);
    } else {
        loadConfig();
    }
    window.TeamData = {
        load: loadConfig,
        getTeamInfo,
        getTeamAbbr,
        getTeamLogo,
        getLeagueLogo,
        parseTeamsFromGame,
        getStatusSortOrder,
        getBetTypeLabel,
        getSegmentLabel,
        LEAGUE_LOGOS
    };
    console.log('[TeamData] Module loaded');
})();
(function() {
    'use strict';
    function makeClickable(element, callback) {
        if (!element) return;
        if (!element.getAttribute('role')) {
            element.setAttribute('role', 'button');
        }
        if (!element.hasAttribute('tabindex')) {
            element.setAttribute('tabindex', '0');
        }
        element.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                e.stopPropagation();
                if (callback) {
                    callback.call(this, e);
                } else {
                    this.click();
                }
            }
        });
    }
    function makeAllClickable(selector, callback) {
        document.querySelectorAll(selector).forEach(el => makeClickable(el, callback));
    }
    function initParlayKeyboard() {
        document.querySelectorAll('.parlay-row[role="button"], tr[onclick*="toggleParlay"]').forEach(row => {
            makeClickable(row, function(e) {
                if (window.toggleParlay) {
                    window.toggleParlay(this);
                } else if (window.PicksParlayManager && window.PicksParlayManager.toggleParlay) {
                    const rowId = this.id || this.getAttribute('data-row-id');
                    window.PicksParlayManager.toggleParlay(rowId);
                } else {
                    this.click();
                }
            });
        });
    }
    function initKPIKeyboard() {
        document.querySelectorAll('.kpi-tile[data-action="flip-tile"], .kpi-tile[role="button"]').forEach(tile => {
            makeClickable(tile, function(e) {
                const layers = this.querySelectorAll('.kpi-tile-layer');
                if (layers.length < 2) return;
                layers.forEach(layer => layer.classList.toggle('active'));
                const isActive = this.querySelector('.kpi-tile-layer:first-child').classList.contains('active');
                this.setAttribute('aria-pressed', isActive ? 'true' : 'false');
            });
        });
    }
    function initFilterKeyboard() {
        document.querySelectorAll('.th-filter-btn').forEach(btn => {
            makeClickable(btn);
        });
        document.querySelectorAll('.filter-chip, .filter-pill, .league-chip, .ft-pill, .ft-toggle').forEach(chip => {
            makeClickable(chip);
        });
        document.querySelectorAll('.ft-dropdown-item, .ft-dropdown-menu button').forEach(item => {
            makeClickable(item);
        });
    }
    function initSortKeyboard() {
        document.querySelectorAll('.th-sort-btn, th[data-sort]').forEach(header => {
            const btn = header.classList.contains('th-sort-btn') ? header : header.querySelector('.th-sort-btn');
            if (btn) {
                makeClickable(btn);
            }
        });
    }
    function initNavKeyboard() {
        document.querySelectorAll('.nav-dropdown-trigger').forEach(trigger => {
            makeClickable(trigger);
        });
        document.querySelectorAll('.sportsbook-fetch-compact').forEach(btn => {
            makeClickable(btn);
        });
    }
    function initTrackerKeyboard() {
        document.querySelectorAll('.tracker-btn').forEach(btn => {
            if (!btn.hasAttribute('type')) {
                btn.setAttribute('type', 'button');
            }
            makeClickable(btn);
        });
    }
    function initFocusTrap(modal) {
        if (!modal) return;
        const focusableSelector = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
        const focusableElements = modal.querySelectorAll(focusableSelector);
        const firstFocusable = focusableElements[0];
        const lastFocusable = focusableElements[focusableElements.length - 1];
        modal.addEventListener('keydown', function(e) {
            if (e.key !== 'Tab') return;
            if (e.shiftKey) {
                if (document.activeElement === firstFocusable) {
                    e.preventDefault();
                    lastFocusable.focus();
                }
            } else {
                if (document.activeElement === lastFocusable) {
                    e.preventDefault();
                    firstFocusable.focus();
                }
            }
        });
    }
    function initEscapeHandler() {
        document.addEventListener('keydown', function(e) {
            if (e.key !== 'Escape') return;
            document.querySelectorAll('.th-filter-dropdown.open, .ft-dropdown-menu.open').forEach(dropdown => {
                dropdown.classList.remove('open');
                dropdown.setAttribute('hidden', '');
                const trigger = document.querySelector(`[aria-controls="${dropdown.id}"]`);
                if (trigger) {
                    trigger.setAttribute('aria-expanded', 'false');
                    trigger.focus();
                }
            });
            document.querySelectorAll('.bet-modal-overlay:not([hidden]), .modal-overlay:not([hidden])').forEach(modal => {
                modal.setAttribute('hidden', '');
                const closeBtn = modal.querySelector('.bet-modal-close, .modal-close');
                if (closeBtn) closeBtn.click();
            });
            document.querySelectorAll('.nav-dropdown-menu:not([hidden])').forEach(menu => {
                menu.setAttribute('hidden', '');
                const trigger = document.querySelector(`[aria-controls="${menu.id}"]`);
                if (trigger) {
                    trigger.setAttribute('aria-expanded', 'false');
                    trigger.focus();
                }
            });
        });
    }
    function announce(message, priority = 'polite') {
        let announcer = document.getElementById('sr-announcer');
        if (!announcer) {
            announcer = document.createElement('div');
            announcer.id = 'sr-announcer';
            announcer.setAttribute('aria-live', priority);
            announcer.setAttribute('aria-atomic', 'true');
            announcer.className = 'sr-only';
            announcer.style.cssText = 'position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0;';
            document.body.appendChild(announcer);
        }
        announcer.textContent = '';
        announcer.setAttribute('aria-live', priority);
        setTimeout(() => {
            announcer.textContent = message;
        }, 100);
    }
    function init() {
        console.log('[Accessibility] Initializing keyboard handlers...');
        initParlayKeyboard();
        initKPIKeyboard();
        initFilterKeyboard();
        initSortKeyboard();
        initNavKeyboard();
        initTrackerKeyboard();
        initEscapeHandler();
        const observer = new MutationObserver((mutations) => {
            let shouldReinit = false;
            mutations.forEach(mutation => {
                if (mutation.addedNodes.length > 0) {
                    mutation.addedNodes.forEach(node => {
                        if (node.nodeType === Node.ELEMENT_NODE) {
                            if (node.matches('.parlay-row, .kpi-tile, .tracker-btn') ||
                                node.querySelector('.parlay-row, .kpi-tile, .tracker-btn')) {
                                shouldReinit = true;
                            }
                        }
                    });
                }
            });
            if (shouldReinit) {
                initParlayKeyboard();
                initKPIKeyboard();
                initTrackerKeyboard();
            }
        });
        observer.observe(document.body, {
            childList: true,
            subtree: true
        });
        console.log('[Accessibility] Keyboard handlers initialized');
    }
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
    window.Accessibility = {
        init,
        makeClickable,
        makeAllClickable,
        initFocusTrap,
        announce,
        initParlayKeyboard,
        initKPIKeyboard,
        initFilterKeyboard
    };
})();
(function() {
    'use strict';
    const ERROR_MESSAGES = {
        network: {
            title: 'Connection Error',
            message: 'Unable to reach the server. Check your internet connection.',
            icon: '🌐'
        },
        timeout: {
            title: 'Request Timeout',
            message: 'The server took too long to respond. Please try again.',
            icon: '⏱️'
        },
        serverError: {
            title: 'Server Error',
            message: 'Something went wrong on our end. Please try again later.',
            icon: '⚠️'
        },
        notFound: {
            title: 'Not Found',
            message: 'The requested data could not be found.',
            icon: '🔍'
        },
        unauthorized: {
            title: 'Access Denied',
            message: 'You don\'t have permission to access this resource.',
            icon: '🔒'
        },
        rateLimit: {
            title: 'Too Many Requests',
            message: 'Please wait a moment before trying again.',
            icon: '⏳'
        },
        dataFetch: {
            title: 'Data Unavailable',
            message: 'Could not load the latest data. Using cached data.',
            icon: '📊'
        },
        parseError: {
            title: 'Data Error',
            message: 'Received invalid data from the server.',
            icon: '❌'
        }
    };
    const RETRY_CONFIG = {
        maxRetries: 3,
        baseDelay: 1000, 
        maxDelay: 10000, 
        backoffFactor: 2
    };
    const activeErrors = new Set();
    function classifyError(error) {
        if (error instanceof TypeError && error.message.includes('fetch')) {
            return 'network';
        }
        if (error.name === 'AbortError') {
            return 'timeout';
        }
        if (error instanceof Response) {
            const status = error.status;
            if (status === 401 || status === 403) return 'unauthorized';
            if (status === 404) return 'notFound';
            if (status === 429) return 'rateLimit';
            if (status >= 500) return 'serverError';
        }
        if (error instanceof SyntaxError) {
            return 'parseError';
        }
        return 'serverError';
    }
    function showError(errorType, options = {}) {
        const errorInfo = ERROR_MESSAGES[errorType] || ERROR_MESSAGES.serverError;
        const errorId = options.errorId || `${errorType}-${Date.now()}`;
        if (activeErrors.has(errorType) && !options.force) {
            console.log(`[APIErrorHandler] Suppressing duplicate: ${errorType}`);
            return;
        }
        activeErrors.add(errorType);
        const title = options.title || errorInfo.title;
        const message = options.message || errorInfo.message;
        const icon = options.icon || errorInfo.icon;
        if (window.showNotification) {
            window.showNotification(`${icon} ${title}: ${message}`, 'error', options.duration || 5000);
        } else if (window.NotificationsManager && window.NotificationsManager.show) {
            window.NotificationsManager.show({
                type: 'error',
                title: `${icon} ${title}`,
                message: message,
                duration: options.duration || 5000
            });
        } else {
            createToast({ icon, title, message, type: 'error', duration: options.duration || 5000 });
        }
        setTimeout(() => {
            activeErrors.delete(errorType);
        }, (options.duration || 5000) + 1000);
        console.error(`[APIErrorHandler] ${errorType}:`, message, options.context || '');
    }
    function createToast({ icon, title, message, type, duration }) {
        let container = document.getElementById('api-error-toast-container');
        if (!container) {
            container = document.createElement('div');
            container.id = 'api-error-toast-container';
            container.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                z-index: 10000;
                display: flex;
                flex-direction: column;
                gap: 10px;
                pointer-events: none;
            `;
            document.body.appendChild(container);
        }
        const toast = document.createElement('div');
        toast.className = 'api-error-toast';
        toast.style.cssText = `
            background: linear-gradient(135deg, rgba(255, 79, 94, 0.95), rgba(200, 50, 70, 0.95));
            color: white;
            padding: 16px 20px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(255, 79, 94, 0.3);
            display: flex;
            align-items: flex-start;
            gap: 12px;
            max-width: 380px;
            pointer-events: auto;
            animation: slideInRight 0.3s ease-out;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        `;
        toast.innerHTML = `
            <span style="font-size: 24px; line-height: 1;">${icon}</span>
            <div style="flex: 1;">
                <div style="font-weight: 600; margin-bottom: 4px; font-size: 14px;">${title}</div>
                <div style="font-size: 13px; opacity: 0.9; line-height: 1.4;">${message}</div>
            </div>
            <button onclick="this.parentElement.remove()" style="
                background: rgba(255,255,255,0.2);
                border: none;
                border-radius: 50%;
                width: 24px;
                height: 24px;
                color: white;
                cursor: pointer;
                font-size: 16px;
                line-height: 1;
                display: flex;
                align-items: center;
                justify-content: center;
            ">×</button>
        `;
        container.appendChild(toast);
        if (!document.getElementById('api-error-toast-styles')) {
            const style = document.createElement('style');
            style.id = 'api-error-toast-styles';
            style.textContent = `
                @keyframes slideInRight {
                    from {
                        transform: translateX(100%);
                        opacity: 0;
                    }
                    to {
                        transform: translateX(0);
                        opacity: 1;
                    }
                }
                @keyframes slideOutRight {
                    from {
                        transform: translateX(0);
                        opacity: 1;
                    }
                    to {
                        transform: translateX(100%);
                        opacity: 0;
                    }
                }
            `;
            document.head.appendChild(style);
        }
        setTimeout(() => {
            toast.style.animation = 'slideOutRight 0.3s ease-in forwards';
            setTimeout(() => toast.remove(), 300);
        }, duration);
    }
    async function handleError(error, options = {}) {
        const errorType = classifyError(error);
        if (!options.silent) {
            showError(errorType, {
                context: options.context,
                ...options.notification
            });
        }
        return {
            errorType,
            shouldRetry: options.retryable !== false && 
                         ['network', 'timeout', 'serverError'].includes(errorType),
            retryDelay: calculateRetryDelay(options.attempt || 0)
        };
    }
    function calculateRetryDelay(attempt) {
        const delay = RETRY_CONFIG.baseDelay * Math.pow(RETRY_CONFIG.backoffFactor, attempt);
        const jitter = delay * 0.2 * Math.random();
        return Math.min(delay + jitter, RETRY_CONFIG.maxDelay);
    }
    async function fetchWithRetry(url, options = {}) {
        const maxRetries = options.maxRetries ?? RETRY_CONFIG.maxRetries;
        const timeout = options.timeout ?? 10000;
        let lastError;
        for (let attempt = 0; attempt <= maxRetries; attempt++) {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), timeout);
                const response = await fetch(url, {
                    ...options,
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                if (!response.ok) {
                    throw response;
                }
                return response;
            } catch (error) {
                lastError = error;
                const { shouldRetry, retryDelay } = await handleError(error, {
                    context: options.context || url,
                    silent: attempt < maxRetries, 
                    attempt
                });
                if (!shouldRetry || attempt >= maxRetries) {
                    throw error;
                }
                console.log(`[APIErrorHandler] Retry ${attempt + 1}/${maxRetries} in ${retryDelay}ms`);
                await new Promise(r => setTimeout(r, retryDelay));
            }
        }
        throw lastError;
    }
    async function safeApiCall(apiCall, options = {}) {
        try {
            const data = await apiCall();
            return { data, error: null };
        } catch (error) {
            await handleError(error, {
                context: options.context,
                silent: options.silent
            });
            return { data: options.fallback ?? null, error };
        }
    }
    window.APIErrorHandler = {
        handleError,
        showError,
        fetchWithRetry,
        safeApiCall,
        classifyError,
        ERROR_MESSAGES
    };
    console.log('[APIErrorHandler] Module loaded');
})();
(function () {
    'use strict';
    try {
        if (typeof window === 'undefined') return;
        var isDebugEnabled = (
            window.DEBUG === true ||
            localStorage.getItem('DEBUG') === 'true' ||
            window.location.search.indexOf('debug=true') !== -1
        );
        window.DEBUG = isDebugEnabled;
        if (!isDebugEnabled && typeof console !== 'undefined') {
            var originalLog = console.log;
            var originalWarn = console.warn;
            console.log = function () {};
            console.warn = function () {
                var msg = arguments[0];
                if (typeof msg === 'string' && /^[^\w]*[🚀🔄⚠️📦📍🎯📚📊✅❌🔧📖🏈🔍⏰🚪]/.test(msg)) {
                    return;
                }
                originalWarn.apply(console, arguments);
            };
            window.__restoreConsole = function () {
                console.log = originalLog;
                console.warn = originalWarn;
                window.DEBUG = true;
            };
        }
    } catch (e) {
    }
})();
class NavigationManager {
    constructor() {
        this.dropdowns = [];
        this.navLinks = null;
        this.isInitialized = false;
        this.init();
    }
    init() {
        if (this.isInitialized) return;
        const dropdownElements = document.querySelectorAll('.nav-dropdown');
        dropdownElements.forEach(dropdown => {
            const trigger = dropdown.querySelector('.nav-dropdown-trigger');
            const menu = dropdown.querySelector('.nav-dropdown-menu');
            if (trigger && menu) {
                this.dropdowns.push({ dropdown, trigger, menu });
                this.setupDropdown(dropdown, trigger, menu);
            }
        });
        this.navLinks = document.querySelectorAll('.nav-link');
        this.setupKeyboardNavigation();
        this.setupResponsiveBehavior();
        this.setupAccessibility();
        this.setupNavState();
        this.isInitialized = true;
    }
    setupDropdown(dropdown, trigger, menu) {
        trigger.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleDropdown(dropdown, trigger, menu);
        });
        trigger.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                e.stopPropagation();
                this.toggleDropdown(dropdown, trigger, menu);
            }
        });
        document.addEventListener('click', (e) => {
            if (!dropdown.contains(e.target)) {
                this.closeDropdown(dropdown, trigger, menu);
            }
        });
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && dropdown.classList.contains('open')) {
                this.closeDropdown(dropdown, trigger, menu);
                trigger.focus();
            }
        });
        if (dropdown.querySelector('.sportsbook-card')) {
            this.setupSyncHandlers(menu);
            const addBtns = menu.querySelectorAll('.add-book-btn-compact');
            addBtns.forEach(addBtn => {
                addBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    this.handleAddSportsbook();
                });
            });
        }
    }
    setupSyncHandlers(menu) {
        const syncBtns = menu.querySelectorAll(
            '.sportsbook-fetch-btn-compact, .sportsbook-fetch-btn-sleek, .sportsbook-fetch-inline'
        );
        syncBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const card = btn.closest('.sportsbook-card');
                const sportsbookName = card.querySelector('.sportsbook-name')?.textContent || 'Sportsbook';
                this.handleSync(card, sportsbookName);
            });
        });
    }
    handleSync(card, sportsbookName) {
        card.classList.add('syncing');
        this.showNotification(`Syncing picks from ${sportsbookName}...`, 'info');
        setTimeout(() => {
            card.classList.remove('syncing');
            const syncTimeEl = card.querySelector('.sync-time');
            if (syncTimeEl) {
                syncTimeEl.textContent = 'Just now';
            }
            this.showNotification(`Successfully synced picks from ${sportsbookName}`, 'success');
        }, 2000);
    }
    handleAddSportsbook() {
        this.showNotification('Add Sportsbook feature coming soon', 'info');
    }
    showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.textContent = message;
        const accentGradient = 'linear-gradient(135deg, rgba(0, 214, 137, 0.95), rgba(60, 255, 181, 0.92))';
        const infoGradient = 'linear-gradient(135deg, rgba(6, 28, 20, 0.95), rgba(16, 58, 40, 0.92))';
        const errorGradient = 'linear-gradient(135deg, rgba(20, 20, 30, 0.95), rgba(40, 40, 50, 0.92))';
        const background = type === 'error' ? errorGradient : type === 'success' ? accentGradient : infoGradient;
        const borderColor = type === 'error' ? 'rgba(214, 40, 40, 0.5)' : 'rgba(60, 255, 181, 0.7)';
        const textColor = type === 'error' ? '#FF6B6B' : type === 'success' ? '#03150e' : '#e8f0f2';
        const glow = type === 'error'
            ? '0 18px 32px rgba(0, 0, 0, 0.5)'
            : '0 18px 32px rgba(60, 255, 181, 0.35)';
        notification.style.cssText = `
            position: fixed;
            top: 24px;
            right: 24px;
            background: ${background};
            color: ${textColor};
            padding: 14px 22px;
            border-radius: 14px;
            border: 1px solid ${borderColor};
            z-index: 999999;
            font-family: 'Cormorant Garamond', Georgia, serif;
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 0.4px;
            box-shadow: ${glow};
            backdrop-filter: blur(14px);
            text-shadow: ${type === 'error' ? 'none' : '0 1px 1px rgba(0, 0, 0, 0.15)'};
            animation: slideIn 0.3s ease-out;
        `;
        document.body.appendChild(notification);
        setTimeout(() => {
            notification.style.animation = 'slideOut 0.3s ease-in forwards';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }
    toggleDropdown(dropdown, trigger, menu) {
        const willOpen = !dropdown.classList.contains('open');
        this.dropdowns.forEach(({ dropdown: otherDropdown, trigger: otherTrigger, menu: otherMenu }) => {
            if (otherDropdown !== dropdown && otherDropdown.classList.contains('open')) {
                this.closeDropdown(otherDropdown, otherTrigger, otherMenu);
            }
        });
        dropdown.classList.toggle('open', willOpen);
        trigger.setAttribute('aria-expanded', willOpen);
        if (menu) {
            if (willOpen) {
                menu.removeAttribute('hidden');
                menu.offsetHeight; 
            } else {
                setTimeout(() => {
                    if (!dropdown.classList.contains('open')) {
                        menu.setAttribute('hidden', '');
                    }
                }, 200);
            }
        }
    }
    closeDropdown(dropdown, trigger, menu) {
        dropdown.classList.remove('open');
        trigger.setAttribute('aria-expanded', 'false');
        if (menu) {
            setTimeout(() => {
                if (!dropdown.classList.contains('open')) {
                    menu.setAttribute('hidden', '');
                }
            }, 200);
        }
    }
    closeAllDropdowns() {
        this.dropdowns.forEach(({ dropdown, trigger, menu }) => {
            this.closeDropdown(dropdown, trigger, menu);
        });
    }
    setupKeyboardNavigation() {
        this.navLinks.forEach(link => {
            link.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    link.click();
                }
            });
        });
    }
    setupResponsiveBehavior() {
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                this.handleResize();
            }, 100);
        });
    }
    handleResize() {
        if (window.innerWidth <= 768) {
            this.closeAllDropdowns();
        }
    }
    setupAccessibility() {
        this.dropdowns.forEach(({ dropdown, trigger, menu }) => {
            if (trigger) {
                trigger.setAttribute('aria-expanded', 'false');
                trigger.setAttribute('aria-haspopup', 'true');
                const menuId = menu?.getAttribute('id');
                if (menuId) {
                    trigger.setAttribute('aria-controls', menuId);
                }
            }
            if (menu) {
                menu.setAttribute('role', 'menu');
                const triggerId = trigger?.getAttribute('id');
                if (triggerId) {
                    menu.setAttribute('aria-labelledby', triggerId);
                }
            }
        });
        this.setupScreenReaderSupport();
    }
    setupScreenReaderSupport() {
        let liveRegion = document.getElementById('navigation-live-region');
        if (!liveRegion) {
            liveRegion = document.createElement('div');
            liveRegion.id = 'navigation-live-region';
            liveRegion.setAttribute('aria-live', 'polite');
            liveRegion.setAttribute('aria-atomic', 'true');
            liveRegion.className = 'sr-only';
            document.body.appendChild(liveRegion);
        }
        this.liveRegion = liveRegion;
    }
    openDropdown(dropdown, trigger, menu) {
        if (!dropdown.classList.contains('open')) {
            this.toggleDropdown(dropdown, trigger, menu);
        }
    }
    setupNavState() {
        try {
            const links = document.querySelectorAll('.nav-link');
            const path = (location.pathname.split('/').pop() || '').toLowerCase();
            links.forEach(link => {
                const href = (link.getAttribute('href') || '').toLowerCase();
                const isDisabled = link.getAttribute('aria-disabled') === 'true';
                if (isDisabled) {
                    link.classList.remove('active');
                    link.removeAttribute('aria-current');
                    return;
                }
                const isActive =
                    !!href &&
                    (
                        href === path ||                      
                        (href.endsWith('.html') && path === '') 
                    );
                link.classList.toggle('active', isActive);
                if (isActive) {
                    link.setAttribute('aria-current', 'page');
                } else {
                    link.removeAttribute('aria-current');
                }
            });
        } catch (e) {
        }
    }
    destroy() {
        this.isInitialized = false;
    }
}
const styleSheet = document.createElement('style');
styleSheet.textContent = `
    @keyframes slideIn {
        from {
            opacity: 0;
            transform: translateX(20px);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }
    @keyframes slideOut {
        from {
            opacity: 1;
            transform: translateX(0);
        }
        to {
            opacity: 0;
            transform: translateX(20px);
        }
    }
    .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
    }
`;
document.head.appendChild(styleSheet);
class BackToTopButton {
    constructor() {
        this.button = document.getElementById('back-to-top');
        this.scrollThreshold = 200; 
        if (this.button) {
            this.init();
        }
    }
    init() {
        let ticking = false;
        window.addEventListener('scroll', () => {
            if (!ticking) {
                window.requestAnimationFrame(() => {
                    this.handleScroll();
                    ticking = false;
                });
                ticking = true;
            }
        });
        this.button.addEventListener('click', () => {
            this.scrollToTop();
        });
        this.handleScroll();
    }
    handleScroll() {
        if (window.scrollY > this.scrollThreshold) {
            this.button.classList.add('visible');
        } else {
            this.button.classList.remove('visible');
        }
    }
    scrollToTop() {
        window.scrollTo({
            top: 0,
            behavior: 'smooth'
        });
    }
}
document.addEventListener('DOMContentLoaded', () => {
    window.navigationManager = new NavigationManager();
    window.backToTopButton = new BackToTopButton();
});
if (typeof module !== 'undefined' && module.exports) {
    module.exports = NavigationManager;
}
(function() {
    'use strict';
    if (typeof window.tableState === 'undefined') {
        window.tableState = {
            filters: {
                date: {
                    start: null,
                    end: null,
                    selectedDates: null,
                    selectedTimes: null,
                    selectedBooks: null
                },
                matchup: {
                    league: '',
                    selectedTeams: null,
                    ticketType: 'all'
                },
                pick: {
                    betType: '',
                    subtype: '',
                    segment: ''
                },
                risk: {
                    min: null,
                    max: null,
                    selectedRiskRanges: [],
                    selectedWinRanges: []
                },
                status: []
            },
            sort: {
                column: null,
                direction: 'asc'
            },
            expandedParlayIds: []
        };
    }
    const StateShapeValidators = {
        createDateFilterState() {
            return {
                start: null,
                end: null,
                selectedDates: null,
                selectedTimes: null,
                selectedBooks: null
            };
        },
        createMatchupFilterState() {
            return {
                league: '',
                selectedTeams: null,
                ticketType: 'all'
            };
        },
        createRiskFilterState() {
            return {
                min: null,
                max: null,
                selectedRiskRanges: [],
                selectedWinRanges: []
            };
        },
        createPickFilterState() {
            return {
                betType: '',
                subtype: '',
                segment: ''
            };
        },
        ensureDateFilterShape() {
            const state = window.tableState;
            if (!state.filters.date || typeof state.filters.date !== 'object') {
                state.filters.date = this.createDateFilterState();
                return;
            }
            const dateFilter = state.filters.date;
            if (!('start' in dateFilter)) dateFilter.start = null;
            if (!('end' in dateFilter)) dateFilter.end = null;
            if (!('selectedDates' in dateFilter)) dateFilter.selectedDates = null;
            if (!('selectedTimes' in dateFilter)) dateFilter.selectedTimes = null;
            if (!('selectedBooks' in dateFilter)) dateFilter.selectedBooks = null;
        },
        ensureMatchupFilterShape() {
            const state = window.tableState;
            if (!state.filters.matchup || typeof state.filters.matchup !== 'object') {
                state.filters.matchup = this.createMatchupFilterState();
                return;
            }
            const matchupFilter = state.filters.matchup;
            if (!('ticketType' in matchupFilter)) matchupFilter.ticketType = 'all';
            if (!('selectedTeams' in matchupFilter)) matchupFilter.selectedTeams = null;
            if (!('league' in matchupFilter)) matchupFilter.league = '';
        },
        ensureRiskFilterShape() {
            const state = window.tableState;
            if (!state.filters.risk || typeof state.filters.risk !== 'object') {
                state.filters.risk = this.createRiskFilterState();
                return;
            }
            const riskFilter = state.filters.risk;
            if (!('min' in riskFilter)) riskFilter.min = null;
            if (!('max' in riskFilter)) riskFilter.max = null;
            if (!Array.isArray(riskFilter.selectedRiskRanges)) riskFilter.selectedRiskRanges = [];
            if (!Array.isArray(riskFilter.selectedWinRanges)) riskFilter.selectedWinRanges = [];
        },
        ensurePickFilterShape() {
            const state = window.tableState;
            if (!state.filters.pick) {
                state.filters.pick = this.createPickFilterState();
            }
        },
        ensureAllFilterShapes() {
            this.ensureDateFilterShape();
            this.ensureMatchupFilterShape();
            this.ensureRiskFilterShape();
            this.ensurePickFilterShape();
        }
    };
    const StateManager = {
        getState() {
            return window.tableState;
        },
        getFilter(filterType) {
            return window.tableState.filters[filterType];
        },
        updateFilter(filterType, updates) {
            if (!window.tableState.filters[filterType]) {
                console.warn(`Filter type ${filterType} does not exist`);
                return;
            }
            Object.assign(window.tableState.filters[filterType], updates);
        },
        resetFilter(filterType) {
            switch(filterType) {
                case 'date':
                    window.tableState.filters.date = StateShapeValidators.createDateFilterState();
                    break;
                case 'matchup':
                    window.tableState.filters.matchup = StateShapeValidators.createMatchupFilterState();
                    break;
                case 'pick':
                    window.tableState.filters.pick = StateShapeValidators.createPickFilterState();
                    break;
                case 'risk':
                    window.tableState.filters.risk = StateShapeValidators.createRiskFilterState();
                    break;
                case 'status':
                    window.tableState.filters.status = [];
                    break;
                default:
                    console.warn(`Unknown filter type: ${filterType}`);
            }
        },
        resetAllFilters() {
            window.tableState.filters = {
                date: StateShapeValidators.createDateFilterState(),
                matchup: StateShapeValidators.createMatchupFilterState(),
                pick: StateShapeValidators.createPickFilterState(),
                risk: StateShapeValidators.createRiskFilterState(),
                status: []
            };
        },
        getExpandedParlayIds() {
            if (!Array.isArray(window.tableState.expandedParlayIds)) {
                window.tableState.expandedParlayIds = [];
            }
            return window.tableState.expandedParlayIds;
        },
        setParlayExpanded(parlayId, isExpanded) {
            if (!parlayId) return;
            if (!Array.isArray(window.tableState.expandedParlayIds)) {
                window.tableState.expandedParlayIds = [];
            }
            const index = window.tableState.expandedParlayIds.indexOf(parlayId);
            if (isExpanded && index === -1) {
                window.tableState.expandedParlayIds.push(parlayId);
            } else if (!isExpanded && index !== -1) {
                window.tableState.expandedParlayIds.splice(index, 1);
            }
        },
        isParlayExpanded(parlayId) {
            if (!parlayId || !Array.isArray(window.tableState.expandedParlayIds)) {
                return false;
            }
            return window.tableState.expandedParlayIds.includes(parlayId);
        },
        toggleParlayExpanded(parlayId) {
            const isCurrentlyExpanded = this.isParlayExpanded(parlayId);
            this.setParlayExpanded(parlayId, !isCurrentlyExpanded);
            return !isCurrentlyExpanded;
        },
        resetExpansionState() {
            window.tableState.expandedParlayIds = [];
        },
        getSortState() {
            return window.tableState.sort;
        },
        updateSort(column, direction) {
            window.tableState.sort = {
                column: column,
                direction: direction || 'asc'
            };
        },
        resetSort() {
            window.tableState.sort = {
                column: null,
                direction: 'asc'
            };
        },
        hasActiveFilters() {
            const filters = window.tableState.filters;
            if (filters.date.selectedDates || filters.date.selectedTimes || filters.date.selectedBooks ||
                filters.date.start || filters.date.end) {
                return true;
            }
            if (filters.matchup.league || filters.matchup.selectedTeams ||
                filters.matchup.ticketType !== 'all') {
                return true;
            }
            if (filters.pick.betType || filters.pick.subtype || filters.pick.segment) {
                return true;
            }
            if (filters.risk.min !== null || filters.risk.max !== null ||
                filters.risk.selectedRiskRanges.length > 0 ||
                filters.risk.selectedWinRanges.length > 0) {
                return true;
            }
            if (filters.status.length > 0) {
                return true;
            }
            return false;
        },
        getActiveFilterCount() {
            let count = 0;
            const filters = window.tableState.filters;
            if (filters.date.selectedDates) count++;
            if (filters.date.selectedTimes) count++;
            if (filters.date.selectedBooks) count++;
            if (filters.matchup.league || filters.matchup.selectedTeams) count++;
            if (filters.pick.betType || filters.pick.subtype) count++;
            if (filters.pick.segment) count++;
            if (filters.risk.selectedRiskRanges.length > 0) count++;
            if (filters.risk.selectedWinRanges.length > 0) count++;
            if (filters.status.length > 0) count++;
            return count;
        },
        init() {
            StateShapeValidators.ensureAllFilterShapes();
            if (!Array.isArray(window.tableState.expandedParlayIds)) {
                window.tableState.expandedParlayIds = [];
            }
        }
    };
    window.PicksStateManager = {
        ...StateManager,
        validators: StateShapeValidators,
        state: window.tableState
    };
    StateManager.init();
})();
(function() {
    'use strict';
    const DataProcessor = {
        collectDateFilterFacets() {
            const tbody = document.getElementById('picks-tbody');
            if (!tbody) return { dates: new Set(), times: new Set(), books: new Set() };
            const facets = {
                dates: new Set(),
                times: new Set(),
                books: new Set()
            };
            const rows = tbody.querySelectorAll('tr:not(.parlay-legs)');
            rows.forEach(row => {
                const dateCell = row.querySelector('td:first-child');
                if (!dateCell) return;
                const dateEl = dateCell.querySelector('.cell-date');
                if (dateEl) {
                    const dateText = dateEl.textContent.trim();
                    if (dateText) {
                        const weekday = window.PicksDOMUtils ?
                            window.PicksDOMUtils.getWeekdayName(dateText) : '';
                        const fullDate = weekday ? `${weekday} ${dateText}` : dateText;
                        facets.dates.add(fullDate);
                    }
                }
                const timeEl = dateCell.querySelector('.cell-time');
                if (timeEl) {
                    const timeText = timeEl.textContent.trim();
                    if (timeText) {
                        facets.times.add(timeText);
                    }
                }
                const bookEl = dateCell.querySelector('.cell-book, .sportsbook-name');
                if (bookEl) {
                    const bookText = bookEl.textContent.trim();
                    if (bookText) {
                        facets.books.add(bookText);
                    }
                }
            });
            return {
                dates: Array.from(facets.dates).sort(),
                times: Array.from(facets.times).sort((a, b) => {
                    const timeA = this.parseTimeValue(a);
                    const timeB = this.parseTimeValue(b);
                    return timeA - timeB;
                }),
                books: Array.from(facets.books).sort()
            };
        },
        parseTimeValue(timeText) {
            const match = timeText.match(/(\d{1,2}):(\d{2})\s*(am|pm)?/i);
            if (!match) return 0;
            let hours = parseInt(match[1], 10);
            const minutes = parseInt(match[2], 10);
            const period = match[3] ? match[3].toLowerCase() : '';
            if (period === 'pm' && hours !== 12) {
                hours += 12;
            } else if (period === 'am' && hours === 12) {
                hours = 0;
            }
            return hours * 60 + minutes;
        },
        getLeaguesFromTable() {
            const tbody = document.getElementById('picks-tbody');
            if (!tbody) return [];
            const leagues = new Set();
            const rows = tbody.querySelectorAll('tr:not(.parlay-legs)');
            rows.forEach(row => {
                const matchupCell = row.querySelector('td:nth-child(2)');
                if (matchupCell) {
                    const league = this.detectLeagueFromCell(matchupCell);
                    if (league) {
                        leagues.add(league.toUpperCase());
                    }
                }
            });
            return Array.from(leagues).sort();
        },
        detectLeagueFromCell(cell) {
            if (!cell) return '';
            const text = cell.textContent.toLowerCase();
            const leaguePatterns = {
                'nfl': /(?:patriots|cowboys|packers|chiefs|bills|dolphins|jets|ravens|bengals|browns|steelers|texans|colts|jaguars|titans|broncos|chargers|raiders|eagles|giants|commanders|bears|lions|vikings|falcons|panthers|saints|buccaneers|cardinals|rams|49ers|seahawks)/,
                'nba': /(?:celtics|nets|knicks|76ers|raptors|bulls|cavaliers|pistons|pacers|bucks|hawks|heat|magic|wizards|hornets|nuggets|timberwolves|thunder|blazers|jazz|warriors|clippers|lakers|suns|kings|mavericks|rockets|grizzlies|pelicans|spurs)/,
                'mlb': /(?:orioles|red sox|yankees|rays|blue jays|white sox|guardians|tigers|royals|twins|astros|athletics|angels|mariners|rangers|braves|marlins|mets|phillies|nationals|brewers|cubs|reds|pirates|cardinals|diamondbacks|rockies|dodgers|padres|giants)/,
                'nhl': /(?:bruins|sabres|red wings|panthers|canadiens|senators|lightning|maple leafs|hurricanes|blue jackets|devils|islanders|rangers|flyers|penguins|capitals|blackhawks|avalanche|stars|wild|predators|blues|jets|ducks|coyotes|flames|oilers|kings|sharks|kraken|canucks|golden knights)/,
                'ncaa': /(?:alabama|georgia|michigan|ohio state|clemson|lsu|oklahoma|texas|florida|usc|notre dame|penn state|tennessee|auburn|wisconsin|oregon|washington|miami|florida state|nebraska)/,
                'soccer': /(?:manchester|liverpool|chelsea|arsenal|barcelona|real madrid|bayern|juventus|psg|milan|inter|atletico|dortmund|ajax|benfica|porto|celtic|rangers)/
            };
            for (const [league, pattern] of Object.entries(leaguePatterns)) {
                if (pattern.test(text)) {
                    return league;
                }
            }
            return '';
        },
        getTeamsForLeague(league) {
            const tbody = document.getElementById('picks-tbody');
            if (!tbody || !league) return [];
            const teams = new Set();
            const rows = tbody.querySelectorAll('tr:not(.parlay-legs)');
            rows.forEach(row => {
                const matchupCell = row.querySelector('td:nth-child(2)');
                if (matchupCell) {
                    const cellLeague = this.detectLeagueFromCell(matchupCell);
                    if (cellLeague.toUpperCase() === league.toUpperCase()) {
                        const extractedTeams = this.extractTeamsFromCell(matchupCell);
                        extractedTeams.forEach(team => teams.add(team));
                    }
                }
            });
            return Array.from(teams).sort();
        },
        extractTeamsFromCell(cell) {
            if (!cell) return [];
            const teams = [];
            const logos = cell.querySelectorAll('.team-logo');
            if (logos.length > 0) {
                logos.forEach(logo => {
                    const name = logo.getAttribute('alt') ||
                                logo.getAttribute('title') ||
                                '';
                    if (name) teams.push(name);
                });
            }
            if (teams.length === 0) {
                const text = cell.textContent;
                const parts = text.split(/\s+(?:vs?\.?|@|at)\s+/i);
                parts.forEach(part => {
                    const cleaned = part.trim();
                    if (cleaned && cleaned.length > 2) {
                        teams.push(cleaned);
                    }
                });
            }
            return teams;
        },
        getGameDayFromRow(row) {
            const dateCell = row.querySelector('td:first-child');
            if (!dateCell) return null;
            const dateEl = dateCell.querySelector('.cell-date');
            if (!dateEl) return null;
            const dateText = dateEl.textContent.trim();
            if (!dateText) return null;
            const match = dateText.match(/(\d{1,2})\/(\d{1,2})/);
            if (!match) return null;
            const month = parseInt(match[1], 10);
            const day = parseInt(match[2], 10);
            const year = new Date().getFullYear();
            return new Date(year, month - 1, day);
        },
        collectStatusValues() {
            const tbody = document.getElementById('picks-tbody');
            if (!tbody) return [];
            const statuses = new Set();
            const rows = tbody.querySelectorAll('tr:not(.parlay-legs)');
            rows.forEach(row => {
                const statusCell = row.querySelector('td:last-child');
                if (statusCell) {
                    const badge = statusCell.querySelector('.status-badge');
                    if (badge) {
                        const status = badge.getAttribute('data-status') ||
                                      badge.className.match(/status-(\w+)/)?.[1] ||
                                      badge.textContent.trim();
                        if (status) {
                            statuses.add(status.toLowerCase());
                        }
                    }
                }
            });
            return Array.from(statuses).sort();
        },
        collectValueRanges(columnIndex) {
            const tbody = document.getElementById('picks-tbody');
            if (!tbody) return [];
            const values = [];
            const rows = tbody.querySelectorAll('tr:not(.parlay-legs)');
            rows.forEach(row => {
                const cell = row.querySelector(`td:nth-child(${columnIndex})`);
                if (cell) {
                    const text = cell.textContent.replace(/[$,]/g, '').trim();
                    const value = parseFloat(text);
                    if (!isNaN(value)) {
                        values.push(value);
                    }
                }
            });
            return this.createValueRanges(values);
        },
        createValueRanges(values) {
            if (!values || values.length === 0) return [];
            const sorted = values.sort((a, b) => a - b);
            const min = sorted[0];
            const max = sorted[sorted.length - 1];
            const ranges = [];
            if (max <= 100) {
                ranges.push('0-25', '25-50', '50-75', '75-100');
            } else if (max <= 500) {
                ranges.push('0-50', '50-100', '100-250', '250-500');
            } else if (max <= 1000) {
                ranges.push('0-100', '100-250', '250-500', '500-1000');
            } else {
                ranges.push('0-100', '100-500', '500-1000', '1000-5000', '5000+');
            }
            return ranges.filter(range => {
                const [rangeMin, rangeMax] = range.includes('+') ?
                    [parseFloat(range), Infinity] :
                    range.split('-').map(parseFloat);
                return values.some(v => v >= rangeMin && v <= rangeMax);
            });
        },
        calculateKPIsFromVisibleRows() {
            const tbody = document.getElementById('picks-tbody');
            if (!tbody) return this.getEmptyKPIs();
            const visibleRows = Array.from(tbody.querySelectorAll('tr:not(.parlay-legs)'))
                .filter(row => row.style.display !== 'none');
            let totalRisk = 0;
            let totalWin = 0;
            let wins = 0;
            let losses = 0;
            let pushes = 0;
            let pending = 0;
            let live = 0;
            visibleRows.forEach(row => {
                const riskCell = row.querySelector('td:nth-child(4)');
                if (riskCell) {
                    const risk = parseFloat(riskCell.textContent.replace(/[$,]/g, '')) || 0;
                    totalRisk += risk;
                }
                const winCell = row.querySelector('td:nth-child(5)');
                if (winCell) {
                    const win = parseFloat(winCell.textContent.replace(/[$,]/g, '')) || 0;
                    totalWin += win;
                }
                const statusCell = row.querySelector('td:last-child');
                if (statusCell) {
                    const badge = statusCell.querySelector('.status-badge');
                    const statusText = badge ?
                        (badge.getAttribute('data-status') || badge.textContent.trim()) :
                        statusCell.textContent.trim();
                    const normalized = window.PicksDOMUtils && window.PicksDOMUtils.normalizeStatus ?
                        window.PicksDOMUtils.normalizeStatus(statusText) :
                        statusText.toLowerCase();
                    if (normalized === 'win' || normalized.includes('win') || normalized === 'won') wins++;
                    else if (normalized === 'loss' || normalized.includes('loss') || normalized === 'lost') losses++;
                    else if (normalized === 'push' || normalized.includes('push')) pushes++;
                    else if (normalized === 'live' || normalized.includes('live') || normalized.includes('active')) live++;
                    else if (normalized === 'pending' || normalized.includes('pending') || normalized === 'open') pending++;
                }
            });
            const totalBets = visibleRows.length;
            const settledBets = wins + losses + pushes;
            const winRate = settledBets > 0 ? (wins / settledBets * 100).toFixed(1) : 0;
            const roi = totalRisk > 0 ? ((totalWin - totalRisk) / totalRisk * 100).toFixed(1) : 0;
            return {
                totalBets,
                totalRisk,
                totalWin,
                profit: totalWin - totalRisk,
                roi,
                winRate,
                wins,
                losses,
                pushes,
                pending,
                live,
                settled: settledBets
            };
        },
        getEmptyKPIs() {
            return {
                totalBets: 0,
                totalRisk: 0,
                totalWin: 0,
                profit: 0,
                roi: 0,
                winRate: 0,
                wins: 0,
                losses: 0,
                pushes: 0,
                pending: 0,
                live: 0,
                settled: 0
            };
        },
        collectBetTypes() {
            const tbody = document.getElementById('picks-tbody');
            if (!tbody) return { types: [], subtypes: [] };
            const types = new Set();
            const subtypes = new Set();
            const rows = tbody.querySelectorAll('tr:not(.parlay-legs)');
            rows.forEach(row => {
                const pickCell = row.querySelector('td:nth-child(3)');
                if (pickCell) {
                    const detected = this.detectBetTypeFromCell(pickCell);
                    if (detected.type) types.add(detected.type);
                    if (detected.subtype) subtypes.add(detected.subtype);
                }
            });
            return {
                types: Array.from(types).sort(),
                subtypes: Array.from(subtypes).sort()
            };
        },
        detectBetTypeFromCell(cell) {
            if (!cell) return { type: '', subtype: '' };
            const text = (cell.textContent || '').toLowerCase();
            const betTypeEl = cell.querySelector('[data-bet-type]');
            if (betTypeEl) {
                return {
                    type: betTypeEl.getAttribute('data-bet-type') || '',
                    subtype: betTypeEl.getAttribute('data-bet-subtype') || ''
                };
            }
            if (text.includes('spread') || /[+-]\d+\.?\d*/.test(text)) {
                return { type: 'spread', subtype: this.detectSegmentFromText(text) };
            }
            if (text.includes('total') || text.includes('over') || text.includes('under')) {
                return { type: 'total', subtype: this.detectSegmentFromText(text) };
            }
            if (text.includes('moneyline') || text.includes(' ml ')) {
                return { type: 'moneyline', subtype: this.detectSegmentFromText(text) };
            }
            if (text.includes('parlay')) {
                return { type: 'parlay', subtype: '' };
            }
            if (text.includes('prop') || text.includes('player')) {
                return { type: 'prop', subtype: '' };
            }
            return { type: '', subtype: '' };
        },
        detectSegmentFromText(text) {
            const lower = text.toLowerCase();
            if (lower.includes('1st') || lower.includes('first') ||
                lower.includes('1h') || lower.includes('1q')) {
                return '1h';
            }
            if (lower.includes('2nd') || lower.includes('second') ||
                lower.includes('2h') || lower.includes('3q') || lower.includes('4q')) {
                return '2h';
            }
            return 'game';
        }
    };
    window.PicksDataProcessor = DataProcessor;
})();
(function() {
    'use strict';
    const DOMUtils = {
        escapeHtml(value) {
            if (!value) return '';
            const div = document.createElement('div');
            div.textContent = value;
            return div.innerHTML;
        },
        formatCurrency(value) {
            if (value == null || isNaN(value)) return '-';
            const num = parseFloat(value);
            const formatted = new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
            }).format(Math.abs(num));
            return num < 0 ? `(${formatted})` : formatted;
        },
        formatCurrencyForChip(value) {
            if (!value) return '';
            const num = parseFloat(value);
            if (num >= 1000) {
                return `$${(num / 1000).toFixed(1)}k`;
            }
            return `$${num}`;
        },
        formatDateWithDay(dateText) {
            if (!dateText) return '';
            if (/^(mon|tue|wed|thu|fri|sat|sun)\s+/i.test(dateText)) {
                return dateText;
            }
            const weekday = this.getWeekdayName(dateText);
            return weekday ? `${weekday} ${dateText}` : dateText;
        },
        getWeekdayName(dateText) {
            if (!dateText) return '';
            const match = dateText.match(/(\d{1,2})\/(\d{1,2})/);
            if (!match) return '';
            const month = parseInt(match[1], 10) - 1;
            const day = parseInt(match[2], 10);
            const year = new Date().getFullYear();
            const date = new Date(year, month, day);
            const weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            return weekdays[date.getDay()];
        },
        normalizeStatus(status) {
            if (!status) return 'pending';
            const lower = status.toString().toLowerCase().trim();
            const statusMap = {
                'win': 'win',
                'won': 'win',
                'winner': 'win',
                'loss': 'loss',
                'lost': 'loss',
                'lose': 'loss',
                'loser': 'loss',
                'push': 'push',
                'tie': 'push',
                'void': 'void',
                'voided': 'void',
                'cancelled': 'void',
                'pending': 'pending',
                'open': 'pending',
                'live': 'live',
                'active': 'live',
                'in-progress': 'live',
                'in progress': 'live'
            };
            return statusMap[lower] || 'pending';
        },
        formatBadgeStatus(status) {
            if (!status) return '';
            const normalized = this.normalizeStatus(status);
            return normalized.toUpperCase();
        },
        formatTeamRecordValue(value) {
            if (!value) return '';
            return value.toString().replace(/[^\d-]/g, '');
        },
        formatBetTypeLabel(type) {
            if (!type) return '';
            const typeMap = {
                'spread': 'Spread',
                'total': 'Total',
                'moneyline': 'Moneyline',
                'ml': 'Moneyline',
                'parlay': 'Parlay',
                'prop': 'Prop',
                'player': 'Player Prop'
            };
            return typeMap[type.toLowerCase()] || type;
        },
        formatSubtypeLabel(subtype) {
            if (!subtype) return '';
            const subtypeMap = {
                '1h': '1st Half',
                '2h': '2nd Half',
                '1q': '1st Quarter',
                '2q': '2nd Quarter',
                '3q': '3rd Quarter',
                '4q': '4th Quarter',
                'game': 'Full Game',
                'full': 'Full Game'
            };
            return subtypeMap[subtype.toLowerCase()] || subtype;
        },
        formatSegmentLabel(segment) {
            if (!segment) return '';
            const segmentMap = {
                '1h': '1st Half',
                '2h': '2nd Half',
                'game': 'Full Game',
                'full': 'Full Game',
                'live': 'Live',
                'pregame': 'Pre-Game'
            };
            return segmentMap[segment.toLowerCase()] || segment;
        },
        createElement(tag, attributes = {}, children = []) {
            const element = document.createElement(tag);
            Object.entries(attributes).forEach(([key, value]) => {
                if (key === 'className') {
                    element.className = value;
                } else if (key === 'innerHTML') {
                    element.innerHTML = value;
                } else if (key === 'textContent') {
                    element.textContent = value;
                } else if (key.startsWith('data-')) {
                    element.setAttribute(key, value);
                } else {
                    element[key] = value;
                }
            });
            children.forEach(child => {
                if (typeof child === 'string') {
                    element.appendChild(document.createTextNode(child));
                } else if (child instanceof Element) {
                    element.appendChild(child);
                }
            });
            return element;
        },
        positionDropdown(button, dropdown) {
            if (!button || !dropdown) return;
            const btnRect = button.getBoundingClientRect();
            const dropdownHeight = dropdown.offsetHeight;
            const viewportHeight = window.innerHeight;
            dropdown.style.position = 'absolute';
            dropdown.style.left = `${btnRect.left}px`;
            if (btnRect.bottom + dropdownHeight > viewportHeight && btnRect.top > dropdownHeight) {
                dropdown.style.top = `${btnRect.top - dropdownHeight}px`;
                dropdown.classList.add('dropdown-above');
            } else {
                dropdown.style.top = `${btnRect.bottom}px`;
                dropdown.classList.remove('dropdown-above');
            }
            const dropdownRect = dropdown.getBoundingClientRect();
            if (dropdownRect.right > window.innerWidth) {
                dropdown.style.left = `${window.innerWidth - dropdown.offsetWidth - 10}px`;
            }
        },
        closeAllDropdowns() {
            document.querySelectorAll('.filter-dropdown.show').forEach(dropdown => {
                dropdown.classList.remove('show');
                const btnId = dropdown.getAttribute('aria-labelledby');
                if (btnId) {
                    const btn = document.getElementById(btnId);
                    if (btn) {
                        btn.setAttribute('aria-expanded', 'false');
                    }
                }
            });
        },
        extractAbbreviation(name) {
            if (!name) return '';
            const cleaned = name
                .replace(/(fc|united|city|town|athletic|rovers)$/i, '')
                .trim();
            const words = cleaned.split(/\s+/);
            if (words.length === 1) {
                return words[0].substring(0, 3).toUpperCase();
            } else {
                return words
                    .map(w => w.charAt(0))
                    .join('')
                    .substring(0, 3)
                    .toUpperCase();
            }
        },
        formatTeamName(name) {
            if (!name) return '';
            return name.replace(/\w\S*/g, txt =>
                txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()
            );
        },
        debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        },
        throttle(func, limit) {
            let inThrottle;
            return function(...args) {
                if (!inThrottle) {
                    func.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
        },
        isElementVisible(element) {
            if (!element) return false;
            const rect = element.getBoundingClientRect();
            return (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        },
        scrollIntoViewSmoothly(element, options = {}) {
            if (!element) return;
            const defaultOptions = {
                behavior: 'smooth',
                block: 'center',
                inline: 'nearest'
            };
            element.scrollIntoView({ ...defaultOptions, ...options });
        },
        getTextContent(element, selector) {
            if (!element) return '';
            if (selector) {
                const child = element.querySelector(selector);
                return child ? child.textContent.trim() : '';
            }
            return element.textContent.trim();
        },
        setLoadingState(element, isLoading, text = 'Loading...') {
            if (!element) return;
            if (isLoading) {
                element.classList.add('loading');
                element.setAttribute('aria-busy', 'true');
                if (element.tagName === 'BUTTON') {
                    element.disabled = true;
                    element.setAttribute('data-original-text', element.textContent);
                    element.textContent = text;
                }
            } else {
                element.classList.remove('loading');
                element.setAttribute('aria-busy', 'false');
                if (element.tagName === 'BUTTON') {
                    element.disabled = false;
                    const originalText = element.getAttribute('data-original-text');
                    if (originalText) {
                        element.textContent = originalText;
                        element.removeAttribute('data-original-text');
                    }
                }
            }
        },
        parseRange(rangeStr) {
            if (!rangeStr) return { min: null, max: null };
            const parts = rangeStr.split('-').map(p => parseFloat(p.trim()));
            return {
                min: parts[0] || null,
                max: parts[1] || parts[0] || null
            };
        },
        formatRangeLabel(range) {
            if (!range) return '';
            if (typeof range === 'string') {
                const { min, max } = this.parseRange(range);
                if (min === max || !max) {
                    return this.formatCurrency(min);
                }
                return `${this.formatCurrency(min)} - ${this.formatCurrency(max)}`;
            }
            return range.toString();
        },
        addEventListenerWithCleanup(element, event, handler) {
            if (!element) return null;
            element.addEventListener(event, handler);
            return () => element.removeEventListener(event, handler);
        },
        batchDOMUpdates(updates) {
            requestAnimationFrame(() => {
                updates.forEach(update => update());
            });
        },
        createFragment(elements) {
            const fragment = document.createDocumentFragment();
            elements.forEach(el => {
                if (el) fragment.appendChild(el);
            });
            return fragment;
        }
    };
    window.PicksDOMUtils = DOMUtils;
})();
(function() {
    'use strict';
    const FilterManager = {
        DATE_FILTER_GROUP_MAP: {
            dates: 'selectedDates',
            times: 'selectedTimes',
            books: 'selectedBooks'
        },
        DATE_FILTER_GROUP_LABELS: {
            dates: 'Dates',
            times: 'Times',
            books: 'Sportsbooks'
        },
        normalizeFilterValue(value) {
            return (value ?? '').toString().trim().toLowerCase();
        },
        getDateTimeParts(row) {
            const dateCell = row.querySelector('td:first-child');
            if (!dateCell) return { date: '', time: '', book: '' };
            const dateEl = dateCell.querySelector('.cell-date');
            const timeEl = dateCell.querySelector('.cell-time');
            const bookEl = dateCell.querySelector('.cell-book, .sportsbook-name');
            let dateText = dateEl ? dateEl.textContent.trim() : '';
            let timeText = timeEl ? timeEl.textContent.trim() : '';
            let bookText = bookEl ? bookEl.textContent.trim() : '';
            const weekdayEl = dateCell.querySelector('.cell-weekday');
            if (weekdayEl) {
                const weekday = weekdayEl.textContent.trim();
                if (weekday && !dateText.includes(weekday)) {
                    dateText = `${weekday} ${dateText}`;
                }
            }
            return {
                date: dateText,
                time: timeText,
                book: bookText
            };
        },
        getMatchupValue(row) {
            const matchupCell = row.querySelector('td:nth-child(2)');
            if (!matchupCell) return '';
            let text = matchupCell.textContent || '';
            const logos = matchupCell.querySelectorAll('.team-logo');
            if (logos.length > 0) {
                const teams = Array.from(logos).map(logo =>
                    logo.getAttribute('alt') || logo.getAttribute('title') || ''
                ).filter(Boolean);
                if (teams.length > 0) {
                    text = teams.join(' vs ');
                }
            }
            return text.toLowerCase();
        },
        getPickValue(row) {
            const pickCell = row.querySelector('td:nth-child(3)');
            if (!pickCell) return '';
            const pickText = pickCell.textContent || '';
            const betTypeEl = pickCell.querySelector('[data-bet-type]');
            const betType = betTypeEl ? betTypeEl.getAttribute('data-bet-type') : '';
            return {
                text: pickText.toLowerCase(),
                betType: betType.toLowerCase()
            };
        },
        getCurrencyValue(row, columnIndex) {
            const cell = row.querySelector(`td:nth-child(${columnIndex})`);
            if (!cell) return null;
            const text = cell.textContent.replace(/[$,]/g, '').trim();
            return text ? parseFloat(text) : null;
        },
        getRiskValue(row) {
            const cell = row.querySelector('td:nth-child(5)');
            if (!cell) return null;
            const amountEl = cell.querySelector('.risk-amount');
            if (!amountEl) return null;
            const text = amountEl.textContent.replace(/[$,]/g, '').trim();
            return text ? parseFloat(text) : null;
        },
        getWinValue(row) {
            const cell = row.querySelector('td:nth-child(5)');
            if (!cell) return null;
            const amountEl = cell.querySelector('.win-amount');
            if (!amountEl) return null;
            const text = amountEl.textContent.replace(/[$,]/g, '').trim();
            return text ? parseFloat(text) : null;
        },
        getStatusValue(row) {
            const statusCell = row.querySelector('td:last-child');
            if (!statusCell) return '';
            const badge = statusCell.querySelector('.status-badge');
            if (badge) {
                return badge.getAttribute('data-status') ||
                       badge.className.match(/status-(\w+)/)?.[1] ||
                       badge.textContent.trim().toLowerCase();
            }
            return statusCell.textContent.trim().toLowerCase();
        },
        normalizeStatus(raw) {
            if (window.PicksDOMUtils && window.PicksDOMUtils.normalizeStatus) {
                return window.PicksDOMUtils.normalizeStatus(raw);
            }
            if (!raw) return '';
            const lower = raw.toString().toLowerCase().trim();
            const statusMap = {
                'win': 'win',
                'won': 'win',
                'winner': 'win',
                'loss': 'loss',
                'lost': 'loss',
                'lose': 'loss',
                'loser': 'loss',
                'push': 'push',
                'tie': 'push',
                'void': 'void',
                'voided': 'void',
                'cancelled': 'void',
                'pending': 'pending',
                'open': 'pending',
                'live': 'live',
                'in-progress': 'live',
                'in progress': 'live',
                'active': 'live'
            };
            return statusMap[lower] || lower;
        },
        detectBetType(row) {
            const pickCell = row.querySelector('td:nth-child(3)');
            if (!pickCell) return { type: '', subtype: '' };
            const pickText = (pickCell.textContent || '').toLowerCase();
            const betTypeAttr = pickCell.querySelector('[data-bet-type]');
            if (betTypeAttr) {
                const type = betTypeAttr.getAttribute('data-bet-type').toLowerCase();
                const subtype = betTypeAttr.getAttribute('data-bet-subtype') || '';
                return { type, subtype: subtype.toLowerCase() };
            }
            if (pickText.includes('spread') || pickText.includes('+') || pickText.includes('-')) {
                if (pickText.includes('1st') || pickText.includes('first')) {
                    return { type: 'spread', subtype: '1h' };
                }
                if (pickText.includes('2nd') || pickText.includes('second')) {
                    return { type: 'spread', subtype: '2h' };
                }
                return { type: 'spread', subtype: 'game' };
            }
            if (pickText.includes('total') || pickText.includes('over') || pickText.includes('under')) {
                if (pickText.includes('1st') || pickText.includes('first')) {
                    return { type: 'total', subtype: '1h' };
                }
                if (pickText.includes('2nd') || pickText.includes('second')) {
                    return { type: 'total', subtype: '2h' };
                }
                return { type: 'total', subtype: 'game' };
            }
            if (pickText.includes('moneyline') || pickText.includes('ml')) {
                if (pickText.includes('1st') || pickText.includes('first')) {
                    return { type: 'moneyline', subtype: '1h' };
                }
                if (pickText.includes('2nd') || pickText.includes('second')) {
                    return { type: 'moneyline', subtype: '2h' };
                }
                return { type: 'moneyline', subtype: 'game' };
            }
            if (pickText.includes('parlay')) {
                return { type: 'parlay', subtype: '' };
            }
            if (pickText.includes('prop') || pickText.includes('player')) {
                return { type: 'prop', subtype: '' };
            }
            return { type: '', subtype: '' };
        },
        detectSegment(row) {
            const segmentCell = row.querySelector('td:nth-child(4)');
            if (!segmentCell) return 'game';
            const segmentSpan = segmentCell.querySelector('.game-segment');
            if (segmentSpan && segmentSpan.getAttribute('data-segment')) {
                return segmentSpan.getAttribute('data-segment').toLowerCase();
            }
            const text = segmentCell.textContent.trim().toLowerCase();
            if (text.includes('1st') || text.includes('1h') || text.includes('1q')) return '1h';
            if (text.includes('2nd') || text.includes('2h') || text.includes('2q')) return '2h';
            return 'game';
        },
        valueMatchesRangeList(ranges, value) {
            if (!ranges || ranges.length === 0 || value === null) return false;
            return ranges.some(range => {
                const [min, max] = range.split('-').map(v => parseFloat(v));
                return value >= min && value <= max;
            });
        },
        passesDateFilter(row) {
            const filters = window.tableState.filters.date;
            if (!filters.selectedDates && !filters.selectedTimes &&
                !filters.selectedBooks && !filters.start && !filters.end) {
                return true;
            }
            const { date, time, book } = this.getDateTimeParts(row);
            if (filters.selectedDates && filters.selectedDates.length > 0) {
                const normalizedDate = this.normalizeFilterValue(date);
                const passes = filters.selectedDates.some(selected =>
                    normalizedDate.includes(this.normalizeFilterValue(selected))
                );
                if (!passes) return false;
            }
            if (filters.selectedTimes && filters.selectedTimes.length > 0) {
                const normalizedTime = this.normalizeFilterValue(time);
                const passes = filters.selectedTimes.some(selected =>
                    normalizedTime.includes(this.normalizeFilterValue(selected))
                );
                if (!passes) return false;
            }
            if (filters.selectedBooks && filters.selectedBooks.length > 0) {
                const normalizedBook = this.normalizeFilterValue(book);
                const passes = filters.selectedBooks.some(selected =>
                    normalizedBook.includes(this.normalizeFilterValue(selected))
                );
                if (!passes) return false;
            }
            return true;
        },
        passesMatchupFilter(row) {
            const filters = window.tableState.filters.matchup;
            if (filters.ticketType && filters.ticketType !== 'all') {
                const isParlay = row.classList.contains('parlay-row');
                if (filters.ticketType === 'single' && isParlay) return false;
                if (filters.ticketType === 'parlay' && !isParlay) return false;
            }
            if (filters.league) {
                const matchupText = this.getMatchupValue(row);
                if (!matchupText.includes(filters.league.toLowerCase())) {
                    return false;
                }
            }
            if (filters.selectedTeams && filters.selectedTeams.length > 0) {
                const matchupText = this.getMatchupValue(row);
                const passes = filters.selectedTeams.some(team =>
                    matchupText.includes(team.toLowerCase())
                );
                if (!passes) return false;
            }
            return true;
        },
        passesPickFilter(row) {
            const filters = window.tableState.filters.pick;
            if (filters.betType || filters.subtype) {
                const detected = this.detectBetType(row);
                if (filters.betType && detected.type !== filters.betType.toLowerCase()) {
                    return false;
                }
                if (filters.subtype && detected.subtype !== filters.subtype.toLowerCase()) {
                    return false;
                }
            }
            if (filters.segment) {
                const segment = this.detectSegment(row);
                if (segment !== filters.segment.toLowerCase()) {
                    return false;
                }
            }
            return true;
        },
        passesRiskFilter(row) {
            const filters = window.tableState.filters.risk;
            if (filters.selectedRiskRanges && filters.selectedRiskRanges.length > 0) {
                const risk = this.getRiskValue(row);
                if (!this.valueMatchesRangeList(filters.selectedRiskRanges, risk)) {
                    return false;
                }
            }
            if (filters.selectedWinRanges && filters.selectedWinRanges.length > 0) {
                const win = this.getWinValue(row);
                if (!this.valueMatchesRangeList(filters.selectedWinRanges, win)) {
                    return false;
                }
            }
            if (filters.min !== null || filters.max !== null) {
                const risk = this.getRiskValue(row);
                if (filters.min !== null && risk < filters.min) return false;
                if (filters.max !== null && risk > filters.max) return false;
            }
            return true;
        },
        passesStatusFilter(row) {
            const filters = window.tableState.filters.status;
            if (!filters || filters.length === 0) {
                return true;
            }
            const status = this.normalizeStatus(this.getStatusValue(row));
            return filters.some(filter =>
                this.normalizeStatus(filter) === status
            );
        },
        passesAllFilters(row) {
            const filters = window.tableState?.filters;
            if (!filters) return true;
            if (filters.search) {
                const rowText = row.textContent.toLowerCase();
                if (!rowText.includes(filters.search)) return false;
            }
            if (filters.date) {
                const { start, end } = filters.date;
                if (start && end) {
                    const rowEpoch = parseInt(row.getAttribute('data-epoch'), 10);
                    if (isNaN(rowEpoch)) return false; 
                    const rowDate = new Date(rowEpoch * 1000);
                    const startDate = new Date(start); startDate.setHours(0,0,0,0);
                    const endDate = new Date(end); endDate.setHours(23,59,59,999);
                    if (rowDate < startDate || rowDate > endDate) return false;
                }
            }
            if (filters.matchup?.league) {
                const rowLeague = (row.getAttribute('data-league') || '').toLowerCase();
                if (rowLeague !== filters.matchup.league.toLowerCase()) return false;
            }
            if (filters.pick?.segment) {
                const rowSegment = (row.getAttribute('data-segment') || '').toLowerCase();
                let normalizedRowSegment = rowSegment;
                if (rowSegment === 'full game') normalizedRowSegment = 'full';
                if (normalizedRowSegment !== filters.pick.segment.toLowerCase()) return false;
            }
            return true;
        },
        applyFilters: (function() {
            let debouncedApply = null;
            return function() {
                if (!debouncedApply && window.SharedUtils?.debounce) {
                    debouncedApply = window.SharedUtils.debounce(function() {
                        if (window.PicksTableRenderer) {
                            window.PicksTableRenderer.updateTable();
                        }
                    }, 150);
                }
                if (debouncedApply) {
                    debouncedApply();
                } else if (window.PicksTableRenderer) {
                    window.PicksTableRenderer.updateTable();
                } else {
                    console.warn('PicksTableRenderer not loaded');
                }
            };
        })(),
        applyFilter(type, options = {}) {
            switch(type) {
                case 'date':
                    this.syncDateFilterStateFromUI();
                    break;
                case 'matchup':
                    this.syncMatchupFilterStateFromUI();
                    break;
                case 'pick':
                    this.syncPickFilterStateFromUI();
                    break;
                case 'risk':
                    this.syncRiskFilterStateFromUI();
                    break;
                case 'status':
                    this.syncStatusFilterStateFromUI();
                    break;
            }
            this.applyFilters();
            if (window.PicksTableRenderer) {
                const count = this.countVisibleRows();
                window.PicksTableRenderer.announceFilterChange(
                    `Filter applied. ${count} rows visible.`
                );
            }
        },
        resetFilter(type) {
            if (window.PicksStateManager) {
                window.PicksStateManager.resetFilter(type);
            }
            this.clearFilterUI(type);
            this.applyFilters();
        },
        clearFilterByChip(type, subtype) {
            if (type === 'date' && subtype) {
                const stateKey = this.DATE_FILTER_GROUP_MAP[subtype];
                if (stateKey) {
                    window.tableState.filters.date[stateKey] = null;
                }
            } else {
                this.resetFilter(type);
            }
            this.applyFilters();
        },
        syncDateFilterStateFromUI() {
            const container = document.getElementById('date-filter-options');
            if (!container) return;
            const checkboxes = container.querySelectorAll('input[type="checkbox"]:checked');
            const grouped = { dates: [], times: [], books: [] };
            checkboxes.forEach(cb => {
                if (cb.id === 'date-select-all') return;
                const group = cb.getAttribute('data-group');
                const value = cb.value;
                if (group && value && grouped[group]) {
                    grouped[group].push(value);
                }
            });
            window.tableState.filters.date.selectedDates = grouped.dates.length > 0 ? grouped.dates : null;
            window.tableState.filters.date.selectedTimes = grouped.times.length > 0 ? grouped.times : null;
            window.tableState.filters.date.selectedBooks = grouped.books.length > 0 ? grouped.books : null;
        },
        syncMatchupFilterStateFromUI() {
            const leagueSelect = document.getElementById('league-select');
            const teamsList = document.getElementById('teams-list');
            if (leagueSelect) {
                window.tableState.filters.matchup.league = leagueSelect.value;
            }
            if (teamsList) {
                const checkedTeams = teamsList.querySelectorAll('input[type="checkbox"]:checked');
                const teams = Array.from(checkedTeams)
                    .filter(cb => cb.id !== 'teams-select-all')
                    .map(cb => cb.value);
                window.tableState.filters.matchup.selectedTeams =
                    teams.length > 0 ? teams : null;
            }
            const ticketType = document.querySelector('input[name="ticket-type"]:checked');
            if (ticketType) {
                window.tableState.filters.matchup.ticketType = ticketType.value;
            }
        },
        syncPickFilterStateFromUI() {
            const betTypeSelect = document.getElementById('bet-type-select');
            const subtypeSelect = document.getElementById('subtype-select');
            const segmentSelect = document.getElementById('segment-select');
            if (betTypeSelect) {
                window.tableState.filters.pick.betType = betTypeSelect.value;
            }
            if (subtypeSelect) {
                window.tableState.filters.pick.subtype = subtypeSelect.value;
            }
            if (segmentSelect) {
                window.tableState.filters.pick.segment = segmentSelect.value;
            }
        },
        syncRiskFilterStateFromUI() {
            const riskContainer = document.getElementById('risk-ranges');
            const winContainer = document.getElementById('win-ranges');
            if (riskContainer) {
                const checked = riskContainer.querySelectorAll('input[type="checkbox"]:checked');
                const ranges = Array.from(checked).map(cb => cb.value);
                window.tableState.filters.risk.selectedRiskRanges = ranges;
            }
            if (winContainer) {
                const checked = winContainer.querySelectorAll('input[type="checkbox"]:checked');
                const ranges = Array.from(checked).map(cb => cb.value);
                window.tableState.filters.risk.selectedWinRanges = ranges;
            }
        },
        syncStatusFilterStateFromUI() {
            const container = document.getElementById('status-filter-options');
            if (!container) return;
            const checked = container.querySelectorAll('input[type="checkbox"]:checked');
            const statuses = Array.from(checked).map(cb => cb.value);
            window.tableState.filters.status = statuses;
        },
        clearFilterUI(type) {
            switch(type) {
                case 'date':
                    const dateChecks = document.querySelectorAll('#date-filter-options input[type="checkbox"]');
                    dateChecks.forEach(cb => cb.checked = false);
                    break;
                case 'matchup':
                    const leagueSelect = document.getElementById('league-select');
                    if (leagueSelect) leagueSelect.value = '';
                    const teamChecks = document.querySelectorAll('#teams-list input[type="checkbox"]');
                    teamChecks.forEach(cb => cb.checked = false);
                    break;
                case 'pick':
                    const betTypeSelect = document.getElementById('bet-type-select');
                    if (betTypeSelect) betTypeSelect.value = '';
                    const subtypeSelect = document.getElementById('subtype-select');
                    if (subtypeSelect) subtypeSelect.value = '';
                    const segmentSelect = document.getElementById('segment-select');
                    if (segmentSelect) segmentSelect.value = '';
                    break;
                case 'risk':
                    const riskChecks = document.querySelectorAll('#risk-ranges input[type="checkbox"], #win-ranges input[type="checkbox"]');
                    riskChecks.forEach(cb => cb.checked = false);
                    break;
                case 'status':
                    const statusChecks = document.querySelectorAll('#status-filter-options input[type="checkbox"]');
                    statusChecks.forEach(cb => cb.checked = false);
                    break;
            }
        },
        countVisibleRows() {
            const tbody = document.getElementById('picks-tbody');
            if (!tbody) return 0;
            const rows = tbody.querySelectorAll('tr:not(.parlay-legs)');
            return Array.from(rows).filter(row => row.style.display !== 'none').length;
        }
    };
    window.PicksFilterManager = FilterManager;
})();
(function() {
    'use strict';
    const SortManager = {
        getDateSortValue(dateText) {
            if (!dateText) return 0;
            const cleanDate = dateText.replace(/^(mon|tue|wed|thu|fri|sat|sun)\s+/i, '');
            const parts = cleanDate.split('/');
            if (parts.length === 2) {
                const month = parseInt(parts[0], 10) || 0;
                const day = parseInt(parts[1], 10) || 0;
                const currentYear = new Date().getFullYear();
                return new Date(currentYear, month - 1, day).getTime();
            }
            return 0;
        },
        getTimeSortValue(timeText) {
            if (!timeText) return 0;
            const match = timeText.match(/(\d{1,2}):(\d{2})\s*(am|pm)?/i);
            if (match) {
                let hours = parseInt(match[1], 10);
                const minutes = parseInt(match[2], 10);
                const period = match[3] ? match[3].toLowerCase() : '';
                if (period === 'pm' && hours !== 12) {
                    hours += 12;
                } else if (period === 'am' && hours === 12) {
                    hours = 0;
                }
                return hours * 60 + minutes;
            }
            return 0;
        },
        getSortValue(row, column) {
            switch(column) {
                case 'date': {
                    const dateCell = row.querySelector('td:first-child');
                    if (!dateCell) return 0;
                    const dateEl = dateCell.querySelector('.cell-date');
                    const timeEl = dateCell.querySelector('.cell-time');
                    const dateValue = this.getDateSortValue(dateEl ? dateEl.textContent : '');
                    const timeValue = this.getTimeSortValue(timeEl ? timeEl.textContent : '');
                    return dateValue + timeValue / (24 * 60);
                }
                case 'matchup': {
                    const cell = row.querySelector('td:nth-child(2)');
                    return cell ? cell.textContent.trim().toLowerCase() : '';
                }
                case 'pick': {
                    const cell = row.querySelector('td:nth-child(3)');
                    return cell ? cell.textContent.trim().toLowerCase() : '';
                }
                case 'segment': {
                    const cell = row.querySelector('td:nth-child(4)');
                    return cell ? cell.textContent.trim().toLowerCase() : '';
                }
                case 'risk': {
                    const cell = row.querySelector('td:nth-child(5)');
                    if (!cell) return 0;
                    const amountEl = cell.querySelector('.risk-amount');
                    if (!amountEl) return 0;
                    const text = amountEl.textContent.replace(/[$,]/g, '').trim();
                    return parseFloat(text) || 0;
                }
                case 'win': {
                    const cell = row.querySelector('td:nth-child(5)');
                    if (!cell) return 0;
                    const amountEl = cell.querySelector('.win-amount');
                    if (!amountEl) return 0;
                    const text = amountEl.textContent.replace(/[$,]/g, '').trim();
                    return parseFloat(text) || 0;
                }
                case 'status': {
                    const cell = row.querySelector('td:last-child');
                    if (!cell) return '';
                    const badge = cell.querySelector('.status-badge');
                    if (badge) {
                        const status = badge.getAttribute('data-status') ||
                                      badge.className.match(/status-(\w+)/)?.[1] ||
                                      badge.textContent.trim();
                        return this.getStatusSortPriority(status);
                    }
                    return cell.textContent.trim().toLowerCase();
                }
                default:
                    return '';
            }
        },
        getStatusSortPriority(status) {
            const priorities = {
                'live': 1,
                'in-progress': 1,
                'active': 1,
                'pending': 2,
                'open': 2,
                'win': 3,
                'won': 3,
                'loss': 4,
                'lost': 4,
                'push': 5,
                'tie': 5,
                'void': 6,
                'voided': 6,
                'cancelled': 6
            };
            const normalized = status.toString().toLowerCase();
            return priorities[normalized] || 99;
        },
        applySorting(rows) {
            const state = window.PicksStateManager ?
                window.PicksStateManager.getSortState() :
                window.tableState.sort;
            if (!state.column) {
                return rows;
            }
            const sorted = [...rows].sort((a, b) => {
                const aValue = this.getSortValue(a, state.column);
                const bValue = this.getSortValue(b, state.column);
                if (typeof aValue === 'number' && typeof bValue === 'number') {
                    return state.direction === 'asc' ?
                        aValue - bValue :
                        bValue - aValue;
                }
                const aStr = aValue.toString();
                const bStr = bValue.toString();
                if (state.direction === 'asc') {
                    return aStr.localeCompare(bStr);
                } else {
                    return bStr.localeCompare(aStr);
                }
            });
            return sorted;
        },
        handleHeaderClick(column) {
            const state = window.PicksStateManager ?
                window.PicksStateManager.getSortState() :
                window.tableState.sort;
            if (state.column === column) {
                const newDirection = state.direction === 'asc' ? 'desc' : 'asc';
                this.updateSort(column, newDirection);
            } else {
                this.updateSort(column, 'asc');
            }
            if (window.PicksTableRenderer) {
                window.PicksTableRenderer.updateTable();
            }
            this.updateSortIndicators();
        },
        updateSort(column, direction) {
            if (window.PicksStateManager) {
                window.PicksStateManager.updateSort(column, direction);
            } else {
                window.tableState.sort = { column, direction };
            }
        },
        resetSorting() {
            if (window.PicksStateManager) {
                window.PicksStateManager.resetSort();
            } else {
                window.tableState.sort = { column: null, direction: 'asc' };
            }
            this.updateSortIndicators();
            if (window.PicksTableRenderer) {
                window.PicksTableRenderer.updateTable();
            }
        },
        updateSortIndicators() {
        },
        initSorting() {
            const headers = document.querySelectorAll('th[data-sort]');
            headers.forEach(header => {
                const column = header.getAttribute('data-sort');
                header.style.cursor = 'pointer';
                header.setAttribute('role', 'button');
                header.setAttribute('aria-label', `Sort by ${column}`);
                const sortBtn = header.querySelector('.th-sort-btn');
                const target = sortBtn || header;
                target.addEventListener('click', (e) => {
                    if (e.target.closest('.th-filter-btn') || e.target.closest('.th-filter-dropdown')) {
                        return;
                    }
                    this.handleHeaderClick(column);
                });
                target.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.handleHeaderClick(column);
                    }
                });
            });
            this.updateSortIndicators();
        }
    };
    window.PicksSortManager = SortManager;
})();
(function() {
    'use strict';
    const TableRenderer = {
        getParentRowsOnly(tbody) {
            if (!tbody) return [];
            return Array.from(tbody.children).filter(row =>
                row && row.tagName === 'TR' && !row.classList.contains('parlay-legs')
            );
        },
        getDirectChildRows(tbody) {
            if (!tbody) return [];
            return Array.from(tbody.children).filter(node => node && node.tagName === 'TR');
        },
        isRowVisibleForZebra(row) {
            if (!row) return false;
            if (row.style.display === 'none') return false;
            return true;
        },
        applyZebraStripes() {
            if (window.ZebraStripes && typeof window.ZebraStripes.applyPicksTableZebraStripes === 'function') {
                window.ZebraStripes.applyPicksTableZebraStripes();
                return;
            }
            const tbody = document.getElementById('picks-tbody');
            if (!tbody) return;
            const visibleRows = this.getParentRowsOnly(tbody)
                .filter(row => this.isRowVisibleForZebra(row));
            visibleRows.forEach((row, index) => {
                const className = index % 2 === 0 ? 'zebra-even' : 'zebra-odd';
                const otherClass = index % 2 === 0 ? 'zebra-odd' : 'zebra-even';
                row.classList.remove(otherClass);
                row.classList.add(className);
                row.classList.add('zebra-row');
                if (window.PicksParlayManager) {
                    const legsRow = window.PicksParlayManager.findParlayLegsRow(row);
                    if (legsRow) {
                        legsRow.classList.remove(otherClass);
                        legsRow.classList.add(className);
                        legsRow.classList.add('zebra-row');
                    }
                }
            });
        },
        updateTable() {
            const tbody = document.getElementById('picks-tbody');
            if (!tbody) return;
            let parentRows = this.getParentRowsOnly(tbody);
            const sortState = window.PicksStateManager ?
                window.PicksStateManager.getSortState() :
                window.tableState.sort;
            if (sortState.column) {
                parentRows = window.PicksSortManager ?
                    window.PicksSortManager.applySorting(parentRows) :
                    parentRows;
                parentRows.forEach(row => {
                    tbody.appendChild(row);
                    if (window.PicksParlayManager && row.classList.contains('parlay-row')) {
                        window.PicksParlayManager.ensureLegRowPosition(row);
                    }
                });
            }
            this.applyFiltersToRows(parentRows);
            if (window.PicksParlayManager) {
                window.PicksParlayManager.refreshAllParlayVisibility();
            }
            this.applyZebraStripes();
            this.renderFilterChips();
        },
        applyFiltersToRows(rows) {
            if (!rows) {
                const tbody = document.getElementById('picks-tbody');
                rows = this.getParentRowsOnly(tbody);
            }
            rows.forEach(row => {
                const shouldShow = window.PicksFilterManager ?
                    window.PicksFilterManager.passesAllFilters(row) :
                    true;
                row.style.display = shouldShow ? '' : 'none';
                if (window.PicksParlayManager && row.classList.contains('parlay-row')) {
                    const legsRow = window.PicksParlayManager.findParlayLegsRow(row);
                    if (legsRow) {
                        if (!shouldShow) {
                            legsRow.style.display = 'none';
                        } else {
                            const parlayId = row.getAttribute('data-row-id');
                            const isExpanded = window.PicksStateManager ?
                                window.PicksStateManager.isParlayExpanded(parlayId) :
                                row.getAttribute('aria-expanded') === 'true';
                            legsRow.style.display = isExpanded ? 'table-row' : 'none';
                        }
                    }
                }
            });
        },
        renderFilterChips() {
            const container = document.querySelector('.filter-chips') ||
                            document.getElementById('filter-chips-container');
            if (!container) return;
            container.innerHTML = '';
            const state = window.PicksStateManager ?
                window.PicksStateManager.getState() :
                window.tableState;
            const filters = state.filters;
            const chips = [];
            if (filters.date.selectedDates && filters.date.selectedDates.length > 0) {
                chips.push({
                    type: 'date',
                    subtype: 'dates',
                    label: `Dates: ${filters.date.selectedDates.length} selected`,
                    value: filters.date.selectedDates
                });
            }
            if (filters.date.selectedTimes && filters.date.selectedTimes.length > 0) {
                chips.push({
                    type: 'date',
                    subtype: 'times',
                    label: `Times: ${filters.date.selectedTimes.length} selected`,
                    value: filters.date.selectedTimes
                });
            }
            if (filters.date.selectedBooks && filters.date.selectedBooks.length > 0) {
                chips.push({
                    type: 'date',
                    subtype: 'books',
                    label: `Books: ${filters.date.selectedBooks.length} selected`,
                    value: filters.date.selectedBooks
                });
            }
            if (filters.matchup.league || filters.matchup.selectedTeams) {
                const label = filters.matchup.selectedTeams ?
                    `Teams: ${filters.matchup.selectedTeams.length} selected` :
                    `League: ${filters.matchup.league}`;
                chips.push({
                    type: 'matchup',
                    label: label,
                    value: filters.matchup
                });
            }
            if (filters.pick.betType || filters.pick.subtype) {
                const parts = [];
                if (filters.pick.betType) parts.push(filters.pick.betType);
                if (filters.pick.subtype) parts.push(filters.pick.subtype);
                chips.push({
                    type: 'pick',
                    label: `Pick: ${parts.join(' - ')}`,
                    value: filters.pick
                });
            }
            if (filters.pick.segment) {
                chips.push({
                    type: 'segment',
                    label: `Segment: ${filters.pick.segment}`,
                    value: filters.pick.segment
                });
            }
            if (filters.risk.selectedRiskRanges && filters.risk.selectedRiskRanges.length > 0) {
                chips.push({
                    type: 'risk',
                    label: `Risk: ${filters.risk.selectedRiskRanges.length} ranges`,
                    value: filters.risk.selectedRiskRanges
                });
            }
            if (filters.risk.selectedWinRanges && filters.risk.selectedWinRanges.length > 0) {
                chips.push({
                    type: 'win',
                    label: `Win: ${filters.risk.selectedWinRanges.length} ranges`,
                    value: filters.risk.selectedWinRanges
                });
            }
            if (filters.status && filters.status.length > 0) {
                chips.push({
                    type: 'status',
                    label: `Status: ${filters.status.join(', ')}`,
                    value: filters.status
                });
            }
            chips.forEach(chip => {
                const chipEl = document.createElement('div');
                chipEl.className = 'filter-chip';
                chipEl.setAttribute('data-filter-type', chip.type);
                if (chip.subtype) {
                    chipEl.setAttribute('data-filter-subtype', chip.subtype);
                }
                const labelSpan = document.createElement('span');
                labelSpan.className = 'filter-chip-label';
                labelSpan.textContent = chip.label;
                const removeBtn = document.createElement('button');
                removeBtn.className = 'filter-chip-remove';
                removeBtn.innerHTML = '&times;';
                removeBtn.setAttribute('aria-label', `Remove ${chip.label} filter`);
                removeBtn.onclick = () => this.removeFilterChip(chip.type, chip.subtype);
                chipEl.appendChild(labelSpan);
                chipEl.appendChild(removeBtn);
                container.appendChild(chipEl);
            });
            if (chips.length > 0) {
                const clearAllBtn = document.createElement('button');
                clearAllBtn.className = 'clear-all-filters';
                clearAllBtn.textContent = 'Clear All';
                clearAllBtn.onclick = () => this.clearAllFilters();
                container.appendChild(clearAllBtn);
            }
        },
        removeFilterChip(type, subtype) {
            if (window.PicksFilterManager) {
                window.PicksFilterManager.clearFilterByChip(type, subtype);
            } else {
                console.warn('PicksFilterManager not loaded');
            }
        },
        clearAllFilters() {
            if (window.PicksStateManager) {
                window.PicksStateManager.resetAllFilters();
            }
            this.updateTable();
        },
        updateFilterIndicators() {
            const indicators = {
                'date-filter-btn': window.tableState.filters.date.selectedDates ||
                                   window.tableState.filters.date.selectedTimes ||
                                   window.tableState.filters.date.selectedBooks,
                'matchup-filter-btn': window.tableState.filters.matchup.league ||
                                     window.tableState.filters.matchup.selectedTeams,
                'pick-filter-btn': window.tableState.filters.pick.betType ||
                                  window.tableState.filters.pick.subtype,
                'risk-filter-btn': window.tableState.filters.risk.selectedRiskRanges?.length > 0 ||
                                  window.tableState.filters.risk.selectedWinRanges?.length > 0,
                'status-filter-btn': window.tableState.filters.status?.length > 0
            };
            Object.entries(indicators).forEach(([btnId, hasFilter]) => {
                const btn = document.getElementById(btnId);
                if (!btn) return;
                const indicator = btn.querySelector('.filter-indicator') ||
                                btn.querySelector('.indicator');
                if (hasFilter) {
                    btn.classList.add('has-filter');
                    if (indicator) {
                        indicator.style.display = 'inline-block';
                    }
                } else {
                    btn.classList.remove('has-filter');
                    if (indicator) {
                        indicator.style.display = 'none';
                    }
                }
            });
            const filterCount = window.PicksStateManager ?
                window.PicksStateManager.getActiveFilterCount() : 0;
            const countEl = document.getElementById('active-filter-count');
            if (countEl) {
                countEl.textContent = filterCount > 0 ? `(${filterCount})` : '';
            }
        },
        announceFilterChange(message) {
            let announcer = document.getElementById('filter-announcer');
            if (!announcer) {
                announcer = document.createElement('div');
                announcer.id = 'filter-announcer';
                announcer.setAttribute('role', 'status');
                announcer.setAttribute('aria-live', 'polite');
                announcer.setAttribute('aria-atomic', 'true');
                announcer.style.position = 'absolute';
                announcer.style.left = '-10000px';
                announcer.style.width = '1px';
                announcer.style.height = '1px';
                announcer.style.overflow = 'hidden';
                document.body.appendChild(announcer);
            }
            announcer.textContent = message;
        },
        refresh() {
            this.updateTable();
            this.updateFilterIndicators();
        }
    };
    let zebraDebounceTimer;
    TableRenderer.debouncedZebraStripes = function() {
        clearTimeout(zebraDebounceTimer);
        zebraDebounceTimer = setTimeout(() => {
            TableRenderer.applyZebraStripes();
        }, 50);
    };
    window.PicksTableRenderer = TableRenderer;
})();
(function() {
    'use strict';
    const ParlayManager = {
        calculateParlayStatus(legs) {
            if (!legs || legs.length === 0) return 'pending';
            const utils = window.PicksDOMUtils || {};
            const normalize = utils.normalizeStatus ?
                utils.normalizeStatus.bind(utils) :
                this.normalizeLegStatus.bind(this);
            const statuses = legs.map(leg => normalize(leg.status));
            if (statuses.includes('loss')) {
                return 'loss';
            }
            if (statuses.includes('void')) {
                const nonVoidStatuses = statuses.filter(s => s !== 'void');
                if (nonVoidStatuses.length === 0) {
                    return 'void';
                }
                return this.calculateParlayStatus(
                    legs.filter(leg => normalize(leg.status) !== 'void')
                );
            }
            if (statuses.includes('live')) {
                return 'live';
            }
            if (statuses.includes('pending')) {
                return 'pending';
            }
            if (statuses.every(s => s === 'push')) {
                return 'push';
            }
            if (statuses.every(s => s === 'win')) {
                return 'win';
            }
            if (statuses.every(s => s === 'win' || s === 'push')) {
                return 'win';
            }
            return 'pending';
        },
        normalizeLegStatus(status) {
            if (window.PicksDOMUtils && window.PicksDOMUtils.normalizeStatus) {
                return window.PicksDOMUtils.normalizeStatus(status);
            }
            if (!status) return 'pending';
            const lower = status.toString().toLowerCase().trim();
            const statusMap = {
                'win': 'win',
                'won': 'win',
                'winner': 'win',
                'loss': 'loss',
                'lost': 'loss',
                'lose': 'loss',
                'push': 'push',
                'tie': 'push',
                'void': 'void',
                'voided': 'void',
                'cancelled': 'void',
                'pending': 'pending',
                'open': 'pending',
                'live': 'live',
                'active': 'live',
                'in-progress': 'live'
            };
            return statusMap[lower] || 'pending';
        },
        findParlayLegsRow(parentRow) {
            if (!parentRow) return null;
            const rowId = parentRow.getAttribute('data-row-id');
            if (rowId) {
                const tbody = parentRow.parentElement;
                const legsRow = tbody.querySelector(`tr.parlay-legs[data-parent-id="${rowId}"]`);
                if (legsRow) return legsRow;
            }
            const nextRow = parentRow.nextElementSibling;
            if (nextRow && nextRow.classList.contains('parlay-legs')) {
                return nextRow;
            }
            return null;
        },
        formatLegLine(leg, index, parentRow, parentDate, parentTime) {
            const utils = window.PicksDOMUtils || {};
            const legNum = index + 1;
            const parsePickDescription = window.parsePickDescription || (() => ({}));
            const parseTeamsFromGame = window.parseTeamsFromGame || ((game) => ({ away: '', home: '' }));
            const getTeamAbbr = window.getTeamAbbr || ((name) => name);
            const getTeamLogo = window.getTeamLogo || ((name, league) => 'assets/data/logos/default.png');
            const generatePickDisplay = window.generatePickDisplay || (() => '');
            const buildStatusMeta = window.buildStatusMeta || (() => ({}));
            const buildStatusBadgeHTML = window.buildStatusBadgeHTML || (() => '');
            const getStatusBlurb = window.getStatusBlurb || (() => '');
            const pickDescription = leg.description || leg.pick || '';
            const legParsed = parsePickDescription(pickDescription);
            const gameString = leg.game || leg.matchup || '';
            const legTeams = parseTeamsFromGame(gameString);
            const legAwayAbbr = getTeamAbbr(legTeams.away);
            const legHomeAbbr = getTeamAbbr(legTeams.home);
            const league = (leg.league || leg.sport || 'nfl').toLowerCase();
            const legAwayLogo = getTeamLogo(legTeams.away, league);
            const legHomeLogo = getTeamLogo(legTeams.home, league);
            const statusMeta = buildStatusMeta({
                status: leg.status || 'pending',
                result: leg.score || leg.result,
                score: leg.score || leg.result,
                matchup: leg.matchup || leg.game,
                selection: leg.selection,
                description: leg.description,
                parsedPick: legParsed,
                market: leg.market,
                start: leg.start || leg.countdown
            });
            const legStatusClass = (leg.status || 'pending').toLowerCase();
            const derivedStatus = (statusMeta.statusKey || legStatusClass || 'pending').toLowerCase();
            const isLiveLeg = derivedStatus === 'on-track' || derivedStatus === 'at-risk' || derivedStatus === 'live';
            const statusTooltipText = statusMeta.tooltip || getStatusBlurb(leg.status || '', leg.result || '') || '';
            const legBadgeMarkup = buildStatusBadgeHTML({
                statusClass: derivedStatus,
                label: statusMeta.statusLabel || leg.status || 'Pending',
                tooltip: statusTooltipText,
                info: statusMeta.badgeContext,
                extraClass: isLiveLeg ? 'live-pulsing' : ''
            });
            let pickedTeamLogo = legAwayLogo;
            let pickedTeamAbbr = legAwayAbbr;
            let pickedTeamName = legTeams.away;
            if (legParsed.pickTeam) {
                const pickTeamLower = legParsed.pickTeam.toLowerCase();
                const homeLower = (legTeams.home || '').toLowerCase();
                if (homeLower.includes(pickTeamLower) || pickTeamLower.includes(homeLower)) {
                    pickedTeamLogo = legHomeLogo;
                    pickedTeamAbbr = legHomeAbbr;
                    pickedTeamName = legTeams.home;
                }
            } else if (legParsed.pickType === 'Over' || legParsed.pickType === 'Under') {
                pickedTeamAbbr = legParsed.pickType.substring(0, 1); 
            }
            const dateValue = leg.accepted || parentDate || '';
            const timeValue = leg.scheduled ? leg.scheduled.split(' ').slice(-2).join(' ') : (leg.start || leg.countdown || parentTime || '');
            const pickDisplay = generatePickDisplay(legParsed, pickedTeamLogo, pickedTeamAbbr, pickedTeamName);
            const boxScoreRows = createBoxScoreRows(leg, legAwayLogo, legAwayAbbr, legHomeLogo, legHomeAbbr, derivedStatus);
            return `
                <tr class="parlay-leg-row group-start ${isLiveLeg ? 'live-game' : ''}" 
                    data-leg-index="${index}" 
                    data-leg-number="${legNum}"
                    data-status="${derivedStatus}"
                    data-pick-type="${legParsed.pickType?.toLowerCase() || 'unknown'}" 
                    data-pick-text="${(pickDescription || '').toLowerCase()}" 
                    data-segment="${(leg.segment || 'full-game').toLowerCase().replace(/\s+/g, '-')}" 
                    data-odds="${legParsed.odds || '-110'}" 
                    data-away="${legTeams.away.toLowerCase()}" 
                    data-home="${legTeams.home.toLowerCase()}">
                    <td>
                        <div class="datetime-cell">
                            <span class="date-value">${dateValue}</span>
                            ${timeValue ? `<span class="time-value">${timeValue}</span>` : ''}
                        </div>
                    </td>
                    <td>
                        <div class="matchup-cell-parlay-leg">
                            <img src="${legAwayLogo}" class="team-logo" loading="lazy" alt="${legAwayAbbr}">
                            <span class="team-name-full">${utils.escapeHtml ? utils.escapeHtml(legTeams.away) : legTeams.away}</span>
                            <span class="team-record" data-team="${legAwayAbbr}"></span>
                            <span class="vs-divider-inline">vs</span>
                            <img src="${legHomeLogo}" class="team-logo" loading="lazy" alt="${legHomeAbbr}">
                            <span class="team-name-full">${utils.escapeHtml ? utils.escapeHtml(legTeams.home) : legTeams.home}</span>
                            <span class="team-record" data-team="${legHomeAbbr}"></span>
                        </div>
                    </td>
                    <td>
                        <div class="pick-cell">
                            ${pickDisplay}
                        </div>
                    </td>
                    <td class="center">
                        <span class="game-segment">${leg.segment || 'Full Game'}</span>
                    </td>
                    <td class="center">
                        ${legBadgeMarkup}
                    </td>
                </tr>
            `;
        },
        syncParlaySummary(parentRow, legsData) {
            if (!parentRow || !legsData) return;
            const summaryEl = parentRow.querySelector('.parlay-summary');
            if (!summaryEl) return;
            const legCount = legsData.length;
            const legStatuses = legsData.map(leg => this.normalizeLegStatus(leg.status));
            const statusCounts = {
                win: legStatuses.filter(s => s === 'win').length,
                loss: legStatuses.filter(s => s === 'loss').length,
                push: legStatuses.filter(s => s === 'push').length,
                pending: legStatuses.filter(s => s === 'pending').length,
                live: legStatuses.filter(s => s === 'live').length,
                void: legStatuses.filter(s => s === 'void').length
            };
            const statusParts = [];
            if (statusCounts.win > 0) statusParts.push(`${statusCounts.win} won`);
            if (statusCounts.loss > 0) statusParts.push(`${statusCounts.loss} lost`);
            if (statusCounts.push > 0) statusParts.push(`${statusCounts.push} push`);
            if (statusCounts.pending > 0) statusParts.push(`${statusCounts.pending} pending`);
            if (statusCounts.live > 0) statusParts.push(`${statusCounts.live} live`);
            if (statusCounts.void > 0) statusParts.push(`${statusCounts.void} void`);
            const statusSummary = statusParts.length > 0 ?
                ` (${statusParts.join(', ')})` : '';
            summaryEl.textContent = `${legCount}-leg parlay${statusSummary}`;
        },
        hydrateParlayLegs(parentRow, presetLegsRow) {
            if (!parentRow) return;
            const legsDataAttr = parentRow.getAttribute('data-parlay-legs') || 
                                parentRow.getAttribute('data-legs');
            if (!legsDataAttr) return;
            let legsData;
            try {
                legsData = JSON.parse(legsDataAttr);
            } catch (e) {
                console.error('Failed to parse parlay legs data:', e);
                return;
            }
            if (!Array.isArray(legsData) || legsData.length === 0) return;
            const legsRow = presetLegsRow || this.findParlayLegsRow(parentRow);
            if (!legsRow) return;
            console.warn('createParlayLegsRow function not found or failed, using fallback formatLegLine');
            const dateCell = parentRow.querySelector('td:first-child');
            const parentDate = dateCell ? dateCell.querySelector('.date-value, .cell-date')?.textContent : '';
            const parentTime = dateCell ? dateCell.querySelector('.time-value, .cell-time')?.textContent : '';
            const legsHtml = legsData.map((leg, index) =>
                this.formatLegLine(leg, index, parentRow, parentDate, parentTime)
            ).join('');
            const legsContainer = legsRow.querySelector('.parlay-legs-container');
            const tableHtml = `
                <div class="parlay-legs-header">
                    <div class="parlay-legs-title">
                        <span class="parlay-legs-heading">Parlay Details</span>
                    </div>
                </div>
                <table class="picks-table compact-leg-table" style="margin: 0;">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Matchup</th>
                            <th>Pick</th>
                            <th>Segment</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${legsHtml}
                    </tbody>
                </table>
            `;
            if (legsContainer) {
                legsContainer.innerHTML = tableHtml;
            } else {
                const td = legsRow.querySelector('td');
                if (td) {
                    td.innerHTML = `<div class="parlay-legs-container">${tableHtml}</div>`;
                }
            }
            this.hydrateLegLogos(legsRow);
            if (typeof populateTeamRecordsWhenReady === 'function') {
                populateTeamRecordsWhenReady(legsRow);
            }
            this.syncParlaySummary(parentRow, legsData);
            this.updateParlayStatus(parentRow, legsData);
        },
        hydrateLegLogos(legsRow) {
            if (!legsRow) return;
            const logos = legsRow.querySelectorAll('.team-logo[data-team]');
            logos.forEach(async (logo) => {
                const team = logo.getAttribute('data-team');
                const league = logo.getAttribute('data-league') || 'nfl';
                if (team && window.getTeamLogo) {
                    try {
                        const logoUrl = await window.getTeamLogo(team, league);
                        if (logoUrl) {
                            logo.src = logoUrl;
                        }
                    } catch (e) {
                        console.warn(`Failed to load logo for ${team}:`, e);
                    }
                }
            });
        },
        updateParlayStatus(parentRow, legsData) {
            if (!parentRow) return;
            const parlayStatus = this.calculateParlayStatus(legsData);
            const statusCell = parentRow.querySelector('td:last-child');
            if (statusCell) {
                const badge = statusCell.querySelector('.status-badge');
                if (badge) {
                    badge.setAttribute('data-status', parlayStatus);
                    badge.className = `status-badge status-${parlayStatus}`;
                    const utils = window.PicksDOMUtils || {};
                    badge.textContent = utils.formatBadgeStatus ?
                        utils.formatBadgeStatus(parlayStatus) : parlayStatus.toUpperCase();
                }
            }
        },
        refreshParlayStatuses() {
            const tbody = document.getElementById('picks-tbody');
            if (!tbody) return;
            const parlayRows = tbody.querySelectorAll('tr.parlay-row');
            parlayRows.forEach(row => {
                const legsDataAttr = row.getAttribute('data-parlay-legs');
                if (legsDataAttr) {
                    try {
                        const legsData = JSON.parse(legsDataAttr);
                        this.updateParlayStatus(row, legsData);
                    } catch (e) {
                        console.error('Failed to parse parlay legs:', e);
                    }
                }
            });
        },
        toggleParlayExpansion(parentRow) {
            if (!parentRow || !parentRow.classList.contains('parlay-row')) return;
            const isCurrentlyExpanded = parentRow.classList.contains('expanded');
            const newState = !isCurrentlyExpanded;
            let parlayId = parentRow.getAttribute('data-row-id') || 
                          parentRow.getAttribute('data-parlay-id') ||
                          parentRow.id;
            if (!parlayId) {
                parlayId = `parlay-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                parentRow.setAttribute('data-row-id', parlayId);
                if (!parentRow.id) {
                    parentRow.id = parlayId;
                }
            }
            if (window.PicksStateManager) {
                window.PicksStateManager.setParlayExpanded(parlayId, newState);
            }
            this.setRowExpansionState(parentRow, newState);
        },
        setRowExpansionState(parentRow, isExpanded) {
            if (!parentRow) return;
            if (isExpanded) {
                parentRow.classList.add('expanded');
                parentRow.setAttribute('aria-expanded', 'true');
            } else {
                parentRow.classList.remove('expanded');
                parentRow.setAttribute('aria-expanded', 'false');
            }
            let legsRow = this.findParlayLegsRow(parentRow);
            if (!legsRow && isExpanded) {
                const legsDataAttr = parentRow.getAttribute('data-parlay-legs');
                if (legsDataAttr) {
                    this.ingestParlayLegs(parentRow, JSON.parse(legsDataAttr));
                    legsRow = this.findParlayLegsRow(parentRow);
                }
            }
            if (legsRow) {
                if (isExpanded) {
                    legsRow.classList.add('show');
                    legsRow.style.display = 'table-row';
                    const container = legsRow.querySelector('.parlay-legs-container');
                    if (container && !container.querySelector('.parlay-leg-row')) {
                        this.hydrateParlayLegs(parentRow, legsRow);
                    }
                } else {
                    legsRow.classList.remove('show');
                    legsRow.style.display = 'none';
                }
            }
            const toggleElements = parentRow.querySelectorAll('.parlay-toggle, .parlay-toggle-icon, .parlay-expand-arrow');
            toggleElements.forEach(el => {
                el.setAttribute('aria-expanded', String(isExpanded));
            });
            if (typeof applyPicksTableZebraStripes === 'function') {
                setTimeout(() => applyPicksTableZebraStripes(), 10);
            }
        },
        refreshAllParlayVisibility() {
            const tbody = document.getElementById('picks-tbody');
            if (!tbody) return;
            const parlayRows = tbody.querySelectorAll('tr.parlay-row');
            parlayRows.forEach(row => {
                const parlayId = row.getAttribute('data-row-id');
                const isExpanded = window.PicksStateManager ?
                    window.PicksStateManager.isParlayExpanded(parlayId) :
                    row.getAttribute('aria-expanded') === 'true';
                this.setRowExpansionState(row, isExpanded);
            });
        },
        ensureLegRowPosition(parentRow) {
            if (!parentRow) return;
            const legsRow = this.findParlayLegsRow(parentRow);
            if (legsRow && parentRow.nextElementSibling !== legsRow) {
                parentRow.parentNode.insertBefore(legsRow, parentRow.nextSibling);
            }
        },
        initParlays() {
            const tbody = document.getElementById('picks-tbody');
            if (!tbody) return;
            if (this._parlayClickHandler) {
                tbody.removeEventListener('click', this._parlayClickHandler);
            }
            this._parlayClickHandler = (e) => {
                const row = e.target.closest('tr.parlay-row');
                if (!row) return;
                if (e.target.closest('.status-badge')) {
                    return;
                }
                if (e.target.tagName === 'A' || e.target.closest('a')) {
                    return;
                }
                e.preventDefault();
                e.stopPropagation();
                this.toggleParlayExpansion(row);
            };
            tbody.addEventListener('click', this._parlayClickHandler);
            if (this._parlayKeyHandler) {
                tbody.removeEventListener('keydown', this._parlayKeyHandler);
            }
            this._parlayKeyHandler = (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    const row = e.target.closest('tr.parlay-row');
                    if (row) {
                        e.preventDefault();
                        this.toggleParlayExpansion(row);
                    }
                }
            };
            tbody.addEventListener('keydown', this._parlayKeyHandler);
            this.refreshAllParlayVisibility();
            this.primeParlaySummaries();
            this.refreshParlayStatuses();
        },
        reinitParlays() {
            const tbody = document.getElementById('picks-tbody');
            if (!tbody) return;
            const parlayRows = tbody.querySelectorAll('tr.parlay-row');
            parlayRows.forEach(row => {
                const hasToggle = row.querySelector('.parlay-toggle, .parlay-toggle-icon, .parlay-expand-arrow');
                if (!hasToggle) {
                    const dateCell = row.querySelector('td:first-child');
                    if (dateCell) {
                        const toggle = document.createElement('span');
                        toggle.className = 'parlay-toggle-icon';
                        toggle.setAttribute('aria-label', 'Expand parlay details');
                        toggle.setAttribute('aria-expanded', 'false');
                        toggle.textContent = '▶';
                        toggle.setAttribute('role', 'button');
                        toggle.setAttribute('tabindex', '0');
                        const firstChild = dateCell.firstElementChild || dateCell.firstChild;
                        if (firstChild) {
                            dateCell.insertBefore(toggle, firstChild);
                        } else {
                            dateCell.appendChild(toggle);
                        }
                    }
                }
                if (!row.getAttribute('data-row-id')) {
                    const rowId = row.id || `parlay-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                    row.setAttribute('data-row-id', rowId);
                    if (!row.id) {
                        row.id = rowId;
                    }
                }
            });
            this.refreshAllParlayVisibility();
        },
        primeParlaySummaries() {
            const tbody = document.getElementById('picks-tbody');
            if (!tbody) return;
            const parlayRows = tbody.querySelectorAll('tr.parlay-row');
            parlayRows.forEach(row => {
                const legsDataAttr = row.getAttribute('data-parlay-legs');
                if (legsDataAttr) {
                    try {
                        const legsData = JSON.parse(legsDataAttr);
                        this.syncParlaySummary(row, legsData);
                    } catch (e) {
                        console.error('Failed to parse parlay legs:', e);
                    }
                }
            });
        },
        ingestParlayLegs(rowRef, legsData) {
            let parentRow;
            if (typeof rowRef === 'string') {
                parentRow = document.querySelector(rowRef);
            } else if (rowRef instanceof Element) {
                parentRow = rowRef;
            }
            if (!parentRow || !Array.isArray(legsData)) {
                console.error('Invalid row reference or legs data');
                return;
            }
            parentRow.setAttribute('data-parlay-legs', JSON.stringify(legsData));
            parentRow.classList.add('parlay-row');
            const hasToggle = parentRow.querySelector('.parlay-toggle, .parlay-toggle-icon, .parlay-expand-arrow');
            if (!hasToggle) {
                const dateCell = parentRow.querySelector('td:first-child');
                const matchupCell = parentRow.querySelector('td:nth-child(2)');
                const targetCell = dateCell || matchupCell;
                if (targetCell) {
                    const toggle = document.createElement('span');
                    toggle.className = 'parlay-toggle-icon';
                    toggle.setAttribute('aria-label', 'Expand parlay details');
                    toggle.setAttribute('aria-expanded', 'false');
                    toggle.textContent = '▶';
                    toggle.setAttribute('role', 'button');
                    toggle.setAttribute('tabindex', '0');
                    const firstChild = targetCell.firstElementChild || targetCell.firstChild;
                    if (firstChild) {
                        targetCell.insertBefore(toggle, firstChild);
                    } else {
                        targetCell.appendChild(toggle);
                    }
                }
            }
            let legsRow = this.findParlayLegsRow(parentRow);
            if (!legsRow) {
                legsRow = document.createElement('tr');
                legsRow.className = 'parlay-legs';
                legsRow.style.display = 'none';
                const rowId = parentRow.getAttribute('data-row-id') ||
                             `parlay-${Date.now()}`;
                parentRow.setAttribute('data-row-id', rowId);
                legsRow.setAttribute('data-parent-id', rowId);
                const td = document.createElement('td');
                td.setAttribute('colspan', '7');
                td.innerHTML = '<div class="parlay-legs-container"></div>';
                legsRow.appendChild(td);
                parentRow.parentNode.insertBefore(legsRow, parentRow.nextSibling);
            }
            this.syncParlaySummary(parentRow, legsData);
            this.updateParlayStatus(parentRow, legsData);
        },
        formatLegLine(leg, index, parentRow, parentDate, parentTime) {
            const utils = window.PicksDOMUtils || {};
            const getTeamInfo = window.getTeamInfo || ((name) => ({ abbr: name, logo: '' }));
            const pickTeamInfo = getTeamInfo(leg.pickTeam);
            const awayTeam = leg.awayTeam || leg.pickTeam || 'TBD';
            const homeTeam = leg.homeTeam || 'TBD';
            const awayInfo = getTeamInfo(awayTeam);
            const homeInfo = getTeamInfo(homeTeam);
            let selection = '';
            let market = '';
            if (leg.pickType === 'spread') {
                const line = leg.line || '';
                selection = line.startsWith('+') || line.startsWith('-') ? line : `+${line}`;
                market = 'Spread';
            } else if (leg.pickType === 'moneyline') {
                selection = 'ML';
                market = 'Moneyline';
            } else if (leg.pickType === 'total' || leg.pickType === 'team-total') {
                selection = `${leg.pickDirection || 'Over'} ${leg.line || ''}`;
                market = 'Total';
            }
            const status = leg.status || 'pending';
            const isSingleTeamBet = !leg.homeTeam || homeTeam === 'TBD';
            const awayLogoHtml = awayInfo.logo 
                ? `<img src="${awayInfo.logo}" class="team-logo" loading="lazy" alt="${awayInfo.abbr}" onerror="this.style.display='none'">`
                : '';
            const homeLogoHtml = homeInfo.logo 
                ? `<img src="${homeInfo.logo}" class="team-logo" loading="lazy" alt="${homeInfo.abbr}" onerror="this.style.display='none'">`
                : '';
            const pickLogoHtml = pickTeamInfo.logo
                ? `<img src="${pickTeamInfo.logo}" class="pick-team-logo" loading="lazy" alt="${pickTeamInfo.abbr}" onerror="this.style.display='none'">`
                : '';
            const matchupHtml = isSingleTeamBet 
                ? `<div class="matchup-cell-parlay-leg">
                        <div class="team-line">
                            ${awayLogoHtml}
                            <span class="team-name-full">${awayTeam}</span>
                        </div>
                    </div>`
                : `<div class="matchup-cell-parlay-leg">
                        <div class="team-line">
                            ${awayLogoHtml}
                            <span class="team-name-full">${awayTeam}</span>
                        </div>
                        <div class="vs-divider">vs</div>
                        <div class="team-line">
                            ${homeLogoHtml}
                            <span class="team-name-full">${homeTeam}</span>
                        </div>
                    </div>`;
            let dateStr = parentDate;
            let timeStr = parentTime;
            if (leg.gameDate) {
                const d = new Date(leg.gameDate);
                if (!isNaN(d)) {
                    dateStr = d.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
                }
            }
            if (leg.gameTime) timeStr = leg.gameTime;
            return `
                <tr class="parlay-leg-item">
                    <td data-label="Date & Time">
                        <div class="cell-date">${dateStr}</div>
                        <div class="cell-time">${timeStr}</div>
                    </td>
                    <td>
                        ${matchupHtml}
                    </td>
                    <td>
                        <div class="pick-cell">
                            <div class="pick-team-info">
                                ${pickLogoHtml}
                                <span class="pick-team-abbr">${pickTeamInfo.abbr}</span>
                            </div>
                            <div class="pick-details">
                                <span class="pick-market">${market}</span>
                                <span class="pick-selection">${selection}</span>
                                <span class="pick-odds">(${leg.odds || '-110'})</span>
                            </div>
                        </div>
                    </td>
                    <td class="center">
                        <span class="game-segment">${leg.segment || 'Full Game'}</span>
                    </td>
                    <td class="center">
                        <span class="status-badge" data-status="${status}">${status.charAt(0).toUpperCase() + status.slice(1)}</span>
                    </td>
                </tr>
            `;
        },
        getMiniStatusBadgeText(status, statusMeta, legInfo) {
            if (status === 'live' && statusMeta && statusMeta.score) {
                return statusMeta.score;
            }
            const utils = window.PicksDOMUtils || {};
            return utils.formatBadgeStatus ?
                utils.formatBadgeStatus(status) : status.toUpperCase();
        }
    };
    window.PicksParlayManager = ParlayManager;
    window.ingestParlayLegs = function(rowRef, legsData) {
        ParlayManager.ingestParlayLegs(rowRef, legsData);
    };
})();
(function() {
    'use strict';
    const debug = (...args) => {
        if (window.APP_CONFIG?.DEBUG_MODE) console.log('🔍 [Filters]', ...args);
    };
    function init() {
        debug('Initializing card-based filters...');
        bindFilterEvents();
        updateActiveStatesFromConfig();
    }
    function bindFilterEvents() {
        document.querySelectorAll('.filter-card[data-filter-type="date"] .filter-pill').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const range = e.target.dataset.range;
                handleDateFilter(range);
                updatePillState(e.target, '.filter-card[data-filter-type="date"] .filter-pill');
            });
        });
        document.querySelectorAll('.filter-card[data-filter-type="league"] .filter-icon-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const btnEl = e.currentTarget; 
                const league = btnEl.dataset.league;
                handleLeagueFilter(league);
                updatePillState(btnEl, '.filter-card[data-filter-type="league"] .filter-icon-btn');
            });
        });
        document.querySelectorAll('.filter-card[data-filter-type="segment"] .filter-pill').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const segment = e.target.dataset.segment;
                handleSegmentFilter(segment);
                updatePillState(e.target, '.filter-card[data-filter-type="segment"] .filter-pill');
            });
        });
        const searchInput = document.getElementById('global-search-input');
        if (searchInput) {
            searchInput.addEventListener('input', debounce((e) => {
                handleSearchFilter(e.target.value);
            }, 300));
        }
    }
    function updatePillState(activeBtn, selector) {
        document.querySelectorAll(selector).forEach(btn => btn.classList.remove('active'));
        activeBtn.classList.add('active');
    }
    function updateActiveStatesFromConfig() {
    }
    function handleDateFilter(range) {
        debug('Date filter selected:', range);
        if (window.TableFilters && window.TableFilters.setDateRange) {
            window.TableFilters.setDateRange(range);
        }
        applyFilters();
    }
    function handleLeagueFilter(league) {
        debug('League filter selected:', league);
        if (window.tableState && window.tableState.filters) {
            window.tableState.filters.matchup.league = (league === 'all') ? '' : league;
        }
        applyFilters();
    }
    function handleSegmentFilter(segment) {
        debug('Segment filter selected:', segment);
        if (window.tableState && window.tableState.filters) {
            window.tableState.filters.pick.segment = (segment === 'all') ? '' : segment;
        }
        applyFilters();
    }
    function handleSearchFilter(query) {
        debug('Search query:', query);
        if (window.tableState && window.tableState.filters) {
            window.tableState.filters.search = query.toLowerCase();
        }
        applyFilters();
    }
    function applyFilters() {
        if (window.PicksFilterManager && window.PicksFilterManager.applyFilters) {
            window.PicksFilterManager.applyFilters();
        } else if (window.TableFilters && window.TableFilters.applyFilters) {
            window.TableFilters.applyFilters();
        }
    }
    function debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
})();
(function() {
    'use strict';
    const debug = (...args) => {
        console.log('🔍 [Filters]', ...args);
    };
    if (typeof window.tableState === 'undefined') {
        window.tableState = {
            filters: {
                date: {
                    start: null,
                    end: null,
                    selectedDates: null,
                    selectedTimes: null,
                    selectedBooks: null,
                    activeRange: 'all' 
                },
                matchup: { league: '', selectedTeams: null, ticketType: 'all' },
                pick: { betType: '', subtype: '', segment: '' },
                risk: { min: null, max: null, selectedRiskRanges: [], selectedWinRanges: [] },
                status: []
            },
            sort: { column: null, direction: 'asc' }
        };
    }
    const CONFIG = {
        DATE_GROUP_MAP: {
            dates: 'selectedDates',
            times: 'selectedTimes',
            books: 'selectedBooks'
        },
        DATE_GROUP_LABELS: {
            dates: 'Dates',
            times: 'Times',
            books: 'Sportsbooks'
        },
        STATUS_NORMALIZE_MAP: {
            'pending': 'pending',
            'live': 'live',
            'on-track': 'on-track',
            'on track': 'on-track',
            'ontrack': 'on-track',
            'at-risk': 'at-risk',
            'at risk': 'at-risk',
            'atrisk': 'at-risk',
            'win': 'win',
            'winner': 'win',
            'won': 'win',
            'loss': 'loss',
            'lost': 'loss',
            'loser': 'loss',
            'push': 'push',
            'tie': 'push'
        },
        LEAGUE_LABELS: {
            'nfl': 'NFL', 'nba': 'NBA', 'ncaaf': 'NCAAF', 'ncaab': 'NCAAB',
            'mlb': 'MLB', 'nhl': 'NHL', 'mls': 'MLS', 'epl': 'EPL'
        }
    };
    function normalizeFilterValue(value) {
        return (value ?? '').toString().trim().toLowerCase();
    }
    function normalizeStatus(status) {
        const key = normalizeFilterValue(status);
        return CONFIG.STATUS_NORMALIZE_MAP[key] || key;
    }
    function escapeHtml(str) {
        if (!str) return '';
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
    }
    function parseRangeBound(attr, fallback) {
        if (attr === undefined || attr === null || attr === '') return fallback;
        if (attr === 'inf') return Number.POSITIVE_INFINITY;
        const parsed = parseFloat(attr);
        return Number.isNaN(parsed) ? fallback : parsed;
    }
    function ensureDateFilterShape() {
        const filters = window.tableState.filters;
        if (!filters.date || typeof filters.date !== 'object') {
            filters.date = createDateFilterState();
            return;
        }
        const df = filters.date;
        if (!('start' in df)) df.start = null;
        if (!('end' in df)) df.end = null;
        if (!('selectedDates' in df)) df.selectedDates = null;
        if (!('selectedTimes' in df)) df.selectedTimes = null;
        if (!('selectedBooks' in df)) df.selectedBooks = null;
        if (!('activeRange' in df)) df.activeRange = 'all';
    }
    function createDateFilterState() {
        return {
            start: null, end: null,
            selectedDates: null, selectedTimes: null, selectedBooks: null,
            activeRange: 'all'
        };
    }
    function ensureMatchupFilterShape() {
        const filters = window.tableState.filters;
        if (!filters.matchup || typeof filters.matchup !== 'object') {
            filters.matchup = { league: '', selectedTeams: null, ticketType: 'all' };
            return;
        }
        if (!('ticketType' in filters.matchup)) filters.matchup.ticketType = 'all';
        if (!('selectedTeams' in filters.matchup)) filters.matchup.selectedTeams = null;
        if (!('league' in filters.matchup)) filters.matchup.league = '';
    }
    function ensureRiskFilterShape() {
        const filters = window.tableState.filters;
        if (!filters.risk || typeof filters.risk !== 'object') {
            filters.risk = { min: null, max: null, selectedRiskRanges: [], selectedWinRanges: [] };
            return;
        }
        const rf = filters.risk;
        if (!('min' in rf)) rf.min = null;
        if (!('max' in rf)) rf.max = null;
        if (!Array.isArray(rf.selectedRiskRanges)) rf.selectedRiskRanges = [];
        if (!Array.isArray(rf.selectedWinRanges)) rf.selectedWinRanges = [];
    }
    ensureDateFilterShape();
    ensureMatchupFilterShape();
    ensureRiskFilterShape();
    function getDateTimeParts(row) {
        const datetimeCell = row.querySelector('.datetime-cell');
        const cell = datetimeCell || row.querySelector('td[data-label="Date & Time"]');
        if (!cell) {
            debug('No date/time cell found in row');
            return { dateText: '', timeText: '', sportsbookText: '' };
        }
        const dateEl = cell.querySelector('.cell-date') || cell.querySelector('.date-value');
        const timeEl = cell.querySelector('.cell-time') || cell.querySelector('.time-value');
        const bookEl = cell.querySelector('.sportsbook-value');
        const result = {
            dateText: dateEl?.textContent?.trim() || '',
            timeText: timeEl?.textContent?.trim() || '',
            sportsbookText: bookEl?.textContent?.trim() || ''
        };
        if (window._dateTimeDebugCount === undefined) window._dateTimeDebugCount = 0;
        if (window._dateTimeDebugCount < 3) {
            console.log('📅 getDateTimeParts result:', result);
            window._dateTimeDebugCount++;
        }
        return result;
    }
    function getDateValue(row) {
        const epoch = row.getAttribute('data-epoch');
        if (epoch) return new Date(parseInt(epoch, 10));
        const { dateText } = getDateTimeParts(row);
        if (dateText) return new Date(dateText);
        return null;
    }
    function getStatusKey(row) {
        const statusAttr = row.getAttribute('data-status');
        if (statusAttr) return normalizeStatus(statusAttr);
        const badge = row.querySelector('.status-badge');
        if (badge) {
            const badgeStatus = badge.getAttribute('data-status');
            if (badgeStatus) return normalizeStatus(badgeStatus);
            return normalizeStatus(badge.textContent);
        }
        return '';
    }
    function getPickValue(row) {
        const pickCell = row.querySelector('.pick-cell');
        if (!pickCell) return '';
        return pickCell.textContent?.trim() || '';
    }
    function getSegmentFromRow(row) {
        const segAttr = row.getAttribute('data-segment');
        if (segAttr) return segAttr.toLowerCase();
        const segCell = row.querySelector('.game-segment');
        if (segCell) {
            const text = segCell.textContent?.trim().toLowerCase() || '';
            if (text.includes('full')) return 'full-game';
            if (text.includes('1h') || text.includes('first half')) return '1h';
            if (text.includes('2h') || text.includes('second half')) return '2h';
            if (text.includes('multi')) return 'multi';
            return text;
        }
        return '';
    }
    function getRiskValue(row) {
        const riskAttr = row.getAttribute('data-risk');
        if (riskAttr) return parseFloat(riskAttr) || 0;
        const riskEl = row.querySelector('.risk-amount');
        if (riskEl) {
            const text = riskEl.textContent?.replace(/[$,]/g, '') || '0';
            return parseFloat(text) || 0;
        }
        return 0;
    }
    function getWinValue(row) {
        const winAttr = row.getAttribute('data-win');
        if (winAttr) return parseFloat(winAttr) || 0;
        const winEl = row.querySelector('.win-amount');
        if (winEl) {
            const text = winEl.textContent?.replace(/[$,]/g, '') || '0';
            return parseFloat(text) || 0;
        }
        return 0;
    }
    function valueMatchesRangeList(ranges, value) {
        if (!Array.isArray(ranges) || !ranges.length) return true;
        return ranges.some(range => {
            const min = typeof range.min === 'number' ? range.min : 0;
            const max = typeof range.max === 'number' ? range.max : Number.POSITIVE_INFINITY;
            return value >= min && value <= max;
        });
    }
    function passesAllFilters(row) {
        const filters = window.tableState.filters;
        if (filters.date) {
            const df = filters.date;
            const { dateText, timeText, sportsbookText } = getDateTimeParts(row);
            if (Array.isArray(df.selectedDates) && df.selectedDates.length > 0) {
                const normalizedDate = normalizeFilterValue(dateText);
                const passes = df.selectedDates.includes(normalizedDate);
                if (!passes) {
                    debug(`Date filter failed: "${dateText}" (normalized: "${normalizedDate}") not in`, df.selectedDates);
                    return false;
                }
            }
            if (Array.isArray(df.selectedTimes) && df.selectedTimes.length > 0) {
                const normalizedTime = normalizeFilterValue(timeText);
                const passes = df.selectedTimes.includes(normalizedTime);
                if (!passes) {
                    debug(`Time filter failed: "${timeText}" (normalized: "${normalizedTime}") not in`, df.selectedTimes);
                    return false;
                }
            }
            if (Array.isArray(df.selectedBooks) && df.selectedBooks.length > 0) {
                const normalizedBook = normalizeFilterValue(sportsbookText);
                const passes = df.selectedBooks.includes(normalizedBook);
                if (!passes) {
                    debug(`Book filter failed: "${sportsbookText}" (normalized: "${normalizedBook}") not in`, df.selectedBooks);
                    return false;
                }
            }
            if (df.start || df.end) {
                const rowDate = getDateValue(row);
                if (rowDate) {
                    if (df.start && rowDate < df.start) return false;
                    if (df.end && rowDate > df.end) return false;
                }
            }
        }
        const mf = filters.matchup;
        if (mf && (mf.league || mf.selectedTeams || (mf.ticketType && mf.ticketType !== 'all'))) {
            const rowLeague = (row.getAttribute('data-league') || '').toLowerCase();
            const awayTeam = (row.getAttribute('data-away') || '').toLowerCase();
            const homeTeam = (row.getAttribute('data-home') || '').toLowerCase();
            const rowPickType = (row.getAttribute('data-pick-type') || '').toLowerCase();
            if (mf.league && rowLeague !== mf.league) return false;
            if (mf.selectedTeams && mf.selectedTeams.length > 0) {
                const selectedSet = new Set(mf.selectedTeams);
                if (!selectedSet.has(awayTeam) && !selectedSet.has(homeTeam)) return false;
            }
            if (mf.ticketType && mf.ticketType !== 'all') {
                if (mf.ticketType === 'straight' && rowPickType === 'parlay') return false;
                if (mf.ticketType === 'multi' && rowPickType !== 'parlay') return false;
                if (mf.ticketType === 'props' && rowPickType !== 'prop') return false;
            }
        }
        const pf = filters.pick;
        if (pf && (pf.betType || pf.subtype || pf.segment)) {
            const rowType = (row.getAttribute('data-pick-type') || '').toLowerCase();
            const rowSeg = getSegmentFromRow(row);
            const pickText = getPickValue(row).toLowerCase();
            if (pf.betType && pf.betType !== 'all') {
                if (rowType !== pf.betType) return false;
            }
            if (pf.segment && pf.segment !== 'all') {
                if (pf.segment === 'multi' && rowSeg !== 'multi') return false;
                else if (pf.segment !== 'multi' && rowSeg !== pf.segment) return false;
            }
            if (pf.subtype) {
                if (!pickText.includes(pf.subtype)) return false;
            }
        }
        const rf = filters.risk;
        if (rf) {
            const riskVal = getRiskValue(row);
            const winVal = getWinValue(row);
            if (rf.selectedRiskRanges && rf.selectedRiskRanges.length > 0) {
                if (!valueMatchesRangeList(rf.selectedRiskRanges, riskVal)) return false;
            }
            if (rf.selectedWinRanges && rf.selectedWinRanges.length > 0) {
                if (!valueMatchesRangeList(rf.selectedWinRanges, winVal)) return false;
            }
            if (rf.min !== null && riskVal < rf.min) return false;
            if (rf.max !== null && riskVal > rf.max) return false;
        }
        if (filters.status && filters.status.length > 0) {
            const rowStatus = getStatusKey(row);
            const normalizedStatuses = filters.status.map(normalizeStatus);
            if (!normalizedStatuses.includes(rowStatus)) return false;
        }
        return true;
    }
    function calculateDateRange(range, customStart = null, customEnd = null) {
        const now = new Date();
        let start = null, end = null;
        switch (range) {
            case 'today':
                start = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                end = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59, 999);
                break;
            case 'week':
                const dayOfWeek = now.getDay();
                start = new Date(now);
                start.setDate(now.getDate() - dayOfWeek);
                start.setHours(0, 0, 0, 0);
                end = new Date(start);
                end.setDate(start.getDate() + 6);
                end.setHours(23, 59, 59, 999);
                break;
            case 'month':
                start = new Date(now.getFullYear(), now.getMonth(), 1);
                end = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59, 999);
                break;
            case 'custom':
                start = customStart;
                end = customEnd;
                break;
            case 'all':
            default:
                start = null;
                end = null;
                break;
        }
        return { start, end };
    }
    function setDateRange(range, customStart = null, customEnd = null) {
        const { start, end } = calculateDateRange(range, customStart, customEnd);
        window.tableState.filters.date.start = start;
        window.tableState.filters.date.end = end;
        window.tableState.filters.date.activeRange = range;
        debug('Date range set:', range, { start, end });
    }
    function applyFiltersToTable() {
        console.log('🎯 TableFilters.applyFiltersToTable() called');
        const tbody = document.getElementById('picks-tbody');
        if (!tbody) {
            console.error('❌ picks-tbody not found');
            return;
        }
        const rows = Array.from(tbody.querySelectorAll('tr:not(.parlay-legs)'));
        console.log(`📊 Processing ${rows.length} table rows`);
        let visibleCount = 0;
        let hiddenCount = 0;
        rows.forEach((row, index) => {
            const shouldShow = passesAllFilters(row);
            if (index < 3) {
                const { dateText, timeText, sportsbookText } = getDateTimeParts(row);
                console.log(`Row ${index}: Date="${dateText}", Time="${timeText}", Book="${sportsbookText}", Show=${shouldShow}`);
            }
            if (shouldShow) {
                row.style.display = '';
                visibleCount++;
                const legsRow = row.nextElementSibling;
                if (legsRow && legsRow.classList.contains('parlay-legs')) {
                    const isExpanded = row.getAttribute('aria-expanded') === 'true';
                    legsRow.style.display = isExpanded ? 'table-row' : 'none';
                }
            } else {
                row.style.display = 'none';
                hiddenCount++;
                const legsRow = row.nextElementSibling;
                if (legsRow && legsRow.classList.contains('parlay-legs')) {
                    legsRow.style.display = 'none';
                    row.setAttribute('aria-expanded', 'false');
                }
            }
        });
        console.log(`✅ Filter results: ${visibleCount} visible, ${hiddenCount} hidden`);
        if (window.ZebraStripes?.debouncedApply) {
            window.ZebraStripes.debouncedApply();
        } else if (window.__gbsvApplyZebraStripes) {
            window.__gbsvApplyZebraStripes();
        }
        renderFilterChips();
        updateFilterIndicators();
        announceFilterChange('Filters applied');
        debug('Filters applied to', rows.length, 'rows');
    }
    function updateFilterIndicators() {
        const filters = window.tableState.filters;
        const dateHeader = document.querySelector('th.date-time-header');
        if (dateHeader) {
            const hasFilter = filters.date && (
                filters.date.selectedDates?.length > 0 ||
                filters.date.selectedTimes?.length > 0 ||
                filters.date.selectedBooks?.length > 0 ||
                filters.date.start || filters.date.end
            );
            dateHeader.classList.toggle('has-active-filter', !!hasFilter);
        }
        const matchupHeader = document.querySelector('th.matchup-header');
        if (matchupHeader) {
            const hasFilter = filters.matchup && (
                filters.matchup.league ||
                filters.matchup.selectedTeams ||
                (filters.matchup.ticketType && filters.matchup.ticketType !== 'all')
            );
            matchupHeader.classList.toggle('has-active-filter', !!hasFilter);
        }
        const pickHeader = document.querySelector('th.pick-header');
        if (pickHeader) {
            const hasFilter = filters.pick?.betType || filters.pick?.subtype;
            pickHeader.classList.toggle('has-active-filter', !!hasFilter);
        }
        const segmentHeader = document.querySelector('th.segment-header');
        if (segmentHeader) {
            segmentHeader.classList.toggle('has-active-filter', !!filters.pick?.segment);
        }
        const riskHeader = document.querySelector('th.risk-win-header');
        if (riskHeader) {
            const rf = filters.risk || {};
            const hasFilter = rf.min != null || rf.max != null ||
                (Array.isArray(rf.selectedRiskRanges) && rf.selectedRiskRanges.length > 0) ||
                (Array.isArray(rf.selectedWinRanges) && rf.selectedWinRanges.length > 0);
            riskHeader.classList.toggle('has-active-filter', !!hasFilter);
        }
        const statusHeader = document.querySelector('th.status-header');
        if (statusHeader) {
            statusHeader.classList.toggle('has-active-filter', filters.status?.length > 0);
        }
    }
    const currencyFormatter = new Intl.NumberFormat('en-US', {
        style: 'currency', currency: 'USD', maximumFractionDigits: 0
    });
    function formatDateForChip(dateObj) {
        if (!(dateObj instanceof Date) || isNaN(dateObj)) return '';
        return dateObj.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    }
    function formatSelectionLabel(values, label) {
        if (!Array.isArray(values) || values.length === 0) return '';
        if (values.length <= 3) return `${label}: ${values.join(', ')}`;
        return `${label}: ${values.length} selected`;
    }
    function renderFilterChips() {
        const container = document.getElementById('table-filter-chips');
        if (!container) return;
        const chips = [];
        const filters = window.tableState.filters;
        const df = filters.date || {};
        const dateParts = [];
        if (df.selectedDates?.length) dateParts.push(formatSelectionLabel(df.selectedDates, 'Dates'));
        if (df.selectedTimes?.length) dateParts.push(formatSelectionLabel(df.selectedTimes, 'Times'));
        if (df.selectedBooks?.length) dateParts.push(formatSelectionLabel(df.selectedBooks, 'Books'));
        if (dateParts.length) {
            chips.push({ type: 'date', label: dateParts.join(' • ') });
        } else if (df.start || df.end) {
            let label = df.activeRange !== 'custom' && df.activeRange !== 'all'
                ? df.activeRange.charAt(0).toUpperCase() + df.activeRange.slice(1)
                : '';
            if (!label && df.start && df.end) {
                label = `${formatDateForChip(df.start)} – ${formatDateForChip(df.end)}`;
            }
            if (label) chips.push({ type: 'date', label: `Date: ${label}` });
        }
        const mf = filters.matchup;
        if (mf && (mf.league || mf.selectedTeams || (mf.ticketType && mf.ticketType !== 'all'))) {
            const parts = [];
            if (mf.league) parts.push(CONFIG.LEAGUE_LABELS[mf.league] || mf.league.toUpperCase());
            if (mf.selectedTeams?.length > 0) {
                parts.push(mf.selectedTeams.length <= 2 
                    ? mf.selectedTeams.map(t => t.charAt(0).toUpperCase() + t.slice(1)).join(', ')
                    : `${mf.selectedTeams.length} teams`);
            }
            if (mf.ticketType && mf.ticketType !== 'all') {
                const labels = { 'straight': 'Straight', 'multi': 'Parlay', 'props': 'Props' };
                parts.push(labels[mf.ticketType] || mf.ticketType);
            }
            if (parts.length) chips.push({ type: 'matchup', label: `Matchup: ${parts.join(' • ')}` });
        }
        const pf = filters.pick;
        if (pf?.betType) {
            const labels = { 'spread': 'Spread', 'moneyline': 'ML', 'total': 'O/U', 'team-total': 'TT' };
            chips.push({ type: 'pick', label: `Pick: ${labels[pf.betType] || pf.betType}` });
        }
        if (pf?.segment) {
            const labels = { 'full-game': 'Full Game', '1h': '1H', '2h': '2H', 'multi': 'Parlay' };
            chips.push({ type: 'segment', label: `Segment: ${labels[pf.segment] || pf.segment}` });
        }
        const rf = filters.risk;
        if (rf?.selectedRiskRanges?.length || rf?.selectedWinRanges?.length) {
            const parts = [];
            if (rf.selectedRiskRanges?.length) parts.push(`Risk: ${rf.selectedRiskRanges.length} ranges`);
            if (rf.selectedWinRanges?.length) parts.push(`Win: ${rf.selectedWinRanges.length} ranges`);
            chips.push({ type: 'risk', label: parts.join(' • ') });
        }
        if (filters.status?.length) {
            const labels = filters.status.map(s => s.charAt(0).toUpperCase() + s.slice(1));
            chips.push({ type: 'status', label: `Status: ${labels.join(', ')}` });
        }
        container.innerHTML = '';
        container.setAttribute('data-has-chips', chips.length > 0 ? 'true' : 'false');
        chips.forEach(chip => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'filter-chip-btn';
            btn.textContent = chip.label;
            btn.setAttribute('aria-label', `Remove ${chip.label} filter`);
            btn.addEventListener('click', () => clearFilterByType(chip.type));
            container.appendChild(btn);
        });
    }
    function clearFilterByType(type) {
        const filters = window.tableState.filters;
        switch (type) {
            case 'date':
                filters.date = createDateFilterState();
                resetDateToggleUI();
                resetDateFilterDropdownUI();
                break;
            case 'matchup':
                filters.matchup = { league: '', selectedTeams: null, ticketType: 'all' };
                resetMatchupFilterUI();
                break;
            case 'pick':
                filters.pick.betType = '';
                filters.pick.subtype = '';
                resetPickFilterUI();
                break;
            case 'segment':
                filters.pick.segment = '';
                resetSegmentFilterUI();
                break;
            case 'risk':
                filters.risk = { min: null, max: null, selectedRiskRanges: [], selectedWinRanges: [] };
                resetRiskFilterUI();
                break;
            case 'status':
                filters.status = [];
                resetStatusFilterUI();
                break;
        }
        applyFiltersToTable();
        debug('Cleared filter:', type);
    }
    function clearAllFilters() {
        window.tableState.filters = {
            date: createDateFilterState(),
            matchup: { league: '', selectedTeams: null, ticketType: 'all' },
            pick: { betType: '', subtype: '', segment: '' },
            risk: { min: null, max: null, selectedRiskRanges: [], selectedWinRanges: [] },
            status: []
        };
        resetAllFilterUIs();
        applyFiltersToTable();
        debug('All filters cleared');
    }
    function resetDateToggleUI() {
        const buttons = document.querySelectorAll('.date-toggle-btn');
        buttons.forEach(btn => btn.classList.remove('active'));
        const allBtn = document.querySelector('.date-toggle-btn[data-range="all"]');
        if (allBtn) allBtn.classList.add('active');
        const customRange = document.querySelector('.custom-date-range');
        if (customRange) customRange.classList.remove('active');
    }
    function resetDateFilterDropdownUI() {
        const dropdown = document.getElementById('filter-date');
        if (!dropdown) return;
        dropdown.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = true);
        const selectAll = dropdown.querySelector('#filter-date-select-all');
        if (selectAll) {
            selectAll.checked = true;
            selectAll.indeterminate = false;
        }
    }
    function resetMatchupFilterUI() {
        const leagueSelect = document.getElementById('matchup-league-select');
        if (leagueSelect) leagueSelect.value = '';
        document.querySelectorAll('input[name="matchup-ticket-type"]').forEach(r => {
            r.checked = r.value === 'all';
        });
        const teamsCard = document.getElementById('matchup-teams-card');
        if (teamsCard) teamsCard.setAttribute('data-visible', 'false');
        const selectAll = document.getElementById('filter-matchup-select-all');
        if (selectAll) { selectAll.checked = true; selectAll.indeterminate = false; }
    }
    function resetPickFilterUI() {
        document.querySelectorAll('input[name="pick-bet-type"]').forEach(r => {
            r.checked = r.value === 'all';
        });
    }
    function resetSegmentFilterUI() {
        document.querySelectorAll('input[name="segment-select"]').forEach(r => {
            r.checked = r.value === 'all';
        });
    }
    function resetRiskFilterUI() {
        document.querySelectorAll('input[name="risk-range"], input[name="win-range"]').forEach(cb => {
            cb.checked = false;
        });
    }
    function resetStatusFilterUI() {
        document.querySelectorAll('input[name="status-filter"]').forEach(cb => {
            cb.checked = false;
        });
    }
    function resetAllFilterUIs() {
        resetDateToggleUI();
        resetDateFilterDropdownUI();
        resetMatchupFilterUI();
        resetPickFilterUI();
        resetSegmentFilterUI();
        resetRiskFilterUI();
        resetStatusFilterUI();
    }
    function announceFilterChange(message) {
        const container = document.getElementById('table-filter-chips');
        if (container) {
            container.setAttribute('aria-label', message);
        }
    }
    window.TableFilters = {
        getState: () => window.tableState.filters,
        passesAllFilters,
        applyFilters: applyFiltersToTable,
        clearFilter: clearFilterByType,
        clearAll: clearAllFilters,
        setDateRange,
        calculateDateRange,
        ensureDateFilterShape,
        ensureMatchupFilterShape,
        ensureRiskFilterShape,
        normalizeFilterValue,
        normalizeStatus,
        getDateTimeParts,
        getStatusKey,
        getPickValue,
        getSegmentFromRow,
        getRiskValue,
        getWinValue,
        updateFilterIndicators,
        renderFilterChips,
        CONFIG
    };
    window.updateTableWithFilters = applyFiltersToTable;
    window.passesAllFilters = passesAllFilters;
    window.updateFilterIndicators = updateFilterIndicators;
    window.renderFilterChips = renderFilterChips;
    debug('TableFilters module loaded');
})();
(function() {
    'use strict';
    let zebraTimeout = null;
    const DEBOUNCE_DELAY = 50; 
    function isRowVisibleForZebra(row) {
        if (!row) return false;
        if (row.style.display === 'none') return false;
        if (row.hasAttribute('hidden') || row.getAttribute('aria-hidden') === 'true') return false;
        if (row.classList.contains('is-hidden') || row.classList.contains('hidden')) return false;
        if (typeof window !== 'undefined' && typeof window.getComputedStyle === 'function') {
            const computed = window.getComputedStyle(row);
            if (!computed) return false;
            if (computed.display === 'none' || computed.visibility === 'hidden') return false;
        }
        return true;
    }
    function getDirectChildRows(tbody) {
        if (!tbody) return [];
        return Array.from(tbody.children).filter(node => node && node.tagName === 'TR');
    }
    function getParentRowsOnly(tbody) {
        return getDirectChildRows(tbody).filter(row => !row.classList.contains('parlay-legs'));
    }
    function findParlayLegsRow(parentRow) {
        if (!parentRow) return null;
        const rowId = parentRow.getAttribute('data-row-id');
        if (rowId) {
            const byId = document.querySelector(`tr.parlay-legs[data-parent-id="${rowId}"]`);
            if (byId) return byId;
        }
        const nextSibling = parentRow.nextElementSibling;
        if (nextSibling && nextSibling.classList.contains('parlay-legs')) {
            return nextSibling;
        }
        return null;
    }
    let cachedTbody = null;
    let lastTbodyCheck = 0;
    const TBODY_CACHE_TIME = 1000; 
    function applyPicksTableZebraStripes(forceTbody) {
        let tbody = forceTbody;
        if (!tbody) {
            const now = Date.now();
            if (!cachedTbody || now - lastTbodyCheck > TBODY_CACHE_TIME) {
                cachedTbody = document.getElementById('picks-tbody') || document.querySelector('.picks-table tbody');
                lastTbodyCheck = now;
            }
            tbody = cachedTbody;
        }
        if (!tbody) return 0;
        const zebraClasses = ['zebra-row', 'zebra-odd', 'zebra-even'];
        tbody.querySelectorAll('.zebra-row, .zebra-odd, .zebra-even').forEach(row => {
            zebraClasses.forEach(cls => row.classList.remove(cls));
        });
        const parentRows = getDirectChildRows(tbody).filter(row => {
            if (!row) return false;
            if (row.classList.contains('parlay-legs')) return false;
            if (row.dataset && row.dataset.zebraIgnore === 'true') return false;
            return true;
        });
        const applyLegTableStripes = (legsRow) => {
            if (!legsRow) return;
            let legRows = legsRow.querySelectorAll('.compact-leg-table tbody tr');
            if (!legRows.length) {
                const allRows = legsRow.querySelectorAll('.compact-leg-table tr');
                legRows = Array.from(allRows).filter(tr => !tr.closest('thead'));
            }
            if (!legRows.length) return;
            legRows.forEach((legRow, legIndex) => {
                zebraClasses.forEach(cls => legRow.classList.remove(cls));
                const legClass = legIndex % 2 === 0 ? 'zebra-odd' : 'zebra-even';
                legRow.classList.add('zebra-row', legClass);
            });
        };
        let visibleIndex = 0;
        parentRows.forEach(row => {
            if (!isRowVisibleForZebra(row)) {
                return;
            }
            const zebraClass = visibleIndex % 2 === 0 ? 'zebra-odd' : 'zebra-even';
            row.classList.add('zebra-row', zebraClass);
            visibleIndex += 1;
            if (row.classList.contains('parlay-row')) {
                const legsRow = findParlayLegsRow(row);
                if (legsRow) {
                    const legsVisible = isRowVisibleForZebra(legsRow);
                    if (legsVisible) {
                        const legsZebraClass = visibleIndex % 2 === 0 ? 'zebra-odd' : 'zebra-even';
                        legsRow.classList.add('zebra-row', legsZebraClass);
                        applyLegTableStripes(legsRow);
                        visibleIndex += 1;
                    } else {
                        legsRow.classList.add('zebra-row', zebraClass);
                    }
                }
            }
        });
        return visibleIndex;
    }
    function debouncedApplyZebraStripes(customDelay) {
        const delay = customDelay || DEBOUNCE_DELAY;
        clearTimeout(zebraTimeout);
        zebraTimeout = setTimeout(() => {
            applyPicksTableZebraStripes();
        }, delay);
    }
    function applyZebraStripesNow() {
        clearTimeout(zebraTimeout);
        applyPicksTableZebraStripes();
    }
    window.ZebraStripes = {
        isRowVisibleForZebra,
        getDirectChildRows,
        getParentRowsOnly,
        findParlayLegsRow,
        applyPicksTableZebraStripes,
        debouncedApply: debouncedApplyZebraStripes,
        applyNow: applyZebraStripesNow,
        DEBOUNCE_DELAY
    };
    window.__gbsvApplyZebraStripes = applyPicksTableZebraStripes;
    window.getDirectChildRows = getDirectChildRows;
    window.getParentRowsOnly = getParentRowsOnly;
    window.findParlayLegsRow = findParlayLegsRow;
    if (typeof document !== 'undefined') {
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', applyPicksTableZebraStripes);
        } else {
            try {
                applyPicksTableZebraStripes();
            } catch (_) {
            }
        }
    }
    console.log('✅ zebra-stripes.js loaded');
})();
(function() {
    'use strict';
    const SPORTSDATAIO_API_KEY = window.APP_CONFIG?.SPORTSDATAIO?.API_KEY || '';
    const todayISO = new Date().toISOString().split('T')[0];
    const todayESPN = todayISO.replace(/-/g, '');
    let todaysGamesCache = null;
    let teamRecordsCache = {};  
    let lastFetch = null;
    async function fetchSportsDataIO(sport) {
        if (!SPORTSDATAIO_API_KEY) {
            console.warn(`[AUTO-GAME-FETCHER] Missing SportsDataIO API key, skipping ${sport} fetch.`);
            return [];
        }
        const todaySportsDataIO = todayISO.replace(/-/g, '-').toUpperCase();
        const url = `https://api.sportsdata.io/v4/${sport}/scores/json/ScoresByDate/${todaySportsDataIO}`;
        const response = await fetch(url, {
            headers: {
                'Ocp-Apim-Subscription-Key': SPORTSDATAIO_API_KEY
            }
        });
        if (!response.ok) {
            throw new Error(`SportsDataIO ${sport} API error: ${response.status}`);
        }
        return await response.json();
    }
    async function fetchStandings(sport) {
        const sportPath = sport === 'NBA' ? 'nba' :
                         sport === 'NFL' ? 'nfl' :
                         sport === 'NCAAM' ? 'mens-college-basketball' :
                         sport === 'NCAAF' ? 'college-football' : null;
        if (!sportPath) return;
        const sportCategory = sport === 'NBA' || sport === 'NCAAM' ? 'basketball' : 'football';
        const url = `https://site.api.espn.com/apis/v2/sports/${sportCategory}/${sportPath}/standings`;
        try {
            console.log(`[AUTO-GAME-FETCHER] Fetching ${sport} standings...`);
            const response = await fetch(url);
            if (!response.ok) return;
            const data = await response.json();
            const conferences = data.children || [];
            for (const conf of conferences) {
                const entries = conf.standings?.entries || [];
                for (const entry of entries) {
                    const teamName = entry.team?.displayName;
                    if (!teamName) continue;
                    const stats = entry.stats || [];
                    const winsObj = stats.find(s => s.name === 'wins');
                    const lossesObj = stats.find(s => s.name === 'losses');
                    const wins = winsObj?.displayValue || winsObj?.value || '0';
                    const losses = lossesObj?.displayValue || lossesObj?.value || '0';
                    teamRecordsCache[teamName.toLowerCase()] = `${wins}-${losses}`;
                }
            }
            console.log(`[AUTO-GAME-FETCHER] Loaded ${Object.keys(teamRecordsCache).length} team records for ${sport}`);
        } catch (e) {
            console.warn(`[AUTO-GAME-FETCHER] Could not fetch ${sport} standings:`, e.message);
        }
    }
    function getTeamRecord(teamName) {
        if (!teamName) return '';
        const lower = teamName.toLowerCase();
        return teamRecordsCache[lower] || '';
    }
    async function fetchESPN(sport) {
        const sportPath = sport === 'NCAAM' ? 'mens-college-basketball' :
                         sport === 'NBA' ? 'nba' :
                         sport === 'NCAAF' ? 'college-football' :
                         sport === 'NFL' ? 'nfl' : null;
        if (!sportPath) throw new Error('Unknown sport');
        const sportCategory = sport === 'NBA' || sport === 'NCAAM' ? 'basketball' : 'football';
        const dateStr = todayESPN;
        const url = `https://site.api.espn.com/apis/site/v2/sports/${sportCategory}/${sportPath}/scoreboard?dates=${dateStr}`;
        console.log(`[AUTO-GAME-FETCHER] Fetching ${sport} from: ${url}`);
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`ESPN ${sport} API error: ${response.status}`);
        }
        return await response.json();
    }
    function parseESPNGames(data, sport) {
        if (!data || !data.events || data.events.length === 0) {
            return [];
        }
        return data.events
            .map(event => {
                const competition = event.competitions?.[0];
                const competitors = competition?.competitors || [];
                const homeTeam = competitors.find(t => t.homeAway === 'home');
                const awayTeam = competitors.find(t => t.homeAway === 'away');
                if (!competition || !homeTeam || !awayTeam) {
                    return null;
                }
                const status = competition.status || event.status || {};
                const statusType = status.type || {};
                const awayTeamName = awayTeam.team.displayName;
                const homeTeamName = homeTeam.team.displayName;
                return {
                    sport,
                    date: todayISO,
                    time: new Date(event.date).toLocaleTimeString('en-US', {
                        hour: 'numeric',
                        minute: '2-digit',
                        hour12: true
                    }),
                    awayTeam: awayTeamName,
                    homeTeam: homeTeamName,
                    awayRecord: getTeamRecord(awayTeamName),
                    homeRecord: getTeamRecord(homeTeamName),
                    awayScore: parseInt(awayTeam.score, 10) || 0,
                    homeScore: parseInt(homeTeam.score, 10) || 0,
                    status: statusType.description || statusType.name || 'Scheduled',
                    statusDetail: statusType.detail || '',
                    gameId: event.id,
                    channel: competition.broadcasts?.[0]?.names?.[0] || 'TBD'
                };
            })
            .filter(Boolean);
    }
    async function fetchTodaysGames(forceRefresh = false) {
        if (!forceRefresh && todaysGamesCache && lastFetch && (Date.now() - lastFetch < 60000)) {
            return todaysGamesCache;
        }
        console.log('[AUTO-GAME-FETCHER] Fetching team standings for records...');
        await Promise.all([
            fetchStandings('NBA'),
            fetchStandings('NFL'),
            fetchStandings('NCAAM'),
            fetchStandings('NCAAF')
        ]);
        const allGames = [];
        try {
            console.log('[AUTO-GAME-FETCHER] Fetching NCAAM games...');
            const ncaamData = await fetchESPN('NCAAM');
            const ncaamGames = parseESPNGames(ncaamData, 'NCAAM');
            allGames.push(...ncaamGames);
            console.log(`[AUTO-GAME-FETCHER] Found ${ncaamGames.length} NCAAM games`);
        } catch (e) {
            console.error('[AUTO-GAME-FETCHER] Error fetching NCAAM:', e.message);
        }
        try {
            console.log('[AUTO-GAME-FETCHER] Fetching NBA games...');
            const nbaData = await fetchESPN('NBA');
            const nbaGames = parseESPNGames(nbaData, 'NBA');
            allGames.push(...nbaGames);
            console.log(`[AUTO-GAME-FETCHER] Found ${nbaGames.length} NBA games`);
        } catch (e) {
            console.error('[AUTO-GAME-FETCHER] Error fetching NBA:', e.message);
        }
        try {
            console.log('[AUTO-GAME-FETCHER] Fetching NFL games...');
            const nflData = await fetchESPN('NFL');
            const nflGames = parseESPNGames(nflData, 'NFL');
            allGames.push(...nflGames);
            console.log(`[AUTO-GAME-FETCHER] Found ${nflGames.length} NFL games`);
        } catch (e) {
            console.error('[AUTO-GAME-FETCHER] Error fetching NFL:', e.message);
        }
        try {
            console.log('[AUTO-GAME-FETCHER] Fetching NCAAF games...');
            const ncaafData = await fetchESPN('NCAAF');
            const ncaafGames = parseESPNGames(ncaafData, 'NCAAF');
            allGames.push(...ncaafGames);
            console.log(`[AUTO-GAME-FETCHER] Found ${ncaafGames.length} NCAAF games`);
        } catch (e) {
            console.error('[AUTO-GAME-FETCHER] Error fetching NCAAF:', e.message);
        }
        todaysGamesCache = allGames;
        lastFetch = Date.now();
        console.log(`[AUTO-GAME-FETCHER] Total games today: ${allGames.length}`);
        return allGames;
    }
    function findGame(teamName1, teamName2) {
        if (!todaysGamesCache) return null;
        const name1Lower = teamName1.toLowerCase();
        const name2Lower = teamName2 ? teamName2.toLowerCase() : null;
        return todaysGamesCache.find(game => {
            const awayLower = game.awayTeam.toLowerCase();
            const homeLower = game.homeTeam.toLowerCase();
            if (name2Lower) {
                return (awayLower.includes(name1Lower) && homeLower.includes(name2Lower)) ||
                       (awayLower.includes(name2Lower) && homeLower.includes(name1Lower));
            }
            return awayLower.includes(name1Lower) || homeLower.includes(name1Lower);
        });
    }
    function hasGameStarted(game) {
        if (!game) return false;
        const status = (game.status || '').toLowerCase();
        return !status.includes('scheduled') && !status.includes('pre');
    }
    function isGameFinished(game) {
        if (!game) return false;
        const status = (game.status || '').toLowerCase();
        return status.includes('final') || status.includes('completed');
    }
    function getGameStatusMessage(game) {
        if (!game) return 'Game not found for today';
        if (isGameFinished(game)) return `Game finished: ${game.awayTeam} ${game.awayScore}, ${game.homeTeam} ${game.homeScore}`;
        if (hasGameStarted(game)) return `In progress: ${game.awayTeam} ${game.awayScore}, ${game.homeTeam} ${game.homeScore}`;
        return `Scheduled for ${game.time}`;
    }
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            fetchTodaysGames().catch(console.error);
        });
    } else {
        fetchTodaysGames().catch(console.error);
    }
    setInterval(() => {
        fetchTodaysGames(true).catch(console.error);
    }, 60000);
    window.AutoGameFetcher = {
        fetchTodaysGames,
        findGame,
        hasGameStarted,
        isGameFinished,
        getGameStatusMessage,
        getTodaysGames: () => todaysGamesCache,
        getTeamRecord,
        getRecordsCache: () => teamRecordsCache
    };
    console.log('✅ AutoGameFetcher v2.0 loaded (with standings)');
})();
(function() {
    'use strict';
    const THEME_KEY = 'bears-bulls-theme';
    const THEMES = {
        DARK: 'dark',
        LIGHT: 'light'
    };
    function getSystemTheme() {
        return window.matchMedia('(prefers-color-scheme: dark)').matches ? THEMES.DARK : THEMES.LIGHT;
    }
    function getSavedTheme() {
        return localStorage.getItem(THEME_KEY) || getSystemTheme();
    }
    function saveTheme(theme) {
        localStorage.setItem(THEME_KEY, theme);
    }
    function getCurrentTheme() {
        return document.documentElement.getAttribute('data-theme') || THEMES.DARK;
    }
    function applyTheme(theme) {
        document.documentElement.setAttribute('data-theme', theme);
        updateThemeToggleUI(theme);
        window.dispatchEvent(new CustomEvent('themechange', { detail: { theme } }));
    }
    function toggleTheme() {
        const currentTheme = getCurrentTheme();
        const newTheme = currentTheme === THEMES.DARK ? THEMES.LIGHT : THEMES.DARK;
        applyTheme(newTheme);
        saveTheme(newTheme);
        console.log(`Theme switched: ${currentTheme} → ${newTheme}`);
    }
    function updateThemeToggleUI(theme) {
        const toggleBtn = document.querySelector('.theme-toggle');
        if (!toggleBtn) return;
        const icon = toggleBtn.querySelector('.theme-icon');
        const label = toggleBtn.querySelector('.theme-label');
        if (theme === THEMES.DARK) {
            if (icon) icon.textContent = '🌙';
            if (label) label.textContent = 'Dark';
            toggleBtn.setAttribute('aria-label', 'Switch to light theme');
        } else {
            if (icon) icon.textContent = '☀️';
            if (label) label.textContent = 'Light';
            toggleBtn.setAttribute('aria-label', 'Switch to dark theme');
        }
    }
    function setupThemeToggle() {
        if (document.querySelector('.theme-toggle')) return;
        const navActions = document.querySelector('.nav-actions, .user-profile, .dashboard-toolbar');
        if (!navActions) {
            console.warn('Theme toggle: No suitable location found');
            return;
        }
        const toggleHTML = `
            <button class="theme-toggle" title="Toggle theme" aria-label="Toggle theme">
                <span class="theme-icon">🌙</span>
            </button>
        `;
        navActions.insertAdjacentHTML('afterbegin', toggleHTML);
        const toggleBtn = document.querySelector('.theme-toggle');
        toggleBtn?.addEventListener('click', toggleTheme);
    }
    function watchSystemTheme() {
        const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        mediaQuery.addEventListener('change', (e) => {
            if (!localStorage.getItem(THEME_KEY)) {
                const newTheme = e.matches ? THEMES.DARK : THEMES.LIGHT;
                applyTheme(newTheme);
                console.log(`System theme changed: ${newTheme}`);
            }
        });
    }
    function init() {
        const savedTheme = getSavedTheme();
        applyTheme(savedTheme);
        setupThemeToggle();
        watchSystemTheme();
        console.log(`✅ Theme Manager initialized: ${savedTheme}`);
    }
    init();
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupThemeToggle);
    }
    window.ThemeManager = {
        toggle: toggleTheme,
        set: (theme) => {
            if (Object.values(THEMES).includes(theme)) {
                applyTheme(theme);
                saveTheme(theme);
            }
        },
        get: getCurrentTheme,
        THEMES
    };
})();
(function() {
    'use strict';
    const notifications = [];
    let notificationContainer = null;
    const TYPES = {
        SUCCESS: 'success',
        ERROR: 'error',
        WARNING: 'warning',
        INFO: 'info'
    };
    const TYPE_CONFIG = {
        success: { icon: '✓', duration: 3000 },
        error: { icon: '✕', duration: 5000 },
        warning: { icon: '⚠', duration: 4000 },
        info: { icon: 'ℹ', duration: 3000 }
    };
    function ensureContainer() {
        if (notificationContainer) return;
        notificationContainer = document.createElement('div');
        notificationContainer.className = 'notification-container';
        notificationContainer.setAttribute('role', 'region');
        notificationContainer.setAttribute('aria-live', 'polite');
        notificationContainer.setAttribute('aria-label', 'Notifications');
        document.body.appendChild(notificationContainer);
    }
    function show(message, type = TYPES.INFO, options = {}) {
        ensureContainer();
        const config = TYPE_CONFIG[type] || TYPE_CONFIG.info;
        const duration = options.duration || config.duration;
        const id = `notification-${Date.now()}-${Math.random()}`;
        const notification = {
            id,
            message,
            type,
            duration,
            timestamp: Date.now()
        };
        notifications.push(notification);
        const element = createNotificationElement(notification, config);
        notificationContainer.appendChild(element);
        requestAnimationFrame(() => {
            element.classList.add('show');
        });
        if (duration > 0) {
            setTimeout(() => dismiss(id), duration);
        }
        return id;
    }
    function createNotificationElement(notification, config) {
        const div = document.createElement('div');
        div.className = `notification notification-${notification.type}`;
        div.setAttribute('data-notification-id', notification.id);
        div.setAttribute('role', 'alert');
        div.innerHTML = `
            <div class="notification-icon">${config.icon}</div>
            <div class="notification-content">
                <div class="notification-message">${escapeHtml(notification.message)}</div>
            </div>
            <button class="notification-close" aria-label="Close notification">×</button>
        `;
        div.querySelector('.notification-close').addEventListener('click', () => {
            dismiss(notification.id);
        });
        return div;
    }
    function dismiss(id) {
        const element = notificationContainer?.querySelector(`[data-notification-id="${id}"]`);
        if (!element) return;
        element.classList.add('exit');
        setTimeout(() => {
            element.remove();
            const index = notifications.findIndex(n => n.id === id);
            if (index > -1) notifications.splice(index, 1);
        }, 300);
    }
    function dismissAll() {
        const elements = notificationContainer?.querySelectorAll('.notification');
        elements?.forEach(el => {
            el.classList.add('exit');
        });
        setTimeout(() => {
            notificationContainer.innerHTML = '';
            notifications.length = 0;
        }, 300);
    }
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    function success(message, options) {
        return show(message, TYPES.SUCCESS, options);
    }
    function error(message, options) {
        return show(message, TYPES.ERROR, options);
    }
    function warning(message, options) {
        return show(message, TYPES.WARNING, options);
    }
    function info(message, options) {
        return show(message, TYPES.INFO, options);
    }
    window.DashboardNotification = {
        show,
        success,
        error,
        warning,
        info,
        dismiss,
        dismissAll,
        TYPES
    };
    console.log('✅ Enhanced Notification System loaded');
})();
const API_BASE_URL = window.APP_CONFIG?.API_BASE_URL || '/api';
let selectedFiles = [];
const ALLOWED_EXTENSIONS = ['.pdf', '.jpg', '.jpeg', '.png', '.html', '.htm', '.txt', '.csv'];
const ALLOWED_MIME_TYPES = ['application/pdf', 'image/jpeg', 'image/png', 'text/html', 'text/plain', 'text/csv'];
const MAX_FILE_SIZE_MB = 10;
const MAX_FILE_SIZE = MAX_FILE_SIZE_MB * 1024 * 1024;
function isFileAllowed(file) {
    const ext = '.' + file.name.split('.').pop().toLowerCase();
    const isExtAllowed = ALLOWED_EXTENSIONS.includes(ext);
    const isMimeAllowed = ALLOWED_MIME_TYPES.some(mime => file.type.startsWith(mime.split('/')[0]) || file.type === mime);
    const isSizeAllowed = file.size <= MAX_FILE_SIZE;
    return { valid: isExtAllowed && isSizeAllowed, ext, size: file.size, isSizeAllowed, isExtAllowed };
}
document.addEventListener('DOMContentLoaded', () => {
    const actionButtons = document.getElementById('action-buttons');
    const importOptions = document.getElementById('import-options');
    const importBtn = document.querySelector('.import-picks-btn');
    const backBtn = document.querySelector('.import-back-btn');
    if (!importOptions) { console.warn('Import options element not found'); return; }
    function showImportOptions() {
        if (actionButtons) actionButtons.style.display = 'none';
        importOptions.removeAttribute('hidden');
    }
    function hideImportOptions() {
        importOptions.setAttribute('hidden', '');
        if (actionButtons) actionButtons.style.display = 'flex';
        resetUploadForm();
    }
    function resetUploadForm() {
        selectedFiles = [];
        const fileInput = document.getElementById('file-upload');
        const pasteArea = document.getElementById('paste-area');
        const fileList = document.getElementById('file-list');
        const uploadBtn = document.getElementById('upload-files-btn');
        const statusDiv = document.getElementById('upload-status');
        if (fileInput) fileInput.value = '';
        if (pasteArea) pasteArea.value = '';
        if (fileList) {
            fileList.innerHTML = '';
            fileList.style.display = 'none';
        }
        if (uploadBtn) uploadBtn.style.display = 'none';
        if (statusDiv) statusDiv.style.display = 'none';
    }
    if (importBtn) {
        importBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            showImportOptions();
        });
    }
    if (backBtn) {
        backBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            hideImportOptions();
        });
    }
    const dropZone = document.getElementById('drop-zone');
    const fileInput = document.getElementById('file-upload');
    const fileList = document.getElementById('file-list');
    const uploadFilesBtn = document.getElementById('upload-files-btn');
    if (dropZone && fileInput) {
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
        });
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => {
                dropZone.style.borderColor = '#10b981';
                dropZone.style.background = 'rgba(16, 185, 129, 0.05)';
            });
        });
        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => {
                dropZone.style.borderColor = '';
                dropZone.style.background = '';
            });
        });
        dropZone.addEventListener('drop', (e) => {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFiles(files);
        });
        fileInput.addEventListener('change', function() {
            handleFiles(this.files);
        });
    }
    function handleFiles(files) {
        const validFiles = [];
        const rejected = [];
        Array.from(files).forEach(file => {
            const check = isFileAllowed(file);
            if (check.valid) {
                validFiles.push(file);
            } else {
                const reason = !check.isExtAllowed
                    ? `Invalid file type (${check.ext})`
                    : `File too large (${formatFileSize(check.size)} > ${MAX_FILE_SIZE_MB}MB)`;
                rejected.push({ name: file.name, reason });
            }
        });
        if (rejected.length > 0) {
            const rejectMsg = rejected.map(r => `${r.name}: ${r.reason}`).join('\n');
            console.warn('Rejected files:', rejectMsg);
            showStatus(`Some files rejected:\n${rejected.map(r => r.name).join(', ')}`, 'error');
        }
        selectedFiles = validFiles;
        renderFileList();
    }
    function renderFileList() {
        if (selectedFiles.length === 0) {
            fileList.style.display = 'none';
            uploadFilesBtn.style.display = 'none';
            return;
        }
        fileList.style.display = 'block';
        uploadFilesBtn.style.display = 'block';
        fileList.innerHTML = selectedFiles.map((file, index) => {
            const size = formatFileSize(file.size);
            return `
                <div style="display: flex; align-items: center; justify-content: space-between; padding: 0.5rem; background: rgba(16, 185, 129, 0.05); border-radius: 4px; margin-bottom: 0.25rem;">
                    <span style="font-size: 0.75rem; color: #374151; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1;">${escapeHtml(file.name)} (${size})</span>
                    <button onclick="window.removeFile(${index})" style="background: none; border: none; color: #ef4444; cursor: pointer; font-size: 1rem; padding: 0 0.5rem;">×</button>
                </div>
            `;
        }).join('');
    }
    window.removeFile = function(index) {
        selectedFiles.splice(index, 1);
        renderFileList();
    };
    if (uploadFilesBtn) {
        uploadFilesBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            await uploadFiles();
        });
    }
    async function uploadFiles() {
        if (selectedFiles.length === 0) return;
        uploadFilesBtn.disabled = true;
        uploadFilesBtn.textContent = 'Uploading...';
        try {
            for (const file of selectedFiles) {
                const formData = new FormData();
                formData.append('file', file);
                const response = await fetch(`${API_BASE_URL}/upload`, {
                    method: 'POST',
                    body: formData
                });
                if (!response.ok) {
                    throw new Error(`Failed to upload ${file.name}: ${response.statusText}`);
                }
                const result = await response.json();
                console.log(`Uploaded ${file.name}:`, result);
            }
            showStatus(`Successfully uploaded ${selectedFiles.length} file(s)!`, 'success');
            selectedFiles = [];
            renderFileList();
            fileInput.value = '';
            if (window.loadUploadedPicks) {
                setTimeout(() => window.loadUploadedPicks(), 1000);
            } else if (window.loadAndAppendPicks) {
                setTimeout(() => window.loadAndAppendPicks(), 1000);
            }
            if (window.loadPicksFromDatabase) {
                setTimeout(() => window.loadPicksFromDatabase(), 1500);
            }
        } catch (error) {
            console.error('Upload error:', error);
            showStatus(`Upload failed: ${error.message}`, 'error');
        } finally {
            uploadFilesBtn.disabled = false;
            uploadFilesBtn.textContent = 'Upload Selected Files';
        }
    }
    const pasteArea = document.getElementById('paste-area');
    const uploadPasteBtn = document.getElementById('upload-paste-btn');
    const clearBtn = document.querySelector('.paste-clear-btn');
    if (uploadPasteBtn) {
        uploadPasteBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            const content = pasteArea.value.trim();
            if (!content) {
                showStatus('Please paste some content first.', 'error');
                return;
            }
            uploadPasteBtn.disabled = true;
            uploadPasteBtn.textContent = 'Uploading...';
            try {
                const isHTML = content.includes('<html') || content.includes('<!DOCTYPE') || content.includes('<div');
                const saveFn = window.LocalPicksManager?.parseAndAdd || processAndSavePicks;
                const picks = await saveFn(content, isHTML);
                if (picks.length === 0) {
                    showStatus('No picks could be parsed from the pasted content.', 'error');
                    return;
                }
                showStatus(`Successfully parsed and saved ${picks.length} pick(s)!`, 'success');
                pasteArea.value = '';
                if (window.loadUploadedPicks) {
                    setTimeout(() => window.loadUploadedPicks(), 1000);
                } else if (window.loadAndAppendPicks) {
                    setTimeout(() => window.loadAndAppendPicks(), 1000);
                }
                if (window.loadPicksFromDatabase) {
                    setTimeout(() => window.loadPicksFromDatabase(), 1500);
                }
            } catch (error) {
                console.error('Upload error:', error);
                showStatus(`Processing failed: ${error.message}`, 'error');
            } finally {
                uploadPasteBtn.disabled = false;
                uploadPasteBtn.textContent = 'Upload Pasted Content';
            }
        });
    }
    if (clearBtn) {
        clearBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (pasteArea) pasteArea.value = '';
        });
    }
    function showStatus(message, type) {
        const statusDiv = document.getElementById('upload-status');
        if (!statusDiv) return;
        statusDiv.textContent = message;
        statusDiv.style.display = 'block';
        if (type === 'success') {
            statusDiv.style.background = 'rgba(16, 185, 129, 0.1)';
            statusDiv.style.color = '#059669';
            statusDiv.style.border = '1px solid rgba(16, 185, 129, 0.3)';
        } else {
            statusDiv.style.background = 'rgba(239, 68, 68, 0.1)';
            statusDiv.style.color = '#dc2626';
            statusDiv.style.border = '1px solid rgba(239, 68, 68, 0.3)';
        }
        setTimeout(() => {
            statusDiv.style.display = 'none';
        }, 5000);
    }
    function formatFileSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    async function processAndSavePicks(content, isHTML = false) {
        try {
            let picks = [];
            if (window.PickStandardizer) {
                try {
                    picks = window.PickStandardizer.standardize(content);
                    console.log('Used PickStandardizer to parse picks:', picks.length);
                } catch (e) {
                    console.warn('PickStandardizer failed, falling back to basic parser:', e);
                    picks = isHTML ? parseHTMLPicks(content) : parseTextPicks(content);
                }
            } else {
                picks = isHTML ? parseHTMLPicks(content) : parseTextPicks(content);
            }
            const deriveTeams = (pick) => {
                const source = (pick.game || pick.description || pick.pickTeam || '').trim();
                if (!source) return null;
                const match = source.match(/(.+?)\s+(?:vs\.?|@|at)\s+(.+?)(?:\s+(over|under))?$/i);
                if (!match) return null;
                return {
                    awayTeam: match[1].trim(),
                    homeTeam: match[2].trim()
                };
            };
            if (picks.length > 0 && window.AutoGameFetcher) {
                try {
                    await window.AutoGameFetcher.fetchTodaysGames();
                    const todaysGames = window.AutoGameFetcher.getTodaysGames() || [];
                    picks = picks.filter(pick => {
                        const derivedTeams = deriveTeams(pick);
                        if (derivedTeams) {
                            if (!pick.awayTeam) pick.awayTeam = derivedTeams.awayTeam;
                            if (!pick.homeTeam) pick.homeTeam = derivedTeams.homeTeam;
                        }
                        const game = window.AutoGameFetcher.findGame(
                            (pick.awayTeam || pick.pickTeam || '').replace(/\bover\b|\bunder\b/i, '').trim(),
                            pick.homeTeam
                        );
                        if (!game) {
                            console.warn(`Game not found for today: ${pick.game || pick.pickTeam}`);
                            return true; 
                        }
                        if (window.AutoGameFetcher.isGameFinished(game)) {
                            console.warn(`Skipping pick for finished game: ${game.awayTeam} @ ${game.homeTeam}`);
                            return false; 
                        }
                        pick.game = `${game.awayTeam} @ ${game.homeTeam}`;
                        pick.date = game.date;
                        pick.time = game.time;
                        pick.sport = game.sport;
                        pick.gameStatus = game.status;
                        pick.awayTeam = game.awayTeam;
                        pick.homeTeam = game.homeTeam;
                        return true;
                    });
                    console.log(`After validation: ${picks.length} valid picks remaining`);
                } catch (e) {
                    console.warn('AutoGameFetcher validation failed:', e);
                }
            }
            if (picks.length > 0) {
                const response = await fetch(`${API_BASE_URL}/save-picks`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        picks: picks,
                        source: 'upload'
                    })
                });
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Failed to save picks: ${response.statusText} - ${errorText}`);
                }
                const result = await response.json();
                console.log('Picks saved to database:', result);
            } else {
                console.warn('No valid picks to save after processing');
            }
            return picks;
        } catch (error) {
            console.error('Error processing picks:', error);
            throw error; 
        }
    }
    function parseHTMLPicks(html) {
        const picks = [];
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const betElements = doc.querySelectorAll('[class*="bet"], [class*="pick"], [class*="wager"]');
        betElements.forEach(element => {
            try {
                const text = element.textContent;
                const pick = parsePickFromText(text);
                if (pick) picks.push(pick);
            } catch (e) {
                console.warn('Failed to parse bet element:', e);
            }
        });
        return picks;
    }
    function parseTextPicks(text) {
        const picks = [];
        const lines = text.split('\n');
        lines.forEach(line => {
            const pick = parsePickFromText(line);
            if (pick) picks.push(pick);
        });
        return picks;
    }
    function parsePickFromText(text) {
        const spreadPattern = /([A-Za-z\s]+)\s+([-+]?\d+\.?\d*)\s+\(([-+]\d+)\)/;
        const totalPattern = /([A-Za-z\s]+)\s+(O|U|Over|Under)\s+(\d+\.?\d*)/i;
        const mlPattern = /([A-Za-z\s]+)\s+ML\s+([-+]\d+)/i;
        let match;
        let pick = null;
        if (match = text.match(spreadPattern)) {
            pick = {
                pickType: 'spread',
                pickTeam: match[1].trim(),
                line: match[2],
                odds: match[3]
            };
        } else if (match = text.match(totalPattern)) {
            pick = {
                pickType: 'total',
                pickTeam: match[2].toUpperCase() === 'O' || match[2].toLowerCase() === 'over' ? 'Over' : 'Under',
                line: match[3]
            };
        } else if (match = text.match(mlPattern)) {
            pick = {
                pickType: 'moneyline',
                pickTeam: match[1].trim(),
                odds: match[2]
            };
        }
        if (pick) {
            const vsPattern = /([A-Za-z\s]+)\s+(vs?|@|at)\s+([A-Za-z\s]+)/i;
            const teamMatch = text.match(vsPattern);
            if (teamMatch) {
                pick.awayTeam = teamMatch[1].trim();
                pick.homeTeam = teamMatch[3].trim();
            }
            pick.sport = 'nfl'; 
            pick.gameDate = new Date().toISOString().split('T')[0];
            pick.status = 'pending';
        }
        return pick;
    }
    window.processAndSavePicks = processAndSavePicks;
    window.parseTextPicks = parseTextPicks;
});
(function() {
    'use strict';
    function exportToCSV() {
        const picks = window.LocalPicksManager?.getAll() || [];
        if (picks.length === 0) {
            showNotification('No picks to export', 'warning');
            return;
        }
        const headers = [
            'Date', 'Time', 'Sport', 'Sportsbook', 'Pick Team', 'Away Team', 'Home Team',
            'Pick Type', 'Line', 'Odds', 'Segment', 'Risk', 'Win', 'Status', 'Result'
        ];
        const rows = picks.map(pick => [
            pick.gameDate || '',
            pick.gameTime || '',
            pick.sport || '',
            pick.sportsbook || '',
            pick.pickTeam || '',
            pick.awayTeam || '',
            pick.homeTeam || '',
            pick.pickType || '',
            pick.line || '',
            pick.odds || '',
            pick.segment || 'Full Game',
            pick.risk || 0,
            pick.win || 0,
            pick.status || 'pending',
            pick.result || ''
        ]);
        const csvContent = [
            headers.join(','),
            ...rows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(','))
        ].join('\n');
        downloadFile(csvContent, `bears-bulls-picks-${getDateString()}.csv`, 'text/csv');
        showNotification(`${picks.length} picks exported to CSV`, 'success');
    }
    function exportToExcel() {
        const picks = window.LocalPicksManager?.getAll() || [];
        if (picks.length === 0) {
            showNotification('No picks to export', 'warning');
            return;
        }
        const headers = [
            'Date', 'Time', 'Sport', 'Sportsbook', 'Pick Team', 'Away Team', 'Home Team',
            'Pick Type', 'Line', 'Odds', 'Segment', 'Risk', 'Win', 'Status', 'Result', 'Notes'
        ];
        const rows = picks.map(pick => [
            pick.gameDate || '',
            pick.gameTime || '',
            pick.sport || '',
            pick.sportsbook || '',
            pick.pickTeam || '',
            pick.awayTeam || '',
            pick.homeTeam || '',
            pick.pickType || '',
            pick.line || '',
            pick.odds || '',
            pick.segment || 'Full Game',
            pick.risk || 0,
            pick.win || 0,
            pick.status || 'pending',
            pick.result || '',
            pick.notes || ''
        ]);
        const tsvContent = [
            headers.join('\t'),
            ...rows.map(row => row.map(cell => String(cell).replace(/\t/g, ' ')).join('\t'))
        ].join('\n');
        downloadFile(tsvContent, `bears-bulls-picks-${getDateString()}.xls`, 'application/vnd.ms-excel');
        showNotification(`${picks.length} picks exported to Excel`, 'success');
    }
    function exportToJSON() {
        const picks = window.LocalPicksManager?.getAll() || [];
        if (picks.length === 0) {
            showNotification('No picks to export', 'warning');
            return;
        }
        const jsonContent = JSON.stringify(picks, null, 2);
        downloadFile(jsonContent, `bears-bulls-picks-${getDateString()}.json`, 'application/json');
        showNotification(`${picks.length} picks exported to JSON`, 'success');
    }
    function importFromFile(file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const content = e.target.result;
                const ext = file.name.split('.').pop().toLowerCase();
                let picks = [];
                if (ext === 'json') {
                    picks = JSON.parse(content);
                } else if (ext === 'csv' || ext === 'xls' || ext === 'xlsx') {
                    picks = parseCSV(content);
                } else {
                    throw new Error('Unsupported file format');
                }
                if (!Array.isArray(picks) || picks.length === 0) {
                    throw new Error('No valid picks found in file');
                }
                const validPicks = picks.filter(pick => 
                    pick.pickTeam && (pick.awayTeam || pick.homeTeam)
                );
                if (window.LocalPicksManager) {
                    window.LocalPicksManager.add(validPicks);
                    showNotification(`Imported ${validPicks.length} picks`, 'success');
                } else {
                    console.error('LocalPicksManager not available');
                    showNotification('Error: Import system not ready', 'error');
                }
            } catch (error) {
                console.error('Import error:', error);
                showNotification(`Import failed: ${error.message}`, 'error');
            }
        };
        reader.readAsText(file);
    }
    function parseCSV(content) {
        const lines = content.split('\n').filter(line => line.trim());
        if (lines.length < 2) return [];
        const headers = lines[0].split(/,|\t/).map(h => h.replace(/"/g, '').trim().toLowerCase());
        const picks = [];
        for (let i = 1; i < lines.length; i++) {
            const values = lines[i].split(/,|\t/).map(v => v.replace(/"/g, '').trim());
            const pick = {};
            headers.forEach((header, index) => {
                const value = values[index] || '';
                if (header.includes('date')) pick.gameDate = value;
                else if (header.includes('time')) pick.gameTime = value;
                else if (header.includes('sport')) pick.sport = value;
                else if (header.includes('sportsbook') || header.includes('book')) pick.sportsbook = value;
                else if (header.includes('pick') && header.includes('team')) pick.pickTeam = value;
                else if (header.includes('away')) pick.awayTeam = value;
                else if (header.includes('home')) pick.homeTeam = value;
                else if (header.includes('type')) pick.pickType = value;
                else if (header.includes('line')) pick.line = value;
                else if (header.includes('odds')) pick.odds = value;
                else if (header.includes('segment') || header.includes('period')) pick.segment = value;
                else if (header.includes('risk') || header.includes('bet')) pick.risk = parseFloat(value) || 0;
                else if (header.includes('win') || header.includes('return')) pick.win = parseFloat(value) || 0;
                else if (header.includes('status')) pick.status = value || 'pending';
                else if (header.includes('result')) pick.result = value;
                else if (header.includes('notes')) pick.notes = value;
            });
            if (pick.pickTeam && (pick.awayTeam || pick.homeTeam)) {
                picks.push(pick);
            }
        }
        return picks;
    }
    function downloadFile(content, filename, mimeType) {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }
    function getDateString() {
        const now = new Date();
        return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
    }
    function showNotification(message, type = 'info') {
        if (window.DashboardNotification) {
            window.DashboardNotification.show(message, type);
        } else {
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
    }
    function setupExportImportUI() {
        const toolbar = document.querySelector('.filters-toolbar, .dashboard-toolbar, .main-toolbar');
        if (!toolbar || toolbar.querySelector('.export-import-controls')) return;
        const controlsHTML = `
            <div class="export-import-controls">
                <button class="btn-export-csv" title="Export to CSV">
                    <span class="icon">📊</span>
                    <span class="label">Export CSV</span>
                </button>
                <button class="btn-export-excel" title="Export to Excel">
                    <span class="icon">📈</span>
                    <span class="label">Export Excel</span>
                </button>
                <button class="btn-import" title="Import picks from file">
                    <span class="icon">📥</span>
                    <span class="label">Import</span>
                </button>
                <input type="file" id="import-file-input" accept=".csv,.xls,.xlsx,.json" style="display: none;">
            </div>
        `;
        toolbar.insertAdjacentHTML('beforeend', controlsHTML);
        document.querySelector('.btn-export-csv')?.addEventListener('click', exportToCSV);
        document.querySelector('.btn-export-excel')?.addEventListener('click', exportToExcel);
        const importBtn = document.querySelector('.btn-import');
        const fileInput = document.getElementById('import-file-input');
        importBtn?.addEventListener('click', () => fileInput?.click());
        fileInput?.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                importFromFile(file);
                e.target.value = ''; 
            }
        });
    }
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupExportImportUI);
    } else {
        setupExportImportUI();
    }
    window.ExportImportUtil = {
        exportToCSV,
        exportToExcel,
        exportToJSON,
        importFromFile,
        parseCSV
    };
    console.log('✅ Export/Import Utility loaded');
})();
(function() {
    'use strict';
    class LiveScoreUpdater {
        constructor() {
            this.updateInterval = null;
            this.lastUpdate = Date.now();
            this.updateFrequency = 30000; 
            this.isUpdating = false;
            this.activeGames = new Map();
            this.apiEndpoint = window.APP_CONFIG ? window.APP_CONFIG.API_BASE_URL : '/api';
            this.startLiveUpdates = this.startLiveUpdates.bind(this);
            this.stopLiveUpdates = this.stopLiveUpdates.bind(this);
            this.updateScores = this.updateScores.bind(this);
        }
        startLiveUpdates() {
            if (this.updateInterval) {
                return; 
            }
            console.log('Starting live score updates');
            this.updateScores();
            this.updateInterval = setInterval(() => {
                this.updateScores();
            }, this.updateFrequency);
        }
        stopLiveUpdates() {
            if (this.updateInterval) {
                clearInterval(this.updateInterval);
                this.updateInterval = null;
                console.log('Stopped live score updates');
            }
        }
        async updateScores() {
            if (this.isUpdating) {
                return; 
            }
            this.isUpdating = true;
            try {
                const picks = this.getActivePicksFromDOM();
                if (picks.length === 0) {
                    this.isUpdating = false;
                    return;
                }
                const picksBySport = this.groupPicksBySport(picks);
                for (const [sport, sportPicks] of Object.entries(picksBySport)) {
                    await this.updateSportScores(sport, sportPicks);
                }
                this.updateKPIMetrics();
                this.lastUpdate = Date.now();
            } catch (error) {
                console.error('Error updating scores:', error);
            } finally {
                this.isUpdating = false;
            }
        }
        getActivePicksFromDOM() {
            const picks = [];
            const tbody = document.getElementById('picks-tbody');
            if (!tbody) {
                return picks;
            }
            if (picks.length === 0 && tbody.children.length === 0) {
                return picks;
            }
            const rows = tbody.querySelectorAll('tr:not(.parlay-legs)');
            rows.forEach(row => {
                if (row.style.display === 'none') {
                    return;
                }
                const status = row.querySelector('.status-badge')?.textContent || '';
                if (status === 'Pending' || status === 'On Track' || status === 'At Risk') {
                    const pick = this.extractPickFromRow(row);
                    if (pick) {
                        picks.push(pick);
                    }
                }
            });
            return picks;
        }
        extractPickFromRow(row) {
            try {
                const pick = {
                    rowId: row.getAttribute('data-row-id') || row.id,
                    gameId: row.getAttribute('data-game-id'),
                    sport: row.getAttribute('data-sport') || 'nfl',
                    awayTeam: row.getAttribute('data-away-team'),
                    homeTeam: row.getAttribute('data-home-team'),
                    awayAbbr: row.getAttribute('data-away-abbr'),
                    homeAbbr: row.getAttribute('data-home-abbr'),
                    pickType: row.getAttribute('data-pick-type'),
                    pickTeam: row.getAttribute('data-pick-team'),
                    line: row.getAttribute('data-line'),
                    currentAwayScore: null,
                    currentHomeScore: null
                };
                const boxScore = row.querySelector('.boxscore-container, .compact-boxscore');
                if (boxScore) {
                    const awayTotal = boxScore.querySelector('.total-away, .boxscore-row:nth-child(2) .boxscore-cell.total');
                    const homeTotal = boxScore.querySelector('.total-home, .boxscore-row:nth-child(3) .boxscore-cell.total');
                    if (awayTotal) {
                        pick.currentAwayScore = parseInt(awayTotal.textContent) || 0;
                    }
                    if (homeTotal) {
                        pick.currentHomeScore = parseInt(homeTotal.textContent) || 0;
                    }
                }
                return pick;
            } catch (error) {
                console.warn('Failed to extract pick from row:', error);
                return null;
            }
        }
        groupPicksBySport(picks) {
            const grouped = {};
            for (const pick of picks) {
                const sport = pick.sport || 'nfl';
                if (!grouped[sport]) {
                    grouped[sport] = [];
                }
                grouped[sport].push(pick);
            }
            return grouped;
        }
        async updateSportScores(sport, picks) {
            try {
                let endpoint = '';
                if (sport === 'nba') {
                    endpoint = `${this.apiEndpoint}/get-nba-scores`;
                } else {
                    endpoint = `${this.apiEndpoint}/get-espn-scores?sport=${sport}`;
                }
                const response = await fetch(endpoint);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();
                const games = data.data?.games || [];
                for (const pick of picks) {
                    const game = this.findMatchingGame(pick, games);
                    if (game) {
                        this.updatePickWithGameData(pick, game);
                    }
                }
            } catch (error) {
                console.warn(`Failed to update ${sport} scores:`, error);
                await this.fallbackToOddsAPI(sport, picks);
            }
        }
        findMatchingGame(pick, games) {
            for (const game of games) {
                if (pick.gameId && game.gameId === pick.gameId) {
                    return game;
                }
                const awayMatch = this.teamMatches(pick.awayAbbr, game.awayAbbr) ||
                                  this.teamMatches(pick.awayTeam, game.awayTeam);
                const homeMatch = this.teamMatches(pick.homeAbbr, game.homeAbbr) ||
                                  this.teamMatches(pick.homeTeam, game.homeTeam);
                if (awayMatch && homeMatch) {
                    return game;
                }
            }
            return null;
        }
        teamMatches(team1, team2) {
            if (!team1 || !team2) return false;
            const normalize = (str) => str.toLowerCase().replace(/[^a-z0-9]/g, '');
            return normalize(team1) === normalize(team2);
        }
        updatePickWithGameData(pick, game) {
            const row = document.querySelector(`tr[data-row-id="${pick.rowId}"]`);
            if (!row) return;
            const boxScore = row.querySelector('.boxscore-container, .compact-boxscore');
            if (boxScore) {
                this.updateBoxScore(boxScore, game);
            }
            const newStatus = this.calculatePickStatus(pick, game);
            this.updatePickStatus(row, newStatus);
            this.activeGames.set(pick.rowId, game);
        }
        updateBoxScore(boxScore, game) {
            if (game.scoring) {
                for (const [period, scores] of Object.entries(game.scoring)) {
                    const awayCell = boxScore.querySelector(`.${period.toLowerCase()}-away`);
                    const homeCell = boxScore.querySelector(`.${period.toLowerCase()}-home`);
                    if (awayCell && scores.away !== undefined) {
                        awayCell.textContent = scores.away;
                    }
                    if (homeCell && scores.home !== undefined) {
                        homeCell.textContent = scores.home;
                    }
                }
            }
            const awayTotal = boxScore.querySelector('.total-away');
            const homeTotal = boxScore.querySelector('.total-home');
            if (awayTotal && game.awayScore !== undefined) {
                awayTotal.textContent = game.awayScore;
            }
            if (homeTotal && game.homeScore !== undefined) {
                homeTotal.textContent = game.homeScore;
            }
            const gameStatus = boxScore.querySelector('.game-time-status');
            if (gameStatus) {
                if (game.isLive) {
                    gameStatus.textContent = game.gameStatus?.clock || 'Live';
                    gameStatus.className = 'game-time-status live';
                } else if (game.isFinal) {
                    gameStatus.textContent = 'Final';
                    gameStatus.className = 'game-time-status final';
                } else {
                    gameStatus.className = 'game-time-status countdown';
                }
            }
            if (boxScore && boxScore.getAttribute('data-live-ready') !== 'true') {
                boxScore.setAttribute('data-live-ready', 'true');
            }
        }
        calculatePickStatus(pick, game) {
            if (game.isFinal) {
                return this.calculateFinalStatus(pick, game);
            } else if (game.isLive) {
                return this.calculateLiveStatus(pick, game);
            }
            return 'pending';
        }
        calculateFinalStatus(pick, game) {
            const awayScore = game.awayScore || 0;
            const homeScore = game.homeScore || 0;
            if (pick.pickType === 'spread') {
                const spread = parseFloat(pick.line) || 0;
                const isAwayPick = this.teamMatches(pick.pickTeam, pick.awayTeam);
                const actualSpread = isAwayPick ? (awayScore - homeScore) : (homeScore - awayScore);
                if (actualSpread + spread > 0) {
                    return 'win';
                } else if (actualSpread + spread < 0) {
                    return 'loss';
                } else {
                    return 'push';
                }
            } else if (pick.pickType === 'moneyline') {
                const isAwayPick = this.teamMatches(pick.pickTeam, pick.awayTeam);
                const pickScore = isAwayPick ? awayScore : homeScore;
                const oppScore = isAwayPick ? homeScore : awayScore;
                if (pickScore > oppScore) {
                    return 'win';
                } else if (pickScore < oppScore) {
                    return 'loss';
                } else {
                    return 'push';
                }
            } else if (pick.pickType === 'total' || pick.pickType.includes('ou')) {
                const total = parseFloat(pick.line) || 0;
                const actualTotal = awayScore + homeScore;
                const isOver = pick.pickType.includes('over') || pick.pickTeam?.toLowerCase().includes('over');
                if (isOver) {
                    return actualTotal > total ? 'win' : (actualTotal < total ? 'loss' : 'push');
                } else {
                    return actualTotal < total ? 'win' : (actualTotal > total ? 'loss' : 'push');
                }
            }
            return 'pending';
        }
        calculateLiveStatus(pick, game) {
            const awayScore = game.awayScore || 0;
            const homeScore = game.homeScore || 0;
            if (pick.pickType === 'spread') {
                const spread = parseFloat(pick.line) || 0;
                const isAwayPick = this.teamMatches(pick.pickTeam, pick.awayTeam);
                const actualSpread = isAwayPick ? (awayScore - homeScore) : (homeScore - awayScore);
                return (actualSpread + spread > 0) ? 'on-track' : 'at-risk';
            } else if (pick.pickType === 'moneyline') {
                const isAwayPick = this.teamMatches(pick.pickTeam, pick.awayTeam);
                const pickScore = isAwayPick ? awayScore : homeScore;
                const oppScore = isAwayPick ? homeScore : awayScore;
                return pickScore >= oppScore ? 'on-track' : 'at-risk';
            } else if (pick.pickType === 'total' || pick.pickType.includes('ou')) {
                const total = parseFloat(pick.line) || 0;
                const actualTotal = awayScore + homeScore;
                const isOver = pick.pickType.includes('over') || pick.pickTeam?.toLowerCase().includes('over');
                const period = game.gameStatus?.period || 1;
                const projectedTotal = actualTotal * (4 / period);
                if (isOver) {
                    return projectedTotal > total ? 'on-track' : 'at-risk';
                } else {
                    return projectedTotal < total ? 'on-track' : 'at-risk';
                }
            }
            return 'pending';
        }
        updatePickStatus(row, newStatus) {
            const statusBadge = row.querySelector('.status-badge');
            if (!statusBadge) return;
            const currentStatus = statusBadge.getAttribute('data-status');
            if (currentStatus === newStatus) return; 
            statusBadge.setAttribute('data-status', newStatus);
            statusBadge.className = `status-badge status-${newStatus}`;
            statusBadge.textContent = this.getStatusLabel(newStatus);
            statusBadge.style.animation = 'pulse 0.5s ease';
            setTimeout(() => {
                statusBadge.style.animation = '';
            }, 500);
        }
        getStatusLabel(status) {
            const labels = {
                'pending': 'Pending',
                'on-track': 'On Track',
                'at-risk': 'At Risk',
                'win': 'Win',
                'loss': 'Loss',
                'push': 'Push'
            };
            return labels[status] || status;
        }
        async fallbackToOddsAPI(sport, picks) {
            console.log(`Attempting fallback to odds API for ${sport}`);
        }
        updateKPIMetrics() {
            if (typeof window.recalculateKPIs === 'function') {
                window.recalculateKPIs();
            }
            const tiles = document.querySelectorAll('.kpi-tile');
            tiles.forEach(tile => {
                const event = new CustomEvent('update-kpi');
                tile.dispatchEvent(event);
            });
        }
        setUpdateFrequency(seconds) {
            this.updateFrequency = seconds * 1000;
            if (this.updateInterval) {
                this.stopLiveUpdates();
                this.startLiveUpdates();
            }
        }
    }
    const liveUpdater = new LiveScoreUpdater();
    window.LiveScoreUpdater = liveUpdater;
    document.addEventListener('DOMContentLoaded', () => {
        const liveUpdatesEnabled = window.APP_CONFIG?.LIVE_UPDATES !== false;
        if (liveUpdatesEnabled) {
            setTimeout(() => {
                liveUpdater.startLiveUpdates();
            }, 2000);
        }
    });
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            liveUpdater.stopLiveUpdates();
        } else {
            liveUpdater.startLiveUpdates();
        }
    });
    console.log('Live score updater initialized');
})();
(function() {
    'use strict';
    let unitMultiplier = 1000; 
    const TEAM_ALIASES = {
        'spurs': 'San Antonio Spurs',
        'san antonio': 'San Antonio Spurs',
        'knicks': 'New York Knicks',
        'new york': 'New York Knicks',
        'lakers': 'Los Angeles Lakers',
        'la lakers': 'Los Angeles Lakers',
        'clippers': 'Los Angeles Clippers',
        'la clippers': 'Los Angeles Clippers',
        'warriors': 'Golden State Warriors',
        'golden state': 'Golden State Warriors',
        'celtics': 'Boston Celtics',
        'boston': 'Boston Celtics',
        'heat': 'Miami Heat',
        'miami': 'Miami Heat',
        'bulls': 'Chicago Bulls',
        'chicago': 'Chicago Bulls',
        'cavs': 'Cleveland Cavaliers',
        'cavaliers': 'Cleveland Cavaliers',
        'cleveland': 'Cleveland Cavaliers',
        'mavs': 'Dallas Mavericks',
        'mavericks': 'Dallas Mavericks',
        'dallas': 'Dallas Mavericks',
        'nuggets': 'Denver Nuggets',
        'denver': 'Denver Nuggets',
        'pistons': 'Detroit Pistons',
        'detroit': 'Detroit Pistons',
        'rockets': 'Houston Rockets',
        'houston': 'Houston Rockets',
        'pacers': 'Indiana Pacers',
        'indiana': 'Indiana Pacers',
        'grizzlies': 'Memphis Grizzlies',
        'memphis': 'Memphis Grizzlies',
        'bucks': 'Milwaukee Bucks',
        'milwaukee': 'Milwaukee Bucks',
        'wolves': 'Minnesota Timberwolves',
        'timberwolves': 'Minnesota Timberwolves',
        'minnesota': 'Minnesota Timberwolves',
        'pelicans': 'New Orleans Pelicans',
        'new orleans': 'New Orleans Pelicans',
        'nets': 'Brooklyn Nets',
        'brooklyn': 'Brooklyn Nets',
        'thunder': 'Oklahoma City Thunder',
        'okc': 'Oklahoma City Thunder',
        'magic': 'Orlando Magic',
        'orlando': 'Orlando Magic',
        '76ers': 'Philadelphia 76ers',
        'sixers': 'Philadelphia 76ers',
        'philly': 'Philadelphia 76ers',
        'philadelphia': 'Philadelphia 76ers',
        'suns': 'Phoenix Suns',
        'phoenix': 'Phoenix Suns',
        'blazers': 'Portland Trail Blazers',
        'portland': 'Portland Trail Blazers',
        'kings': 'Sacramento Kings',
        'sacramento': 'Sacramento Kings',
        'raptors': 'Toronto Raptors',
        'toronto': 'Toronto Raptors',
        'jazz': 'Utah Jazz',
        'utah': 'Utah Jazz',
        'wizards': 'Washington Wizards',
        'washington': 'Washington Wizards',
        'hawks': 'Atlanta Hawks',
        'atlanta': 'Atlanta Hawks',
        'hornets': 'Charlotte Hornets',
        'charlotte': 'Charlotte Hornets',
        'chiefs': 'Kansas City Chiefs',
        'kansas city': 'Kansas City Chiefs',
        'kc': 'Kansas City Chiefs',
        'eagles': 'Philadelphia Eagles',
        'cowboys': 'Dallas Cowboys',
        'niners': 'San Francisco 49ers',
        '49ers': 'San Francisco 49ers',
        'bills': 'Buffalo Bills',
        'buffalo': 'Buffalo Bills',
        'ravens': 'Baltimore Ravens',
        'baltimore': 'Baltimore Ravens',
        'bengals': 'Cincinnati Bengals',
        'cincinnati': 'Cincinnati Bengals',
        'browns': 'Cleveland Browns',
        'steelers': 'Pittsburgh Steelers',
        'pittsburgh': 'Pittsburgh Steelers',
        'colts': 'Indianapolis Colts',
        'texans': 'Houston Texans',
        'jaguars': 'Jacksonville Jaguars',
        'jags': 'Jacksonville Jaguars',
        'jacksonville': 'Jacksonville Jaguars',
        'titans': 'Tennessee Titans',
        'tennessee': 'Tennessee Titans',
        'broncos': 'Denver Broncos',
        'chargers': 'Los Angeles Chargers',
        'la chargers': 'Los Angeles Chargers',
        'raiders': 'Las Vegas Raiders',
        'vegas': 'Las Vegas Raiders',
        'seahawks': 'Seattle Seahawks',
        'seattle': 'Seattle Seahawks',
        'cardinals': 'Arizona Cardinals',
        'arizona': 'Arizona Cardinals',
        'rams': 'Los Angeles Rams',
        'la rams': 'Los Angeles Rams',
        'packers': 'Green Bay Packers',
        'green bay': 'Green Bay Packers',
        'bears': 'Chicago Bears',
        'lions': 'Detroit Lions',
        'vikings': 'Minnesota Vikings',
        'saints': 'New Orleans Saints',
        'falcons': 'Atlanta Falcons',
        'panthers': 'Carolina Panthers',
        'carolina': 'Carolina Panthers',
        'bucs': 'Tampa Bay Buccaneers',
        'buccaneers': 'Tampa Bay Buccaneers',
        'tampa': 'Tampa Bay Buccaneers',
        'tampa bay': 'Tampa Bay Buccaneers',
        'commanders': 'Washington Commanders',
        'giants': 'New York Giants',
        'ny giants': 'New York Giants',
        'jets': 'New York Jets',
        'ny jets': 'New York Jets',
        'patriots': 'New England Patriots',
        'pats': 'New England Patriots',
        'new england': 'New England Patriots',
        'dolphins': 'Miami Dolphins',
        'army': 'Army Black Knights',
        'navy': 'Navy Midshipmen',
        'alabama': 'Alabama Crimson Tide',
        'bama': 'Alabama Crimson Tide',
        'georgia': 'Georgia Bulldogs',
        'ohio state': 'Ohio State Buckeyes',
        'osu': 'Ohio State Buckeyes',
        'michigan': 'Michigan Wolverines',
        'texas': 'Texas Longhorns',
        'notre dame': 'Notre Dame Fighting Irish'
    };
    function standardizePicks(input, options = {}) {
        if (options.unitMultiplier) {
            unitMultiplier = options.unitMultiplier;
        }
        if (typeof input === 'string' && input.includes('<')) {
            if (input.includes('data-panel="line"') || input.includes('data-sport-line')) {
                return parseSportsbookGameLines(input);
            }
            if (input.includes('<table') || input.includes('<tr')) {
                return parseHTMLPicks(input);
            }
            if (input.includes('class=')) {
                return parseSportsbookGameLines(input);
            }
        }
        return parseTextPicks(input);
    }
    function parseSportsbookGameLines(html) {
        const picks = [];
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        let gamePanels = doc.querySelectorAll('[data-panel="line"]');
        if (gamePanels.length === 0) {
            gamePanels = doc.querySelectorAll('.line-panel, .game-panel, [data-sport-line]');
        }
        if (gamePanels.length === 0) {
            gamePanels = doc.querySelectorAll('.lines-row, .game-row, .event-row');
        }
        console.log(`🔍 Found ${gamePanels.length} game panels to parse`);
        gamePanels.forEach((panel, idx) => {
            try {
                const gamePicks = parseGamePanel(panel);
                console.log(`  Panel ${idx + 1}: ${gamePicks.length} picks found`);
                picks.push(...gamePicks);
            } catch (e) {
                console.warn('Failed to parse game panel:', e);
            }
        });
        if (picks.length === 0) {
            console.log('📝 No HTML picks found, falling back to text parsing...');
            const textContent = doc.body?.textContent || html.replace(/<[^>]*>/g, ' ');
            const textPicks = parseTextPicks(textContent);
            picks.push(...textPicks);
        }
        console.log(`📊 Total parsed: ${picks.length} betting lines`);
        return picks;
    }
    function parseGamePanel(panel) {
        const picks = [];
        const gameInfo = extractGameInfo(panel);
        if (!gameInfo.firstTeam && !gameInfo.secondTeam) {
            return picks;
        }
        const lineGroups = panel.querySelectorAll('.group, .line-group, [data-group-line]');
        lineGroups.forEach(group => {
            try {
                const groupPicks = parseLineGroup(group, gameInfo);
                picks.push(...groupPicks);
            } catch (e) {
                console.warn('Failed to parse line group:', e);
            }
        });
        if (picks.length === 0) {
            const individualLines = panel.querySelectorAll('.line-play, .bet-line, [data-field="line"]');
            individualLines.forEach(line => {
                const pick = parseIndividualLine(line, gameInfo);
                if (pick) picks.push(pick);
            });
        }
        return picks;
    }
    function extractGameInfo(panel) {
        const info = {
            firstTeam: '',
            secondTeam: '',
            date: getTodayDate(),
            time: '',
            sport: 'NBA',  
            league: ''
        };
        const firstTeamEl = panel.querySelector('[data-field="first-team"], .first-team, .away-team, .team-1');
        const secondTeamEl = panel.querySelector('[data-field="second-team"], .second-team, .home-team, .team-2');
        if (firstTeamEl) info.firstTeam = firstTeamEl.textContent.trim();
        if (secondTeamEl) info.secondTeam = secondTeamEl.textContent.trim();
        const dateEl = panel.querySelector('[data-field="min-date"], .game-date, .date');
        const timeEl = panel.querySelector('[data-field="min-time"], .game-time, .time');
        if (dateEl) info.date = dateEl.textContent.trim();
        if (timeEl) info.time = timeEl.textContent.trim();
        const leagueEl = panel.querySelector('[data-field="league-name"], .league, .sport-name');
        if (leagueEl) {
            info.league = leagueEl.textContent.trim();
            info.sport = detectSportFromLeague(info.league);
        }
        const sportLine = panel.querySelector('[data-sport-line]');
        if (sportLine) {
            const sportAttr = sportLine.getAttribute('data-sport-line');
            if (sportAttr) {
                info.sport = detectSportFromAttribute(sportAttr);
            }
        }
        if (info.firstTeam && info.secondTeam) {
            info.game = `${info.firstTeam} @ ${info.secondTeam}`;
            info.awayTeam = info.firstTeam;
            info.homeTeam = info.secondTeam;
        }
        return info;
    }
    function parseLineGroup(group, gameInfo) {
        const picks = [];
        const groupType = detectGroupType(group);
        const linePlays = group.querySelectorAll('.line-play, .bet-option, [data-type]');
        linePlays.forEach((play, index) => {
            const pick = parseLinePlacement(play, gameInfo, groupType, index);
            if (pick) picks.push(pick);
        });
        return picks;
    }
    function detectGroupType(group) {
        const groupClass = group.className || '';
        const dataType = group.getAttribute('data-type') || '';
        const groupText = group.textContent.toLowerCase();
        if (dataType.includes('spread') || dataType.includes('ps')) return 'spread';
        if (dataType.includes('ml') || dataType.includes('money')) return 'moneyline';
        if (dataType.includes('total') || dataType.includes('ou')) {
            if (dataType.includes('team') || dataType.includes('tt')) return 'team-total';
            return 'total';
        }
        if (groupClass.includes('spread')) return 'spread';
        if (groupClass.includes('money') || groupClass.includes('ml')) return 'moneyline';
        if (groupClass.includes('team-total') || groupClass.includes('tt')) return 'team-total';
        if (groupClass.includes('total') || groupClass.includes('ou')) return 'total';
        if (groupClass.includes('group-1') || groupClass.includes('group-0')) return 'spread';
        if (groupClass.includes('group-2')) return 'moneyline';
        if (groupClass.includes('group-3')) return 'total';
        if (groupClass.includes('group-4') || groupClass.includes('group-5')) return 'team-total';
        if (groupText.includes('spread')) return 'spread';
        if (groupText.includes('money')) return 'moneyline';
        if (groupText.includes('over') || groupText.includes('under')) return 'total';
        return 'spread'; 
    }
    function parseLinePlacement(play, gameInfo, betType, index) {
        const pick = {
            sport: gameInfo.sport,
            segment: 'Full Game',
            status: 'pending',
            date: gameInfo.date,
            time: gameInfo.time,
            game: gameInfo.game,
            awayTeam: gameInfo.awayTeam,
            homeTeam: gameInfo.homeTeam
        };
        const lineEl = play.querySelector('[data-field="line"], .line, .spread-value, .total-value');
        const priceEl = play.querySelector('[data-field="price"], .price, .odds, .juice');
        let line = lineEl ? lineEl.textContent.trim() : '';
        let price = priceEl ? priceEl.textContent.trim() : '-110';
        line = line.replace(/½/g, '.5').replace(/¼/g, '.25').replace(/¾/g, '.75');
        const teamIndex = determineTeamIndex(play, index);
        switch (betType) {
            case 'spread':
                pick.pickType = 'spread';
                pick.pickTeam = teamIndex === 0 ? gameInfo.firstTeam : gameInfo.secondTeam;
                pick.line = formatLine(line);
                pick.odds = formatOdds(price);
                break;
            case 'moneyline':
                pick.pickType = 'moneyline';
                pick.pickTeam = teamIndex === 0 ? gameInfo.firstTeam : gameInfo.secondTeam;
                pick.odds = formatOdds(line || price); 
                break;
            case 'total':
                pick.pickType = 'total';
                pick.pickDirection = teamIndex === 0 ? 'Over' : 'Under';
                pick.pickTeam = pick.pickDirection;
                pick.line = line.replace(/[ou]/gi, '').trim();
                pick.odds = formatOdds(price);
                break;
            case 'team-total':
                pick.pickType = 'team-total';
                pick.pickDirection = determineOverUnder(play, index);
                const ttTeamIdx = Math.floor(index / 2);
                pick.pickTeam = ttTeamIdx === 0 ? gameInfo.firstTeam : gameInfo.secondTeam;
                pick.line = line.replace(/[ou]/gi, '').trim();
                pick.odds = formatOdds(price);
                break;
        }
        if (!pick.pickTeam || !pick.pickType) {
            return null;
        }
        if (!pick.line && !pick.odds && pick.pickType !== 'moneyline') {
            return null;
        }
        return pick;
    }
    function parseIndividualLine(lineEl, gameInfo) {
        const pick = {
            sport: gameInfo.sport,
            segment: 'Full Game',
            status: 'pending',
            date: gameInfo.date,
            time: gameInfo.time,
            game: gameInfo.game,
            awayTeam: gameInfo.awayTeam,
            homeTeam: gameInfo.homeTeam
        };
        const lineText = lineEl.textContent.trim();
        if (!lineText) return null;
        parseLineAndOdds(pick, lineText);
        if (!pick.pickType) return null;
        if (!pick.pickTeam) {
            pick.pickTeam = gameInfo.firstTeam || 'Unknown';
        }
        return pick;
    }
    function determineTeamIndex(play, defaultIndex) {
        const teamAttr = play.getAttribute('data-team') || play.getAttribute('data-index');
        if (teamAttr) {
            return parseInt(teamAttr) || 0;
        }
        const parent = play.parentElement;
        if (parent) {
            const siblings = Array.from(parent.children);
            const position = siblings.indexOf(play);
            if (position !== -1) {
                return position % 2; 
            }
        }
        return defaultIndex % 2;
    }
    function determineOverUnder(play, index) {
        const text = play.textContent.toLowerCase();
        if (text.includes('over') || text.includes('o ')) return 'Over';
        if (text.includes('under') || text.includes('u ')) return 'Under';
        return index % 2 === 0 ? 'Over' : 'Under';
    }
    function formatLine(line) {
        if (!line) return '';
        line = line.trim();
        if (/^\d+\.?\d*$/.test(line)) return line;
        if (/^[+-]/.test(line)) return line;
        if (/^\d/.test(line)) return '+' + line;
        return line;
    }
    function formatOdds(odds) {
        if (!odds) return '-110';
        odds = odds.trim();
        odds = odds.replace(/[$€£]/g, '');
        if (/^\d+$/.test(odds)) {
            const num = parseInt(odds);
            return num >= 100 ? `-${num}` : `+${num}`;
        }
        if (/^[+-]\d+/.test(odds)) return odds;
        return '-110'; 
    }
    function detectSportFromLeague(league) {
        const lower = league.toLowerCase();
        if (lower.includes('nba') || lower.includes('basketball')) return 'NBA';
        if (lower.includes('nfl') || lower.includes('football')) return 'NFL';
        if (lower.includes('ncaab') || lower.includes('ncaam') || lower.includes('college basketball')) return 'NCAAB';
        if (lower.includes('ncaaf') || lower.includes('college football')) return 'NCAAF';
        if (lower.includes('mlb') || lower.includes('baseball')) return 'MLB';
        if (lower.includes('nhl') || lower.includes('hockey')) return 'NHL';
        if (lower.includes('soccer') || lower.includes('mls') || lower.includes('premier')) return 'Soccer';
        return 'NBA'; 
    }
    function detectSportFromAttribute(attr) {
        const lower = attr.toLowerCase();
        if (lower.includes('nba')) return 'NBA';
        if (lower.includes('nfl')) return 'NFL';
        if (lower.includes('ncaab') || lower.includes('ncaam')) return 'NCAAB';
        if (lower.includes('ncaaf')) return 'NCAAF';
        if (lower.includes('mlb')) return 'MLB';
        if (lower.includes('nhl')) return 'NHL';
        return 'NBA';
    }
    function parseHTMLPicks(html) {
        const picks = [];
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const rows = doc.querySelectorAll('tr[data-ticket], tr.odd, tr.even');
        const seenLegs = new Set();
        rows.forEach(row => {
            try {
                const ticketId = row.getAttribute('data-ticket') || '';
                const parlayLabel = row.querySelector('.type-magic');
                const isParlayRow = parlayLabel !== null;
                if (isParlayRow) {
                    const parlayType = parlayLabel.textContent.trim();
                    const legs = row.querySelectorAll('.wager-simple');
                    const rowRisk = parseFloat(row.querySelector('[data-risk]')?.getAttribute('data-risk')) || 0;
                    const rowWin = parseFloat(row.querySelector('[data-win]')?.getAttribute('data-win')) || 0;
                    legs.forEach((leg, legIdx) => {
                        const legPick = parseParlayLeg(leg, ticketId, parlayType, legIdx);
                        if (legPick) {
                            const legKey = `${ticketId}_${legPick.pickTeam}_${legPick.line || 'ML'}_${legPick.segment}`;
                            if (!seenLegs.has(legKey)) {
                                seenLegs.add(legKey);
                                legPick.risk = Math.round(rowRisk / legs.length);
                                legPick.win = Math.round(rowWin / legs.length);
                                legPick.parlayId = ticketId;
                                legPick.parlayType = parlayType;
                                legPick.isParlay = true;
                                picks.push(legPick);
                            }
                        }
                    });
                } else {
                    const pick = parseHTMLRow(row);
                    if (pick) {
                        pick.isParlay = false;
                        picks.push(pick);
                    }
                }
            } catch (e) {
                console.warn('Failed to parse HTML row:', e);
            }
        });
        return picks;
    }
    function parseParlayLeg(legEl, ticketId, parlayType, legIndex) {
        const pick = {
            sport: 'NCAAB', 
            segment: 'Full Game',
            status: 'pending'
        };
        const teamEl = legEl.querySelector('.choosen');
        if (teamEl) {
            pick.pickTeam = teamEl.textContent.trim();
            if (pick.pickTeam.includes('/')) {
                const parts = pick.pickTeam.split('/').map(s => s.trim());
                pick.awayTeam = parts[0];
                pick.homeTeam = parts[1];
            }
        }
        const lineEl = legEl.querySelector('.line-selected');
        if (lineEl) {
            const lineText = lineEl.textContent.trim();
            parseLineAndOdds(pick, lineText);
        }
        const periodEl = legEl.querySelector('.period-description-s');
        if (periodEl) {
            const periodText = periodEl.textContent.trim().toLowerCase();
            if (periodText.includes('1st half') || periodText.includes('1h')) {
                pick.segment = '1st Half';
            } else if (periodText.includes('2nd half') || periodText.includes('2h')) {
                pick.segment = '2nd Half';
            }
        }
        const icon = legEl.querySelector('img.team-logo');
        if (icon) {
            const src = icon.getAttribute('src') || '';
            if (src.includes('NBA') || src.includes('Spurs') || src.includes('Knicks')) {
                pick.sport = 'NBA';
            }
        }
        if (pick.pickTeam) {
            const teamLower = pick.pickTeam.toLowerCase();
            if (teamLower.includes('spurs') || teamLower.includes('knicks') || 
                teamLower.includes('lakers') || teamLower.includes('celtics')) {
                pick.sport = 'NBA';
            }
        }
        const dateCell = legEl.closest('tr')?.querySelector('td span');
        if (dateCell) {
            const dateText = dateCell.textContent.trim();
            const parsed = parseDateTimeString(dateText);
            if (parsed) {
                pick.date = parsed.date;
                pick.time = parsed.time;
            }
        }
        if (!pick.pickTeam || !pick.pickType) {
            return null;
        }
        return pick;
    }
    function parseHTMLRow(row) {
        const pick = {
            sport: 'NBA',
            segment: 'Full Game',
            status: 'pending'
        };
        const dateCell = row.querySelector('td span');
        if (dateCell) {
            const dateText = dateCell.textContent.trim();
            const parsed = parseDateTimeString(dateText);
            if (parsed) {
                pick.date = parsed.date;
                pick.time = parsed.time;
            }
        }
        const teamEl = row.querySelector('.choosen');
        if (teamEl) {
            pick.pickTeam = teamEl.textContent.trim();
        }
        const lineEl = row.querySelector('.line-selected');
        if (lineEl) {
            const lineText = lineEl.textContent.trim();
            parseLineAndOdds(pick, lineText);
        }
        const periodEl = row.querySelector('.period-description-s');
        if (periodEl) {
            const periodText = periodEl.textContent.trim().toLowerCase();
            if (periodText.includes('1st half') || periodText.includes('1h')) {
                pick.segment = '1st Half';
            } else if (periodText.includes('2nd half') || periodText.includes('2h')) {
                pick.segment = '2nd Half';
            } else if (periodText.includes('1st quarter') || periodText.includes('q1') || periodText.includes('1q')) {
                pick.segment = '1st Quarter';
            }
        }
        const riskEl = row.querySelector('[data-risk]');
        if (riskEl) {
            pick.risk = parseFloat(riskEl.getAttribute('data-risk')) || 0;
        } else {
            const riskText = row.querySelector('.risk-col span');
            if (riskText) {
                pick.risk = parseCurrency(riskText.textContent);
            }
        }
        const winEl = row.querySelector('[data-win]');
        if (winEl) {
            pick.win = parseFloat(winEl.getAttribute('data-win')) || 0;
        } else {
            const winText = row.querySelector('.win-col span');
            if (winText) {
                pick.win = parseCurrency(winText.textContent);
            }
        }
        const gameEl = row.querySelector('.d-r');
        if (gameEl) {
            const gameText = gameEl.textContent;
            if (gameText.includes('/') || gameText.includes(' vs ') || gameText.includes(' @ ')) {
                pick.game = gameText.trim();
                const teams = parseGameString(gameText);
                if (teams) {
                    pick.awayTeam = teams.away;
                    pick.homeTeam = teams.home;
                }
            }
        }
        const selectionEl = row.querySelector('.selection-S .d-r, .selection-M .d-r');
        if (selectionEl) {
            const selText = selectionEl.textContent.toLowerCase();
            if (selText.includes('nba')) pick.sport = 'NBA';
            else if (selText.includes('nfl')) pick.sport = 'NFL';
            else if (selText.includes('ncaab') || selText.includes('ncaam')) pick.sport = 'NCAAB';
            else if (selText.includes('ncaaf')) pick.sport = 'NCAAF';
            else if (selText.includes('mlb')) pick.sport = 'MLB';
            else if (selText.includes('nhl')) pick.sport = 'NHL';
        }
        if (!pick.pickTeam || !pick.pickType) {
            return null;
        }
        return pick;
    }
    function parseLineAndOdds(pick, text) {
        text = text.replace(/½/g, '.5').replace(/¼/g, '.25').replace(/¾/g, '.75');
        if (/\bML\b/i.test(text)) {
            pick.pickType = 'moneyline';
            const oddsMatch = text.match(/ML\s*([+-]\d+)/i);
            if (oddsMatch) {
                pick.odds = oddsMatch[1];
            }
            return;
        }
        if (/\b(over|under|o|u)\s*(\d+\.?\d*)/i.test(text)) {
            const match = text.match(/\b(over|under|o|u)\s*(\d+\.?\d*)/i);
            pick.pickType = 'total';
            pick.pickDirection = /over|o/i.test(match[1]) ? 'Over' : 'Under';
            pick.line = match[2];
            const oddsMatch = text.match(/([+-]\d{2,4})(?:\s|$)/);
            if (oddsMatch) {
                pick.odds = oddsMatch[1];
            }
            return;
        }
        const spreadMatch = text.match(/([+-]?\d+\.?\d*)\s+([+-]\d{2,4})/);
        if (spreadMatch) {
            pick.pickType = 'spread';
            pick.line = spreadMatch[1].startsWith('+') || spreadMatch[1].startsWith('-') 
                ? spreadMatch[1] 
                : '+' + spreadMatch[1];
            pick.odds = spreadMatch[2];
            return;
        }
        const lineOnly = text.match(/([+-]?\d+\.?\d*)/);
        if (lineOnly) {
            pick.pickType = 'spread';
            pick.line = lineOnly[1].startsWith('+') || lineOnly[1].startsWith('-')
                ? lineOnly[1]
                : '+' + lineOnly[1];
        }
    }
    function parsePipeDelimitedLine(line) {
        const parts = line.split('|').map(p => p.trim());
        if (parts.length < 3) return null;
        const [matchupPart, segmentPart, pickPart] = parts;
        const matchupMatch = matchupPart.match(/^(.+?)\s*(?:vs\.?|@|versus)\s*(.+)$/i);
        if (!matchupMatch) return null;
        const awayTeam = matchupMatch[1].trim();
        const homeTeam = matchupMatch[2].trim();
        let segment = 'Full Game';
        const segLower = segmentPart.toLowerCase();
        if (segLower.includes('1st half') || segLower.includes('1h')) segment = '1st Half';
        else if (segLower.includes('2nd half') || segLower.includes('2h')) segment = '2nd Half';
        else if (segLower.includes('1st quarter') || segLower.includes('1q')) segment = '1st Quarter';
        const pick = {
            sport: 'NCAAB', segment, status: 'pending', date: getTodayDate(),
            gameDate: new Date().toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' }),
            gameTime: 'TBD', awayTeam, homeTeam, game: `${awayTeam} @ ${homeTeam}`
        };
        const oddsMatch = pickPart.match(/\(([+-]?\d+)\)\s*$/);
        if (oddsMatch) pick.odds = oddsMatch[1].startsWith('+') || oddsMatch[1].startsWith('-') ? oddsMatch[1] : `-${oddsMatch[1]}`;
        let pickText = pickPart.replace(/\s*\([+-]?\d+\)\s*$/, '').trim();
        const totalMatch = pickText.match(/^(over|under|o|u)\s+(\d+\.?\d*)/i);
        if (totalMatch) {
            pick.pickType = 'total';
            pick.pickDirection = /^(over|o)$/i.test(totalMatch[1]) ? 'Over' : 'Under';
            pick.pickTeam = pick.pickDirection;
            pick.line = totalMatch[2];
            return pick;
        }
        const mlMatch = pickText.match(/^(.+?)\s+ml$/i);
        if (mlMatch) {
            pick.pickType = 'moneyline';
            pick.pickTeam = mlMatch[1].trim();
            return pick;
        }
        const spreadMatch = pickText.match(/^(.+?)\s+([+-]?\d+\.?\d*)$/);
        if (spreadMatch) {
            pick.pickType = 'spread';
            pick.pickTeam = spreadMatch[1].trim();
            const lineVal = spreadMatch[2];
            pick.line = lineVal.startsWith('+') || lineVal.startsWith('-') ? lineVal : `+${lineVal}`;
            return pick;
        }
        return null;
    }
    function parseTextPicks(text) {
        const picks = [];
        const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 0);
        let currentGame = null;
        let currentSport = 'NBA';
        for (const line of lines) {
            if (line.includes('|')) {
                const pipePick = parsePipeDelimitedLine(line);
                if (pipePick) { picks.push(pipePick); continue; }
            }
            if (shouldSkipLine(line)) {
                updateContextFromLine(line, ctx => {
                    if (ctx.sport) currentSport = ctx.sport;
                    if (ctx.game) currentGame = ctx.game;
                });
                continue;
            }
            const pick = parseTextLine(line, currentSport, currentGame);
            if (pick) {
                picks.push(pick);
            }
        }
        return picks;
    }
    function parseTextLine(line, defaultSport, defaultGame) {
        const pick = {
            sport: defaultSport,
            segment: 'Full Game',
            status: 'pending',
            date: getTodayDate()
        };
        if (/\b1h\b/i.test(line)) {
            pick.segment = '1st Half';
            line = line.replace(/\b1h\b/i, '').trim();
        } else if (/\b2h\b/i.test(line)) {
            pick.segment = '2nd Half';
            line = line.replace(/\b2h\b/i, '').trim();
        } else if (/\b1q\b/i.test(line)) {
            pick.segment = '1st Quarter';
            line = line.replace(/\b1q\b/i, '').trim();
        }
        const riskMatch = line.match(/\$(\d+(?:\.\d+)?)\s*$/);
        if (riskMatch) {
            pick.risk = parseFloat(riskMatch[1]) * unitMultiplier;
            line = line.replace(/\$\d+(?:\.\d+)?\s*$/, '').trim();
        }
        const standaloneTotal = line.match(/^(over|under|o|u)\s+(\d+\.?\d*)\s*([+-]\d{2,4})?/i);
        if (standaloneTotal) {
            pick.pickType = 'total';
            pick.pickDirection = /over|o/i.test(standaloneTotal[1]) ? 'Over' : 'Under';
            pick.pickTeam = pick.pickDirection; 
            pick.line = standaloneTotal[2];
            if (standaloneTotal[3]) {
                pick.odds = standaloneTotal[3];
            }
            if (pick.risk && pick.odds) {
                pick.win = calculateWin(pick.risk, pick.odds);
            }
            if (defaultGame) {
                pick.game = defaultGame;
            }
            return pick;
        }
        const teamMatch = line.match(/^([A-Za-z][A-Za-z\s]*?)(?=\s+[\d+-]|\s+ML|\s+over|\s+under|\s*$)/i);
        if (!teamMatch) {
            return null;
        }
        const teamName = teamMatch[1].trim();
        pick.pickTeam = resolveTeamName(teamName);
        let remainder = line.substring(teamMatch[0].length).trim();
        if (/^ML\s*/i.test(remainder)) {
            pick.pickType = 'moneyline';
            remainder = remainder.replace(/^ML\s*/i, '').trim();
            const oddsMatch = remainder.match(/^([+-]\d{2,4})/);
            if (oddsMatch) {
                pick.odds = oddsMatch[1];
            }
        }
        else if (/^(over|under|o|u)\s*/i.test(remainder)) {
            pick.pickType = 'team-total';
            const totalMatch = remainder.match(/^(over|under|o|u)\s*(\d+\.?\d*)\s*([+-]\d{2,4})?/i);
            if (totalMatch) {
                pick.pickDirection = /over|o/i.test(totalMatch[1]) ? 'Over' : 'Under';
                pick.line = totalMatch[2];
                if (totalMatch[3]) {
                    pick.odds = totalMatch[3];
                }
            }
        }
        else if (/^\d/.test(remainder) || /^[+-]\d/.test(remainder)) {
            const mlOddsMatch = remainder.match(/^([+-])(\d+)(?:\s|$)/);
            if (mlOddsMatch) {
                const sign = mlOddsMatch[1];
                const number = mlOddsMatch[2];
                const numValue = parseInt(number);
                if (numValue >= 100) {
                    pick.pickType = 'moneyline';
                    pick.odds = sign + number;
                } else {
                    pick.pickType = 'spread';
                    pick.line = sign + number;
                    const afterSpread = remainder.substring(mlOddsMatch[0].length).trim();
                    const oddsAfter = afterSpread.match(/^([+-]\d{2,4})/);
                    if (oddsAfter) {
                        pick.odds = oddsAfter[1];
                    }
                }
            } else {
                pick.pickType = 'spread';
                const spreadMatch = remainder.match(/^(\d+\.?\d*)\s*([+-]\d{2,4})?/);
                if (spreadMatch) {
                    pick.line = '+' + spreadMatch[1]; 
                    if (spreadMatch[2]) {
                        pick.odds = spreadMatch[2];
                    }
                }
            }
        }
        if (pick.risk && pick.odds) {
            pick.win = calculateWin(pick.risk, pick.odds);
        }
        if (defaultGame) {
            pick.game = defaultGame;
        }
        if (!pick.pickType) {
            return null;
        }
        return pick;
    }
    function shouldSkipLine(line) {
        const lower = line.toLowerCase();
        if (line.length < 3) return true;
        const skipPatterns = [
            /^tonight['']?s?\s+game/i,
            /^today['']?s?\s+game/i,
            /^correction/i,
            /^note:/i,
            /^fyi/i,
            /^\d+k\s+is\s+the\s+unit/i,
            /^unit/i,
            /^\^+/  
        ];
        return skipPatterns.some(p => p.test(line));
    }
    function updateContextFromLine(line, callback) {
        const lower = line.toLowerCase();
        const ctx = {};
        if (lower.includes('nba')) ctx.sport = 'NBA';
        else if (lower.includes('nfl')) ctx.sport = 'NFL';
        else if (lower.includes('ncaab') || lower.includes('ncaam')) ctx.sport = 'NCAAB';
        else if (lower.includes('ncaaf')) ctx.sport = 'NCAAF';
        else if (lower.includes('mlb')) ctx.sport = 'MLB';
        else if (lower.includes('nhl')) ctx.sport = 'NHL';
        const gameMatch = line.match(/([A-Za-z\s]+)\s*(?:vs\.?|@|\/)\s*([A-Za-z\s]+)/i);
        if (gameMatch) {
            ctx.game = `${gameMatch[1].trim()} @ ${gameMatch[2].trim()}`;
        }
        callback(ctx);
    }
    function resolveTeamName(name) {
        const lower = name.toLowerCase().trim();
        return TEAM_ALIASES[lower] || name;
    }
    function parseCurrency(text) {
        if (!text) return 0;
        const cleaned = text.replace(/[$,]/g, '');
        return parseFloat(cleaned) || 0;
    }
    function parseDateTimeString(text) {
        const match = text.match(/(\w+\s+\d+,?\s+\d{4})\s+(\d+:\d+\s*[AP]M)/i);
        if (match) {
            return {
                date: match[1].trim(),
                time: match[2].trim()
            };
        }
        return null;
    }
    function parseGameString(text) {
        const match = text.match(/(.+?)\s*(?:\/|vs\.?|@)\s*(.+)/i);
        if (match) {
            return {
                away: match[1].trim(),
                home: match[2].trim()
            };
        }
        return null;
    }
    function calculateWin(risk, odds) {
        const oddsNum = parseInt(odds);
        if (oddsNum > 0) {
            return risk * (oddsNum / 100);
        } else {
            return risk / (Math.abs(oddsNum) / 100);
        }
    }
    function getTodayDate() {
        const now = new Date();
        return `${now.getMonth() + 1}/${now.getDate()}/${now.getFullYear()}`;
    }
    function picksToDisplayFormat(picks) {
        return picks.map(pick => {
            let selection = '';
            if (pick.pickType === 'spread') {
                selection = `${pick.pickTeam} ${pick.line}`;
            } else if (pick.pickType === 'moneyline') {
                selection = `${pick.pickTeam} ML`;
            } else if (pick.pickType === 'total') {
                selection = `${pick.pickDirection || pick.pickTeam} ${pick.line}`;
            } else if (pick.pickType === 'team-total') {
                selection = `${pick.pickTeam} ${pick.pickDirection} ${pick.line}`;
            }
            if (pick.odds) {
                selection += ` (${pick.odds})`;
            }
            return {
                ...pick,
                selection,
                displaySegment: pick.segment !== 'Full Game' ? pick.segment : '',
                displayRisk: pick.risk ? `$${pick.risk.toLocaleString()}` : '',
                displayWin: pick.win ? `$${Math.round(pick.win).toLocaleString()}` : ''
            };
        });
    }
    function picksToCSV(picks) {
        const headers = ['Date', 'Time', 'Sport', 'Game', 'Team', 'Pick Type', 'Line', 'Odds', 'Segment', 'Risk', 'To Win', 'Status'];
        const rows = picks.map(pick => [
            pick.date || '',
            pick.time || '',
            pick.sport || '',
            pick.game || '',
            pick.pickTeam || '',
            pick.pickType || '',
            pick.line || '',
            pick.odds || '',
            pick.segment || '',
            pick.risk || '',
            pick.win ? Math.round(pick.win) : '',
            pick.status || 'pending'
        ]);
        return [headers, ...rows].map(row => row.map(cell => `"${cell}"`).join(',')).join('\n');
    }
    function setUnitMultiplier(multiplier) {
        unitMultiplier = multiplier;
    }
    window.PickStandardizer = {
        standardize: standardizePicks,
        parseHTML: parseHTMLPicks,
        parseGameLines: parseSportsbookGameLines,
        parseText: parseTextPicks,
        toDisplayFormat: picksToDisplayFormat,
        toCSV: picksToCSV,
        setUnitMultiplier: setUnitMultiplier,
        resolveTeamName: resolveTeamName,
        _parseTextLine: parseTextLine,
        _parseLineAndOdds: parseLineAndOdds,
        _parseGamePanel: parseGamePanel
    };
    console.log('✅ PickStandardizer v3.0 loaded');
})();
(function() {
    'use strict';
    const ActivePicks = {
        init() {
            console.log('Initializing Active Picks Module...');
            if (!this.verifyDependencies()) {
                console.error('Missing required dependencies for Active Picks');
                return;
            }
            this.initializeState();
            this.initializeFilters();
            this.initializeSorting();
            this.initializeParlays();
            this.initializeEventHandlers();
            this.initializeUI();
            this.updateTable();
            console.log('Active Picks Module initialized successfully');
        },
        verifyDependencies() {
            const required = [
                'PicksStateManager',
                'PicksTableRenderer',
                'PicksFilterManager',
                'PicksSortManager',
                'PicksDOMUtils',
                'PicksDataProcessor',
                'PicksParlayManager'
            ];
            const missing = required.filter(module => !window[module]);
            if (missing.length > 0) {
                console.error('Missing modules:', missing);
                return false;
            }
            return true;
        },
        initializeState() {
            window.PicksStateManager.init();
        },
        initializeFilters() {
            this.initHeaderFilters();
            this.initDateFilter();
            this.initMatchupFilter();
            this.initPickFilter();
            this.initRiskFilter();
            this.initStatusFilter();
        },
        initHeaderFilters() {
            const filterButtons = document.querySelectorAll('.th-filter-btn');
            filterButtons.forEach(btn => {
                if (btn.dataset.filterHandlerAttached) return;
                btn.dataset.filterHandlerAttached = 'true';
                const dropdownId = btn.getAttribute('aria-controls');
                const filterType = btn.getAttribute('data-filter');
                const dropdownEl = document.getElementById(dropdownId);
                if (dropdownEl) {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.toggleFilterDropdown(btn, dropdownEl);
                    });
                    const applyBtn = dropdownEl.querySelector('.apply-filter');
                    if (applyBtn) {
                        applyBtn.addEventListener('click', () => {
                            this.applyFilter(filterType);
                            this.closeDropdown(dropdownEl, btn);
                        });
                    }
                    const resetBtn = dropdownEl.querySelector('.reset-filter');
                    if (resetBtn) {
                        resetBtn.addEventListener('click', () => {
                            this.resetFilter(filterType);
                            this.closeDropdown(dropdownEl, btn);
                        });
                    }
                } else {
                    console.warn(`Filter dropdown not found for button: ${dropdownId}`);
                }
            });
        },
        initDateFilter() {
            const container = document.getElementById('date-filter-options');
            if (!container) return;
            this.renderDateFilterOptions();
            const selectAll = document.getElementById('date-select-all');
            if (selectAll) {
                selectAll.addEventListener('change', (e) => {
                    const checkboxes = container.querySelectorAll('input[type="checkbox"]:not(#date-select-all)');
                    checkboxes.forEach(cb => cb.checked = e.target.checked);
                });
            }
            container.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox' && e.target.id !== 'date-select-all') {
                    this.updateDateSelectAllState();
                }
            });
        },
        renderDateFilterOptions() {
            const container = document.getElementById('date-filter-options');
            if (!container) return;
            const facets = window.PicksDataProcessor.collectDateFilterFacets();
            container.innerHTML = '';
            const selectAllDiv = document.createElement('div');
            selectAllDiv.className = 'filter-option select-all-option';
            selectAllDiv.innerHTML = `
                <label>
                    <input type="checkbox" id="date-select-all" name="date-select-all">
                    <span>Select All</span>
                </label>
            `;
            container.appendChild(selectAllDiv);
            if (facets.dates.length > 0) {
                const dateGroup = document.createElement('div');
                dateGroup.className = 'filter-group';
                dateGroup.innerHTML = '<div class="filter-group-label">Dates</div>';
                facets.dates.forEach(date => {
                    const option = document.createElement('div');
                    option.className = 'filter-option';
                    option.innerHTML = `
                        <label>
                            <input type="checkbox" id="date-filter-${date.replace(/\s+/g, '-').toLowerCase()}" name="date-filter-${date.replace(/\s+/g, '-').toLowerCase()}" value="${date}" data-group="dates">
                            <span>${date}</span>
                        </label>
                    `;
                    dateGroup.appendChild(option);
                });
                container.appendChild(dateGroup);
            }
            if (facets.times.length > 0) {
                const timeGroup = document.createElement('div');
                timeGroup.className = 'filter-group';
                timeGroup.innerHTML = '<div class="filter-group-label">Times</div>';
                facets.times.forEach(time => {
                    const option = document.createElement('div');
                    option.className = 'filter-option';
                    option.innerHTML = `
                        <label>
                            <input type="checkbox" id="time-filter-${time.replace(/\s+/g, '-').toLowerCase()}" name="time-filter-${time.replace(/\s+/g, '-').toLowerCase()}" value="${time}" data-group="times">
                            <span>${time}</span>
                        </label>
                    `;
                    timeGroup.appendChild(option);
                });
                container.appendChild(timeGroup);
            }
            if (facets.books.length > 0) {
                const bookGroup = document.createElement('div');
                bookGroup.className = 'filter-group';
                bookGroup.innerHTML = '<div class="filter-group-label">Sportsbooks</div>';
                facets.books.forEach(book => {
                    const option = document.createElement('div');
                    option.className = 'filter-option';
                    option.innerHTML = `
                        <label>
                            <input type="checkbox" id="book-filter-${book.replace(/\s+/g, '-').toLowerCase()}" name="book-filter-${book.replace(/\s+/g, '-').toLowerCase()}" value="${book}" data-group="books">
                            <span>${book}</span>
                        </label>
                    `;
                    bookGroup.appendChild(option);
                });
                container.appendChild(bookGroup);
            }
        },
        updateDateSelectAllState() {
            const selectAll = document.getElementById('date-select-all');
            const checkboxes = document.querySelectorAll('#date-filter-options input[type="checkbox"]:not(#date-select-all)');
            if (selectAll && checkboxes.length > 0) {
                const checkedCount = document.querySelectorAll('#date-filter-options input[type="checkbox"]:not(#date-select-all):checked').length;
                if (checkedCount === 0) {
                    selectAll.checked = false;
                    selectAll.indeterminate = false;
                } else if (checkedCount === checkboxes.length) {
                    selectAll.checked = true;
                    selectAll.indeterminate = false;
                } else {
                    selectAll.checked = false;
                    selectAll.indeterminate = true;
                }
            }
        },
        initMatchupFilter() {
            const leagueSelect = document.getElementById('league-select');
            if (leagueSelect) {
                this.populateLeagueDropdown();
                leagueSelect.addEventListener('change', (e) => {
                    this.populateTeamsList(e.target.value);
                });
            }
            const teamsSelectAll = document.getElementById('teams-select-all');
            if (teamsSelectAll) {
                teamsSelectAll.addEventListener('change', (e) => {
                    const checkboxes = document.querySelectorAll('#teams-list input[type="checkbox"]:not(#teams-select-all)');
                    checkboxes.forEach(cb => cb.checked = e.target.checked);
                });
            }
            const ticketRadios = document.querySelectorAll('input[name="ticket-type"]');
            ticketRadios.forEach(radio => {
                radio.addEventListener('change', () => {
                    window.tableState.filters.matchup.ticketType = radio.value;
                });
            });
        },
        populateLeagueDropdown() {
            const select = document.getElementById('league-select');
            if (!select) return;
            const leagues = window.PicksDataProcessor.getLeaguesFromTable();
            select.innerHTML = '<option value="">All Leagues</option>';
            leagues.forEach(league => {
                const option = document.createElement('option');
                option.value = league;
                option.textContent = league;
                select.appendChild(option);
            });
        },
        populateTeamsList(league) {
            const container = document.getElementById('teams-list');
            if (!container) return;
            container.innerHTML = '';
            if (!league) {
                container.innerHTML = '<div class="no-selection">Select a league first</div>';
                return;
            }
            const teams = window.PicksDataProcessor.getTeamsForLeague(league);
            if (teams.length === 0) {
                container.innerHTML = '<div class="no-teams">No teams found</div>';
                return;
            }
            const selectAllDiv = document.createElement('div');
            selectAllDiv.className = 'filter-option select-all-option';
            selectAllDiv.innerHTML = `
                <label>
                    <input type="checkbox" id="teams-select-all" name="teams-select-all">
                    <span>Select All Teams</span>
                </label>
            `;
            container.appendChild(selectAllDiv);
            teams.forEach(team => {
                const option = document.createElement('div');
                option.className = 'filter-option';
                    const teamId = team.replace(/\s+/g, '-').toLowerCase();
                    option.innerHTML = `
                        <label>
                            <input type="checkbox" id="team-filter-${teamId}" name="team-filter-${teamId}" value="${team}">
                            <span>${window.PicksDOMUtils.formatTeamName(team)}</span>
                        </label>
                    `;
                container.appendChild(option);
            });
        },
        initPickFilter() {
            const betTypes = window.PicksDataProcessor.collectBetTypes();
            const betTypeSelect = document.getElementById('bet-type-select');
            if (betTypeSelect) {
                betTypeSelect.innerHTML = '<option value="">All Types</option>';
                betTypes.types.forEach(type => {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = window.PicksDOMUtils.formatBetTypeLabel(type);
                    betTypeSelect.appendChild(option);
                });
            }
            const subtypeSelect = document.getElementById('subtype-select');
            if (subtypeSelect) {
                subtypeSelect.innerHTML = '<option value="">All Subtypes</option>';
                betTypes.subtypes.forEach(subtype => {
                    const option = document.createElement('option');
                    option.value = subtype;
                    option.textContent = window.PicksDOMUtils.formatSubtypeLabel(subtype);
                    subtypeSelect.appendChild(option);
                });
            }
            const segmentSelect = document.getElementById('segment-select');
            if (segmentSelect) {
                segmentSelect.innerHTML = `
                    <option value="">All Segments</option>
                    <option value="game">Full Game</option>
                    <option value="1h">1st Half</option>
                    <option value="2h">2nd Half</option>
                `;
            }
        },
        initRiskFilter() {
            const riskRanges = window.PicksDataProcessor.collectValueRanges(4);
            const winRanges = window.PicksDataProcessor.collectValueRanges(5);
            const riskContainer = document.getElementById('risk-ranges');
            if (riskContainer && riskRanges.length > 0) {
                riskContainer.innerHTML = '<div class="filter-group-label">Risk Amount</div>';
                riskRanges.forEach(range => {
                    const option = document.createElement('div');
                    option.className = 'filter-option';
                    const rangeId = range.replace(/\s+/g, '-').toLowerCase().replace(/[<>]/g, '');
                    option.innerHTML = `
                        <label>
                            <input type="checkbox" id="risk-range-${rangeId}" name="risk-range-${rangeId}" value="${range}">
                            <span>${window.PicksDOMUtils.formatRangeLabel(range)}</span>
                        </label>
                    `;
                    riskContainer.appendChild(option);
                });
            }
            const winContainer = document.getElementById('win-ranges');
            if (winContainer && winRanges.length > 0) {
                winContainer.innerHTML = '<div class="filter-group-label">Win Amount</div>';
                winRanges.forEach(range => {
                    const option = document.createElement('div');
                    option.className = 'filter-option';
                    const rangeId = range.replace(/\s+/g, '-').toLowerCase().replace(/[<>]/g, '');
                    option.innerHTML = `
                        <label>
                            <input type="checkbox" id="win-range-${rangeId}" name="win-range-${rangeId}" value="${range}">
                            <span>${window.PicksDOMUtils.formatRangeLabel(range)}</span>
                        </label>
                    `;
                    winContainer.appendChild(option);
                });
            }
        },
        initStatusFilter() {
            const container = document.getElementById('status-filter-options');
            if (!container) return;
            const statuses = window.PicksDataProcessor.collectStatusValues();
            container.innerHTML = '';
            statuses.forEach(status => {
                const option = document.createElement('div');
                option.className = 'filter-option';
                const statusId = status.replace(/\s+/g, '-').toLowerCase();
                option.innerHTML = `
                    <label>
                        <input type="checkbox" id="status-filter-${statusId}" name="status-filter-${statusId}" value="${status}">
                        <span>${window.PicksDOMUtils.formatBadgeStatus(status)}</span>
                    </label>
                `;
                container.appendChild(option);
            });
        },
        initializeSorting() {
            window.PicksSortManager.initSorting();
        },
        initializeParlays() {
            window.PicksParlayManager.initParlays();
        },
        initializeUI() {
            const chipsContainer = document.querySelector('.filter-chips');
            if (!chipsContainer) {
                const header = document.querySelector('.header-controls');
                if (header) {
                    const chips = document.createElement('div');
                    chips.className = 'filter-chips';
                    header.appendChild(chips);
                }
            }
            const clearAllBtn = document.getElementById('clear-all-filters');
            if (clearAllBtn) {
                clearAllBtn.addEventListener('click', () => {
                    this.clearAllFilters();
                });
            }
        },
        initializeEventHandlers() {
            const refreshBtn = document.getElementById('refresh-data');
            if (refreshBtn) {
                refreshBtn.addEventListener('click', () => {
                    this.refreshData();
                });
            }
            const exportBtn = document.getElementById('export-data');
            if (exportBtn) {
                exportBtn.addEventListener('click', () => {
                    this.exportData();
                });
            }
        },
        toggleFilterDropdown(btn, dropdown) {
            const isOpen = dropdown.classList.contains('open');
            this.closeAllFilterDropdowns();
            if (!isOpen) {
                dropdown.removeAttribute('hidden');
                dropdown.classList.add('open');
                btn.setAttribute('aria-expanded', 'true');
                if (window.PicksDOMUtils && window.PicksDOMUtils.positionDropdown) {
                    window.PicksDOMUtils.positionDropdown(btn, dropdown);
                }
            }
        },
        closeAllFilterDropdowns() {
            document.querySelectorAll('.th-filter-dropdown.open').forEach(dropdown => {
                dropdown.classList.remove('open');
                dropdown.setAttribute('hidden', '');
                const btn = document.querySelector(`[aria-controls="${dropdown.id}"]`);
                if (btn) {
                    btn.setAttribute('aria-expanded', 'false');
                }
            });
        },
        closeDropdown(dropdown, btn) {
            dropdown.classList.remove('open');
            dropdown.setAttribute('hidden', '');
            if (btn) {
                btn.setAttribute('aria-expanded', 'false');
            }
        },
        applyFilter(type) {
            window.PicksFilterManager.applyFilter(type);
            window.PicksTableRenderer.updateFilterIndicators();
        },
        resetFilter(type) {
            window.PicksFilterManager.resetFilter(type);
            window.PicksTableRenderer.updateFilterIndicators();
        },
        clearAllFilters() {
            window.PicksStateManager.resetAllFilters();
            window.PicksTableRenderer.updateTable();
            window.PicksTableRenderer.updateFilterIndicators();
            document.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
            document.querySelectorAll('select').forEach(select => select.value = '');
            document.querySelectorAll('input[type="radio"][value="all"]').forEach(radio => radio.checked = true);
        },
        updateTable() {
            window.PicksTableRenderer.updateTable();
        },
        refreshData() {
            console.log('Refreshing data...');
            window.location.reload();
        },
        exportData() {
            console.log('Exporting data...');
            const rows = document.querySelectorAll('#picks-tbody tr:not(.parlay-legs)');
            const visibleRows = Array.from(rows).filter(row => row.style.display !== 'none');
            let csv = 'Date/Time,Matchup,Pick,Risk,Win,Status\n';
            visibleRows.forEach(row => {
                const cells = row.querySelectorAll('td');
                const rowData = Array.from(cells).map(cell => {
                    const text = cell.textContent.trim().replace(/,/g, ';');
                    return `"${text}"`;
                });
                csv += rowData.join(',') + '\n';
            });
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `picks-export-${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }
    };
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => ActivePicks.init());
    } else {
        ActivePicks.init();
    }
    window.ActivePicks = ActivePicks;
})();
(function() {
    'use strict';
    const NBA_API_URL = window.APP_CONFIG?.NBA_API_URL || 'https://www.greenbiersportventures.com';
    let picksCache = null;
    let lastFetch = null;
    const CACHE_DURATION = 60000; 
    async function fetchNBAPicks(date = 'today') {
        if (picksCache && lastFetch && (Date.now() - lastFetch < CACHE_DURATION)) {
            console.log('[NBA-PICKS] Using cached picks');
            return picksCache;
        }
        const url = `${NBA_API_URL}/slate/${date}/executive`;
        console.log(`[NBA-PICKS] Fetching picks from: ${url}`);
        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`NBA API error: ${response.status}`);
            }
            const data = await response.json();
            picksCache = data;
            lastFetch = Date.now();
            console.log(`[NBA-PICKS] Fetched ${data.total_plays || 0} picks`);
            return data;
        } catch (error) {
            console.error('[NBA-PICKS] Error fetching picks:', error.message);
            throw error;
        }
    }
    async function fetchFullSlate(date = 'today') {
        const url = `${NBA_API_URL}/slate/${date}`;
        console.log(`[NBA-PICKS] Fetching full slate from: ${url}`);
        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`NBA API error: ${response.status}`);
            }
            return await response.json();
        } catch (error) {
            console.error('[NBA-PICKS] Error fetching slate:', error.message);
            throw error;
        }
    }
    async function checkHealth() {
        const url = `${NBA_API_URL}/health`;
        try {
            const response = await fetch(url);
            return await response.json();
        } catch (error) {
            console.error('[NBA-PICKS] Health check failed:', error.message);
            return { status: 'error', message: error.message };
        }
    }
    function formatPickForTable(pick) {
        return {
            sport: 'NBA',
            game: `${pick.away_team} @ ${pick.home_team}`,
            pick: pick.pick_display || pick.pick,
            odds: pick.odds || pick.market_odds,
            edge: pick.edge ? `${(pick.edge * 100).toFixed(1)}%` : '',
            confidence: pick.fire_rating || pick.confidence || '',
            time: pick.game_time || '',
            market: pick.market_type || pick.market,
            period: pick.period || 'FG'
        };
    }
    window.NBAPicksFetcher = {
        fetchPicks: fetchNBAPicks,
        fetchFullSlate,
        checkHealth,
        formatPickForTable,
        getCache: () => picksCache,
        clearCache: () => { picksCache = null; lastFetch = null; }
    };
    console.log('✅ NBAPicksFetcher v1.0 loaded');
})();