name: Deploy Complete Model System

# This workflow should ONLY be triggered manually via workflow_dispatch
# It requires input parameters and should not run on push
on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - production
          - staging
          - development
        default: production
      deploy_orchestrator:
        description: 'Deploy orchestrator'
        type: boolean
        default: true
      deploy_monitoring:
        description: 'Deploy monitoring'
        type: boolean
        default: true
      initialize_registry:
        description: 'Initialize model registry'
        type: boolean
        default: true

# Prevent any accidental triggers - only run on manual dispatch
concurrency:
  group: deploy-complete-system
  cancel-in-progress: false

env:
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  RESOURCE_GROUP: dashboard-gbsv-main-rg
  ORCHESTRATOR_NAME: gbsv-orchestrator
  ACR_NAME: gbsvregistry
  STORAGE_ACCOUNT: gbsvorchestratorstorage

jobs:
  validate:
    name: Validate Configuration
    runs-on: ubuntu-latest
    # Only run on manual workflow_dispatch - never on push
    if: github.event_name == 'workflow_dispatch'
    outputs:
      config_valid: ${{ steps.validate.outputs.valid }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Validate deployment config
        id: validate
        run: |
          if [ ! -f "deployment-config.json" ]; then
            echo "deployment-config.json not found"
            echo "valid=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Validate JSON syntax
          jq empty deployment-config.json
          if [ $? -ne 0 ]; then
            echo "Invalid JSON in deployment-config.json"
            echo "valid=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "valid=true" >> $GITHUB_OUTPUT
          echo "âœ… Configuration validated"

  setup-infrastructure:
    name: Setup Azure Infrastructure
    needs: validate
    if: github.event_name == 'workflow_dispatch' && needs.validate.outputs.config_valid == 'true'
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment || 'production' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Azure Login
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          
      - name: Create Resource Group
        run: |
          az group create \
            --name ${{ env.RESOURCE_GROUP }} \
            --location eastus \
            --tags Environment=${{ inputs.environment || 'production' }} Project=GBSV
            
      - name: Create Storage Account
        run: |
          # Check if exists
          if ! az storage account show --name ${{ env.STORAGE_ACCOUNT }} --resource-group ${{ env.RESOURCE_GROUP }} 2>/dev/null; then
            echo "Creating storage account..."
            az storage account create \
              --name ${{ env.STORAGE_ACCOUNT }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --location eastus \
              --sku Standard_LRS \
              --kind StorageV2 \
              --allow-blob-public-access false
          else
            echo "Storage account already exists"
          fi
          
      - name: Create Storage Tables
        run: |
          CONNECTION_STRING=$(az storage account show-connection-string \
            --name ${{ env.STORAGE_ACCOUNT }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query connectionString -o tsv)
            
          # Create tables
          for table in modelregistry modelexecutions; do
            if [ "$(az storage table exists --name $table --connection-string "$CONNECTION_STRING" --query exists -o tsv)" != "true" ]; then
              echo "Creating table: $table"
              az storage table create --name $table --connection-string "$CONNECTION_STRING"
            else
              echo "Table $table already exists"
            fi
          done
          
      - name: Create Blob Containers
        run: |
          CONNECTION_STRING=$(az storage account show-connection-string \
            --name ${{ env.STORAGE_ACCOUNT }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query connectionString -o tsv)
            
          # Create containers
          for container in model-results model-logs model-artifacts; do
            if [ "$(az storage container exists --name $container --connection-string "$CONNECTION_STRING" --query exists -o tsv)" != "true" ]; then
              echo "Creating container: $container"
              az storage container create --name $container --connection-string "$CONNECTION_STRING" --public-access off
            else
              echo "Container $container already exists"
            fi
          done

  deploy-monitoring:
    name: Deploy Monitoring Resources
    needs: setup-infrastructure
    if: github.event_name == 'workflow_dispatch' && inputs.deploy_monitoring
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment || 'production' }}
    outputs:
      app_insights_key: ${{ steps.appinsights.outputs.instrumentation_key }}
      app_insights_connection: ${{ steps.appinsights.outputs.connection_string }}
      
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          
      - name: Create Log Analytics Workspace
        run: |
          WORKSPACE_NAME="gbsv-logs"
          
          if ! az monitor log-analytics workspace show --workspace-name $WORKSPACE_NAME --resource-group ${{ env.RESOURCE_GROUP }} 2>/dev/null; then
            echo "Creating Log Analytics workspace..."
            az monitor log-analytics workspace create \
              --workspace-name $WORKSPACE_NAME \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --location eastus \
              --retention-time 30
          else
            echo "Log Analytics workspace already exists"
          fi
          
      - name: Create Application Insights
        id: appinsights
        run: |
          APP_INSIGHTS_NAME="gbsv-orchestrator-insights"
          WORKSPACE_NAME="gbsv-logs"
          
          if ! az monitor app-insights component show --app $APP_INSIGHTS_NAME --resource-group ${{ env.RESOURCE_GROUP }} 2>/dev/null; then
            echo "Creating Application Insights..."
            az monitor app-insights component create \
              --app $APP_INSIGHTS_NAME \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --location eastus \
              --workspace $WORKSPACE_NAME \
              --application-type web
          else
            echo "Application Insights already exists"
          fi
          
          # Get keys
          INSTRUMENTATION_KEY=$(az monitor app-insights component show \
            --app $APP_INSIGHTS_NAME \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query instrumentationKey -o tsv)
            
          CONNECTION_STRING=$(az monitor app-insights component show \
            --app $APP_INSIGHTS_NAME \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query connectionString -o tsv)
            
          echo "instrumentation_key=$INSTRUMENTATION_KEY" >> $GITHUB_OUTPUT
          echo "connection_string=$CONNECTION_STRING" >> $GITHUB_OUTPUT

  deploy-signalr:
    name: Deploy SignalR Service
    needs: setup-infrastructure
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment || 'production' }}
    outputs:
      signalr_connection: ${{ steps.signalr.outputs.connection_string }}
      
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          
      - name: Create SignalR Service
        id: signalr
        run: |
          SIGNALR_NAME="gbsv-signalr"
          
          if ! az signalr show --name $SIGNALR_NAME --resource-group ${{ env.RESOURCE_GROUP }} 2>/dev/null; then
            echo "Creating SignalR service..."
            az signalr create \
              --name $SIGNALR_NAME \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --location eastus \
              --sku Free_F1 \
              --service-mode Serverless
          else
            echo "SignalR service already exists"
          fi
          
          # Configure CORS
          az signalr cors update \
            --name $SIGNALR_NAME \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --allowed-origins "https://wittypebble-41c11c65.eastus.azurestaticapps.net" "http://localhost:*"
            
          # Get connection string
          CONNECTION_STRING=$(az signalr key show \
            --name $SIGNALR_NAME \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query primaryConnectionString -o tsv)
            
          echo "::add-mask::$CONNECTION_STRING"
          echo "connection_string=$CONNECTION_STRING" >> $GITHUB_OUTPUT

  build-orchestrator:
    name: Build Orchestrator Image
    needs: [deploy-monitoring, deploy-signalr]
    if: github.event_name == 'workflow_dispatch' && inputs.deploy_orchestrator
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment || 'production' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Azure Login
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          
      - name: Create Container Registry
        run: |
          if ! az acr show --name ${{ env.ACR_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} 2>/dev/null; then
            echo "Creating Azure Container Registry..."
            az acr create \
              --name ${{ env.ACR_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --location eastus \
              --sku Basic \
              --admin-enabled true
          else
            echo "Container Registry already exists"
          fi
          
      - name: Get ACR Credentials
        id: acr
        run: |
          LOGIN_SERVER=$(az acr show --name ${{ env.ACR_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} --query loginServer -o tsv)
          PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} --query "passwords[0].value" -o tsv)
          
          echo "::add-mask::$PASSWORD"
          echo "login_server=$LOGIN_SERVER" >> $GITHUB_OUTPUT
          echo "password=$PASSWORD" >> $GITHUB_OUTPUT
          
      - name: Build and Push Image
        run: |
          cd azure-functions
          
          # Create Dockerfile if it doesn't exist
          if [ ! -f Dockerfile ]; then
            cat > Dockerfile << 'EOF'
FROM mcr.microsoft.com/azure-functions/node:4-node18

ENV AzureWebJobsScriptRoot=/home/site/wwwroot \
    AzureFunctionsJobHost__Logging__Console__IsEnabled=true

WORKDIR /home/site/wwwroot

COPY package*.json ./
RUN npm ci --only=production

COPY . .

HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD node -e "require('http').get('http://localhost:80/api/health', (r) => process.exit(r.statusCode === 200 ? 0 : 1))"

EXPOSE 80
EOF
          fi
          
          # Build image
          IMAGE_TAG="${{ inputs.environment || 'production' }}-$(date +%Y%m%d-%H%M%S)"
          docker build -t ${{ env.ORCHESTRATOR_NAME }}:$IMAGE_TAG .
          
          # Tag and push
          docker tag ${{ env.ORCHESTRATOR_NAME }}:$IMAGE_TAG ${{ steps.acr.outputs.login_server }}/${{ env.ORCHESTRATOR_NAME }}:$IMAGE_TAG
          docker tag ${{ env.ORCHESTRATOR_NAME }}:$IMAGE_TAG ${{ steps.acr.outputs.login_server }}/${{ env.ORCHESTRATOR_NAME }}:latest
          
          echo "${{ steps.acr.outputs.password }}" | docker login ${{ steps.acr.outputs.login_server }} -u ${{ env.ACR_NAME }} --password-stdin
          
          docker push ${{ steps.acr.outputs.login_server }}/${{ env.ORCHESTRATOR_NAME }}:$IMAGE_TAG
          docker push ${{ steps.acr.outputs.login_server }}/${{ env.ORCHESTRATOR_NAME }}:latest
          
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

  deploy-orchestrator:
    name: Deploy Orchestrator Container App
    needs: build-orchestrator
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment || 'production' }}
    outputs:
      orchestrator_url: ${{ steps.deploy.outputs.url }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Azure Login
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          
      - name: Create Container App Environment
        run: |
          ENV_NAME="gbsv-aca-env"
          WORKSPACE_NAME="gbsv-logs"
          
          if ! az containerapp env show --name $ENV_NAME --resource-group ${{ env.RESOURCE_GROUP }} 2>/dev/null; then
            echo "Creating Container App Environment..."
            
            WORKSPACE_ID=$(az monitor log-analytics workspace show \
              --workspace-name $WORKSPACE_NAME \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --query customerId -o tsv)
              
            WORKSPACE_KEY=$(az monitor log-analytics workspace get-shared-keys \
              --workspace-name $WORKSPACE_NAME \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --query primarySharedKey -o tsv)
              
            az containerapp env create \
              --name $ENV_NAME \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --location eastus \
              --logs-workspace-id $WORKSPACE_ID \
              --logs-workspace-key $WORKSPACE_KEY
          else
            echo "Container App Environment already exists"
          fi
          
      - name: Deploy Container App
        id: deploy
        run: |
          # Get connection strings
          STORAGE_CONNECTION=$(az storage account show-connection-string \
            --name ${{ env.STORAGE_ACCOUNT }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query connectionString -o tsv)
            
          ACR_LOGIN=$(az acr show --name ${{ env.ACR_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} --query loginServer -o tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} --query "passwords[0].value" -o tsv)
          
          # Read config for model endpoints
          NBA_URL=$(jq -r '.models.nba.endpoint' deployment-config.json)
          NCAAM_URL=$(jq -r '.models.ncaam.endpoint' deployment-config.json)
          NFL_URL=$(jq -r '.models.nfl.endpoint' deployment-config.json)
          NCAAF_URL=$(jq -r '.models.ncaaf.endpoint' deployment-config.json)
          DASHBOARD_URL=$(jq -r '.dashboard.url' deployment-config.json)
          
          # Create or update Container App
          if ! az containerapp show --name ${{ env.ORCHESTRATOR_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} 2>/dev/null; then
            echo "Creating Container App..."
            
            az containerapp create \
              --name ${{ env.ORCHESTRATOR_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --environment gbsv-aca-env \
              --image "$ACR_LOGIN/${{ env.ORCHESTRATOR_NAME }}:latest" \
              --target-port 80 \
              --ingress 'external' \
              --registry-server $ACR_LOGIN \
              --registry-username ${{ env.ACR_NAME }} \
              --registry-password "$ACR_PASSWORD" \
              --cpu 0.5 \
              --memory 1.0 \
              --min-replicas 1 \
              --max-replicas 10 \
              --env-vars \
                "AzureWebJobsStorage=$STORAGE_CONNECTION" \
                "AZURE_SIGNALR_CONNECTION_STRING=${{ needs.deploy-signalr.outputs.signalr_connection }}" \
                "APPINSIGHTS_INSTRUMENTATIONKEY=${{ needs.deploy-monitoring.outputs.app_insights_key }}" \
                "APPLICATIONINSIGHTS_CONNECTION_STRING=${{ needs.deploy-monitoring.outputs.app_insights_connection }}" \
                "MODEL_REGISTRY_TABLE=modelregistry" \
                "NBA_API_URL=$NBA_URL" \
                "NCAAM_API_URL=$NCAAM_URL" \
                "NFL_API_URL=$NFL_URL" \
                "NCAAF_API_URL=$NCAAF_URL" \
                "CORS_ALLOWED_ORIGINS=$DASHBOARD_URL" \
                "ENVIRONMENT=${{ inputs.environment || 'production' }}"
          else
            echo "Updating Container App..."
            
            az containerapp update \
              --name ${{ env.ORCHESTRATOR_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --image "$ACR_LOGIN/${{ env.ORCHESTRATOR_NAME }}:latest"
          fi
          
          # Enable managed identity
          az containerapp identity assign \
            --name ${{ env.ORCHESTRATOR_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --system-assigned
            
          # Get URL
          ORCHESTRATOR_URL="https://$(az containerapp show \
            --name ${{ env.ORCHESTRATOR_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query 'properties.configuration.ingress.fqdn' -o tsv)"
            
          echo "url=$ORCHESTRATOR_URL" >> $GITHUB_OUTPUT
          echo "âœ… Orchestrator deployed: $ORCHESTRATOR_URL"

  setup-rbac:
    name: Setup RBAC Permissions
    needs: deploy-orchestrator
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment || 'production' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Azure Login
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          
      - name: Grant RBAC Permissions
        run: |
          # Get managed identity ID
          IDENTITY_ID=$(az containerapp identity show \
            --name ${{ env.ORCHESTRATOR_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query principalId -o tsv)
            
          if [ -z "$IDENTITY_ID" ]; then
            echo "âŒ Failed to get managed identity ID"
            exit 1
          fi
          
          echo "Managed Identity ID: $IDENTITY_ID"
          
          # Grant permissions to model resource groups
          for rg in nba-gbsv-model-rg ncaam-gbsv-model-rg nfl-gbsv-model-rg ncaaf-gbsv-model-rg; do
            echo "Granting Contributor role to $rg..."
            az role assignment create \
              --assignee $IDENTITY_ID \
              --role "Contributor" \
              --scope "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/$rg" 2>/dev/null || true
          done
          
          # Grant Storage Blob Data Contributor
          echo "Granting Storage Blob Data Contributor role..."
          az role assignment create \
            --assignee $IDENTITY_ID \
            --role "Storage Blob Data Contributor" \
            --scope "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.RESOURCE_GROUP }}/providers/Microsoft.Storage/storageAccounts/${{ env.STORAGE_ACCOUNT }}" 2>/dev/null || true

  initialize-registry:
    name: Initialize Model Registry
    needs: deploy-orchestrator
    if: github.event_name == 'workflow_dispatch' && inputs.initialize_registry
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment || 'production' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Initialize Registry
        run: |
          ORCHESTRATOR_URL="${{ needs.deploy-orchestrator.outputs.orchestrator_url }}"
          
          # Read model endpoints from config
          NBA_URL=$(jq -r '.models.nba.endpoint' deployment-config.json)
          NCAAM_URL=$(jq -r '.models.ncaam.endpoint' deployment-config.json)
          NFL_URL=$(jq -r '.models.nfl.endpoint' deployment-config.json)
          NCAAF_URL=$(jq -r '.models.ncaaf.endpoint' deployment-config.json)
          
          # Register each model
          for model in nba ncaam nfl ncaaf; do
            ENDPOINT_VAR="${model^^}_URL"
            ENDPOINT="${!ENDPOINT_VAR}"
            
            echo "Registering $model: $ENDPOINT"
            
            curl -X POST "$ORCHESTRATOR_URL/api/registry/update" \
              -H "Content-Type: application/json" \
              -d "{
                \"model\": \"$model\",
                \"endpoint\": \"$ENDPOINT\",
                \"version\": \"1.0.0\",
                \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
              }" || true
          done
          
          # Verify registry
          echo "Verifying registry..."
          curl "$ORCHESTRATOR_URL/api/registry" | jq .

  test-deployment:
    name: Test Deployment
    needs: [deploy-orchestrator, initialize-registry]
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment || 'production' }}
    
    steps:
      - name: Test Health Endpoint
        run: |
          ORCHESTRATOR_URL="${{ needs.deploy-orchestrator.outputs.orchestrator_url }}"
          
          echo "Testing health endpoint..."
          HEALTH_RESPONSE=$(curl -s "$ORCHESTRATOR_URL/api/health")
          echo "Health response:"
          echo "$HEALTH_RESPONSE" | jq .
          
          STATUS=$(echo "$HEALTH_RESPONSE" | jq -r '.status')
          if [ "$STATUS" != "healthy" ] && [ "$STATUS" != "degraded" ]; then
            echo "âŒ Health check failed: $STATUS"
            exit 1
          fi
          
          echo "âœ… Health check passed: $STATUS"
          
      - name: Test Registry Endpoint
        run: |
          ORCHESTRATOR_URL="${{ needs.deploy-orchestrator.outputs.orchestrator_url }}"
          
          echo "Testing registry endpoint..."
          REGISTRY_RESPONSE=$(curl -s "$ORCHESTRATOR_URL/api/registry")
          echo "Registry response:"
          echo "$REGISTRY_RESPONSE" | jq .
          
          # Check that all models are registered
          for model in nba ncaam nfl ncaaf; do
            ENDPOINT=$(echo "$REGISTRY_RESPONSE" | jq -r ".$model.endpoint")
            if [ "$ENDPOINT" == "null" ] || [ -z "$ENDPOINT" ]; then
              echo "âŒ Model $model not found in registry"
              exit 1
            fi
            echo "âœ… Model $model registered: $ENDPOINT"
          done

  deployment-summary:
    name: Deployment Summary
    needs: [deploy-orchestrator, test-deployment]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Generate Summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # ðŸš€ GBSV Model System Deployment Summary
          
          ## Environment: ${{ inputs.environment || 'production' }}
          
          ### âœ… Deployed Resources
          
          | Resource | Status | URL/Details |
          |----------|--------|-------------|
          | Orchestrator | âœ… Deployed | ${{ needs.deploy-orchestrator.outputs.orchestrator_url }} |
          | Storage Account | âœ… Created | ${{ env.STORAGE_ACCOUNT }} |
          | SignalR Service | âœ… Deployed | gbsv-signalr |
          | Application Insights | âœ… Configured | gbsv-orchestrator-insights |
          | Container Registry | âœ… Created | ${{ env.ACR_NAME }} |
          
          ### ðŸ“‹ Next Steps
          
          1. Update GitHub Secrets:
             - \`ORCHESTRATOR_URL\`: ${{ needs.deploy-orchestrator.outputs.orchestrator_url }}/api
             - \`AZURE_SUBSCRIPTION_ID\`: ${{ env.AZURE_SUBSCRIPTION_ID }}
          
          2. Configure model repositories to notify orchestrator on deploy
          
          3. Test the orchestrator:
             \`\`\`bash
             curl -X GET ${{ needs.deploy-orchestrator.outputs.orchestrator_url }}/api/registry
             \`\`\`
          
          4. Monitor deployment in Azure Portal:
             - Resource Group: ${{ env.RESOURCE_GROUP }}
             - Application Insights: gbsv-orchestrator-insights
          
          ### ðŸ“Š Deployment Time
          - Started: ${{ github.event.head_commit.timestamp || github.event.repository.updated_at }}
          - Completed: $(date -u +%Y-%m-%dT%H:%M:%SZ)
          
          ---
          
          **Deployment ID**: ${{ github.run_id }}
          **Triggered by**: @${{ github.actor }}
          EOF